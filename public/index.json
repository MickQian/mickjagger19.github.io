[{"content":"Sweep Line Meet In the Middle Find minimum diffs Calculate the sum, get the target, iterator num_cnt on one part of the half Partition Array Into Two Arrays to Minimize Sum Difference Kadane\u0026rsquo;s Algorithm Maximum Subarray, find the subarray with the largest sum, and return its sum Just like sliding window, but in this case, the sum of the subarray is calculated. So when current subarray\u0026rsquo;s sum is negative, instead of moving the start pointer forward until invalid, the remaining window is always empty, so we should set the start pointer to current end pointer Applies to all kinds of subarray, counting the max subarray value(could be occurence) Maximum subarray problem\nint max_subarray(vector\u0026lt;int\u0026gt;\u0026amp; numbers){ // Find the largest sum of any contiguous subarray. int best_sum = 0 int current_sum = 0 for (auto x : numbers){ current_sum = max(0, current_sum + x); best_sum = max(best_sum, current_sum); } return best_sum; } Sliding Window To find range that meets requirement Valid, when :\nafter a valid window, the end pointer needs to move forward to accept new elements when the end pointer moves forward, the start pointer has to move forward to make the window valid again. Find minimum diffs Calculate the sum, get the target, iterator num_cnt on one part of the half Partition Array Into Two Arrays to Minimize Sum Difference long long countSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums, long long k) { long long sum = 0, res = 0; for (int i = 0, j = 0; i \u0026lt; nums.size(); ++i) { sum += nums[i]; while (sum * (i - j + 1) \u0026gt;= k) sum -= nums[j++]; res += i - j + 1; } return res; } Merge Sorts merge process naturally fetch every two items from two sorted sub-arrays, and each item get to combined each item from the right at least once.\nint i = 0, mid = ( i + n ) / 2, j = mid; while (i \u0026lt; mid \u0026amp;\u0026amp; j \u0026lt; n){ // each i in 0~mid have at least one combination to mid~n - 1 if (nums[i++] \u0026lt; nums[j++]){ temp[cnt++] = nums[i++]; } else { temp[cnt++] = nums[j++]; } } Boyer-Morre majority Vote for elements appear at least n / k times, maintain k candidates:\nfor (auto\u0026amp; num : nums){ for (auto\u0026amp; [can,cnt]: candidates){ if (cnt == 0){ can = num, cnt = 0; } } } // check if the candidate appears at leask k times KMP Generate the table\n// kmp: [the index of the matching string] = [the index in the pattern string] vector\u0026lt;int\u0026gt; kmp(evil.size()); for (auto j = 0, i = 1; i \u0026lt; kmp.size(); ++i) { if (evil[i] == evil[j]) kmp[i] = ++j; else if (j \u0026gt; 0) { j = kmp[j - 1]; // recursive step back, to get the max matching len --i; } } use the table as a tool, to determine if a string contains a pattern\nwhile (n_ep \u0026gt; 0 \u0026amp;\u0026amp; ch != evil[n_ep]){ // calculate the max matching len of the character n_ep = kmp[n_ep - 1]; } Rabin-Karp To check existence of exactly equal substrings Time Complexity: O(len) Rolling-hash to encode the seen string pattern in the set, check each hash value with the set\nfor (int i = 0; i \u0026lt; n; i++){ hash = (hash * 26 + s[i] - s[i - k] * pow(26, p)) % mod; } Find the longest duplicate substring Binary Search + Rabin-Karp will do Longest Duplicate Substring Reservior Sampling chance of placing cur item into reservior is $reservior_cnt/item_index$\n(* S has items to sample, R will contain the result *) ReservoirSample(S[1..n], R[1..k]) // fill the reservoir array for i := 1 to k R[i] := S[i] // replace elements with gradually decreasing probability for i := k+1 to n // (* randomInteger(a, b) generates a uniform integer from the inclusive range {a, ..., b} *) j := randomInteger(1, i) if j \u0026lt;= k R[j] := S[i] Binomial Coefficients Stars and Bars: placing m bars in n numbers = choosing n locations from m = number of partition array of n into m subarray\nForming an array of size n, with m consecutive unique numbers = placing m bars as transition in n numbers\n// pascal\u0026#39;s triangle for (int s = 1; s \u0026lt;= m; ++s) // nCr (comb) for (int r = 0; r \u0026lt;= n ; ++r){ comb[s][r] = r == 0 ? 1 : (comb[s - 1][r - 1] + comb[s - 1][r]) % mod; } Count the Number of Ideal Arrays\nPermutation Permutation of index Recusive with bitmask, finding the next ununsed index Minimum XOR SUM Of Two Arrays std::next_permutation\nLIS dp1:\n状态：以 a[i] 结尾的 LIS\n转移： dp[i] = arr[i] \u0026gt; arr[j] ? arr[j + 1]\n复杂度：O(N^2)\ndp2:\n状态：a[i] 之前的，长度为 i + 1，末尾元素最小的 的 LIS\n转移：\n每次将 a[i] 插入序列即可 复杂度：O(NlogN) int main() { int n; vector\u0026lt;int\u0026gt; dp(n, INT_MAX); int pos=0; // 记录dp当前最后一位的下标 dp[0]=nums[0]; for(int i=1; i\u0026lt;n; i++) { if(nums[i]\u0026gt;=dp[pos]) // 组成更长的子序列 dp[++pos]=nums[i]; else // 当前值更小，替换子序列串 dp[lower_bound(dp,dp+pos+1,nums[i])-dp]=nums[i]; } return pos; } Suffix Array Sort all suffix substrings by starting index Usage:\ncompare substrings // Structure to store information of a suffix struct suffix { int index; char *suff; }; // A comparison function used by sort() to compare two suffixes int cmp(struct suffix a, struct suffix b) { return strcmp(a.suff, b.suff) \u0026lt; 0? 1 : 0; } // This is the main function that takes a string \u0026#39;txt\u0026#39; of size n as an // argument, builds and return the suffix array for the given string int *buildSuffixArray(char *txt, int n) { // A structure to store suffixes and their indexes struct suffix suffixes[n]; // Store suffixes and their indexes in an array of structures. // The structure is needed to sort the suffixes alphabetically // and maintain their old indexes while sorting for (int i = 0; i \u0026lt; n; i++) { suffixes[i].index = i; suffixes[i].suff = (txt+i); } // Sort the suffixes using the comparison function // defined above. sort(suffixes, suffixes+n, cmp); // Store indexes of all sorted suffixes in the suffix array int *suffixArr = new int[n]; for (int i = 0; i \u0026lt; n; i++) suffixArr[i] = suffixes[i].index; // Return the suffix array return suffixArr; } Z-function Re Rooting It says so on the post:\nArbitrary root the tree, lets take node 0 for explanation. Solve the given problem as if it was rooted at node 0. Similarily solve the problem for all nodes But I think it\u0026rsquo;s still very vague.\nDFS for once, use information from previous visit, to simulate differnt roots * * Max Root Path Sum - Root * ans[i] = max(subtree sum, parent and its other subtree sum) - v[i] * Difference Between Maximum and Minimum Price Sum\nPossible roots, given at least k of the parent-children query is correct( what the heck is this problem? ) Follow the steps, (1). assume 0 as the root, (2). calculate correct guess (3). DFS. While visiting a new child, correct guess changes atmost 1, updating corrent gusses and update final answer Count Number of Possible Root Nodes Eulerian Path A graph has an Eulerian Path if and only if we have out[i] == in[i] for each node i. Or we have out[i] == in[i] for all nodes i except exactly two nodes x and y, with out[x] = in[x] + 1, out[y] = in[y] - 1, where x being the head, y being the tail Hamilton Path De Brujin ","permalink":"https://mickjagger19.github.io/posts/leetcode/algorithms/","summary":"Sweep Line Meet In the Middle Find minimum diffs Calculate the sum, get the target, iterator num_cnt on one part of the half Partition Array Into Two Arrays to Minimize Sum Difference Kadane\u0026rsquo;s Algorithm Maximum Subarray, find the subarray with the largest sum, and return its sum Just like sliding window, but in this case, the sum of the subarray is calculated. So when current subarray\u0026rsquo;s sum is negative, instead of moving the start pointer forward until invalid, the remaining window is always empty, so we should set the start pointer to current end pointer Applies to all kinds of subarray, counting the max subarray value(could be occurence) Maximum subarray problem","title":""},{"content":"Consider Aspects Every thing appears on the problems, Number of steps/Complete Gardens/cost, even the possibilities of given edges\nAnd choose the one with minimum possibilites:\nif the range of number is limited, but there might be many of them, why not use map/set/bitset to track the occurence of them ? Always consider if iterate over the aspects if possible Monotonic Queue A queue which:\nthe attribute A of items is monotonic, and unique the attribute B of items is also monotonic It neglects all items smaller than before, since they are useless.\nAttribute:\nthe item at the beginning is the max one in a range, if the begining one gets poped when the window left the adjacent items are the next smaller/bigger one to each other while pushing new item, the new value is the next bigger one to the value being pushed Can be used to solve questions like\nsliding window with max/min values: the index of the max value is always kept at the beginning. If there is some bigger items with bigger index, the smaller in-between items are useless, because they will not be max values before the bigger items are removed, when they will be removed before. next index with bigger value: after removing smaller value in the end, the new value is the next-bigger value of the last value in queue LIS: the queue maintains the items of increasing items, in order Parametric Search class Solution: def splitArray(self, nums: List[int], m: int) -\u0026gt; int: lo, hi = max(nums), sum(nums) while lo \u0026lt; hi: mid = (lo+hi)//2 tot, cnt = 0, 1 for num in nums: if tot+num\u0026lt;=mid: tot += num else: tot = num cnt += 1 if cnt\u0026gt;m: lo = mid+1 else: hi = mid A star(Heuristic) pursuit: finds the shortest path from a specified source to a specified goal\nRoughly speaking, A* is a BFS with customized priority for selecting a node to expand; the priority is to select the lowest f()=heuristic()+cost() A heuristic function is admissible if: it\u0026rsquo;s always a lower bound of the actual cost from current state to target state (in this example, manhatten distance is admissible) An important theorem: If heuristic function is admissible, then A* is guaranteed to find the optimal path $$ f(n) = g(n) + h(n) $$, where:\nf(n): priority of n g(n): distance from start to n h(n): distance from n to target function reconstruct_path(cameFrom, current) total_path := {current} while current in cameFrom.Keys: current := cameFrom[current] total_path.prepend(current) return total_path function A_Star(start, goal, h) openSet := {start} // For node n, cameFrom[n] is the node immediately preceding it on the cheapest path from start // to n currently known. cameFrom := an empty map // For node n, gScore[n] is the cost of the cheapest path from start to n currently known. gScore := map with default value of Infinity gScore[start] := 0 fScore := map with default value of Infinity fScore[start] := h(start) while openSet is not empty // This operation can occur in O(Log(N)) time if openSet is a min-heap or a priority queue current := the node in openSet having the lowest f(n) value if current = target return reconstruct_path(cameFrom, current) openSet.Remove(current) for each neighbor of current // d(current,neighbor) is the weight of the edge from current to neighbor // tentative_gScore is the distance from start to the neighbor through current tentative_gScore := gScore[current] + d(current, neighbor) if tentative_gScore \u0026lt; gScore[neighbor] // This path to neighbor is better than any previous one. Record it! cameFrom[neighbor] := current gScore[neighbor] := tentative_gScore fScore[neighbor] := tentative_gScore + h(neighbor) if neighbor not in openSet openSet.add(neighbor) // Open set is empty but goal was never reached return failure Floyd-Warshall Algorithm for (auto\u0026amp; e : edges) dist[e[0]][e[1]] = dist[e[1]][e[0]] = 1; for (int k = 0; k \u0026lt; n; k++) for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); Traveling Salesman directed graph shortest path of Hamilton path\nSequence LCS def find_lcsubstr(s1, s2): m = [[0 for i in range(len(s2) + 1)] for j in range(len(s1) + 1)] # 生成0矩阵，为方便后续计算，比字符串长度多了一列 mmax = 0 # 最长匹配的长度 p = 0 # 最长匹配对应在s1中的最后一位 for i in range(len(s1)): for j in range(len(s2)): if s1[i] == s2[j]: # 如果相等，则加入现有的公共子串 m[i + 1][j + 1] = m[i][j] + 1 if m[i + 1][j + 1] \u0026gt; mmax: mmax = m[i + 1][j + 1] p = i + 1 return s1[p - mmax:p], mmax # 返回最长子串及其长度 LCP LIS 可用于所有 Ord, if $Ord[i, j] \u0026amp; Ord[j, k]$, then $$Ord[i, k] $$\ndp1:\n状态：以 a[i] 结尾的 LIS\n转移： dp[i] = arr[i] \u0026gt; arr[j] ? arr[j + 1]\n复杂度：O(N^2)\ndp2:\n状态：a[i] 之前的，长度为 i + 1，末尾元素最小的 的 LIS\n转移：\n每次将 a[i] 插入序列即可 复杂度：O(NlogN) int main() { int n; vector\u0026lt;int\u0026gt; dp(n, INT_MAX); int pos=0; // 记录dp当前最后一位的下标 dp[0]=nums[0]; for(int i=1; i\u0026lt;n; i++) { if(nums[i]\u0026gt;=dp[pos]) // 组成更长的子序列 dp[++pos]=nums[i]; else // 当前值更小，替换子序列串 dp[lower_bound(dp,dp+pos+1,nums[i])-dp]=nums[i]; } return pos; }``` ### KMP ### Divisors ```c++ int gcd(int a, int b) { if (a \u0026lt; b) { return gcd(b, a); } if (a % b == 0) { return b; } return gcd(b, a % b); } ","permalink":"https://mickjagger19.github.io/posts/leetcode/basic-algorithms-you-must-memorize/","summary":"Consider Aspects Every thing appears on the problems, Number of steps/Complete Gardens/cost, even the possibilities of given edges\nAnd choose the one with minimum possibilites:\nif the range of number is limited, but there might be many of them, why not use map/set/bitset to track the occurence of them ? Always consider if iterate over the aspects if possible Monotonic Queue A queue which:\nthe attribute A of items is monotonic, and unique the attribute B of items is also monotonic It neglects all items smaller than before, since they are useless.","title":""},{"content":"Bit Mask CLRS book\n","permalink":"https://mickjagger19.github.io/posts/leetcode/bit/","summary":"Bit Mask CLRS book","title":""},{"content":"相对顺序 + 值顺序： Monotonic Queue\nFenwick tree struct BIT { vector\u0026lt;int\u0026gt; arr; int N; BIT(int n) { N = n + 1; arr = vector\u0026lt;int\u0026gt;(N, 0); } void add(int i) { i += 1; while (i \u0026lt; N) { arr[i] += 1; i += i \u0026amp; (-i); } } int query(int i) { int sum = 0; while (i \u0026gt; 0) { sum += arr[i]; i = i \u0026amp; (i - 1); } return sum; } }; Segment Tree class SegmentTree { public: int n; vector\u0026lt;int\u0026gt; tree; MaxSegmentTree(int n_) : n(n_) { int size = (int)(ceil(log2(n))); size = (2 * pow(2, size)) - 1; tree = vector\u0026lt;int\u0026gt;(size); } int max_value() { return tree[0]; } int query(int l, int r) { return query_util(0, l, r, 0, n - 1); } int query_util(int i, int qL, int qR, int l, int r) { if (l \u0026gt;= qL \u0026amp;\u0026amp; r \u0026lt;= qR) return tree[i]; if (l \u0026gt; qR || r \u0026lt; qL) return INT_MIN; int m = (l + r) / 2; return max(query_util(2 * i + 1, qL, qR, l, m), query_util(2 * i + 2, qL, qR, m + 1, r)); } void update(int i, int val) { update_util(0, 0, n - 1, i, val); } void update_util(int i, int l, int r, int pos, int val) { if (pos \u0026lt; l || pos \u0026gt; r) return; if (l == r) { tree[i] = max(val, tree[i]); return; } int m = (l + r) / 2; update_util(2 * i + 1, l, m, pos, val); update_util(2 * i + 2, m + 1, r, pos, val); tree[i] = max(tree[2 * i + 1], tree[2 * i + 2]); } }; Trie class TrieNode { public: TrieNode* child[26]; int count; TrieNode* insert(int c){ if (child[c] == nullptr){ child[c] = new TrieNode(); } return child[c]; } }; void build(const string \u0026amp;word) { auto ptr = root; for (char ch: word) { int idx = ch - \u0026#39;a\u0026#39;; ptr = ptr-\u0026gt;insert(idx); ptr-\u0026gt;count++; } } Disjoint Set(aka Union-Find) class UnionFind { private: vector\u0026lt;int\u0026gt; parent, rank; public: UnionFind(int size) { parent.resize(size); rank.resize(size, 0); // initially, parent i points to i itself for (int i = 0; i \u0026lt; size; i++) { parent[i] = i; } } int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } void union_set(int x, int y) { int xset = find(x), yset = find(y); if (xset == yset) { return; } else if (rank[xset] \u0026lt; rank[yset]) { parent[xset] = yset; } else if (rank[xset] \u0026gt; rank[yset]) { parent[yset] = xset; } else { parent[yset] = xset; rank[xset]++; } } }; DS can be used to build connectivity of partial nodes. Just think of it as a way to query indepedent group nodes and size(via voting)\nMAXBIT? https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/solutions/1390159/c-python-same-with-longest-increasing-subsequence-problem-clean-concise/?orderBy=most_votes\nBit Trie effectively judge the:\norder difference of different digits, with the new value and previously inserted values. Which shows the usage of Trie: Situation of first different item on the prefix sequence struct Trie { Trie* t[2] = {}; int cnt = 0; void insert(int n, int i = 1 \u0026lt;\u0026lt; 14) { ++cnt; bool b = n \u0026amp; i; if (t[b] == nullptr) t[b] = new Trie(); if (i \u0026gt; 0) t[b]-\u0026gt;insert(n, i / 2); } // e.g. for an application int countLess(int n, int lim, int i = 1 \u0026lt;\u0026lt; 14) { bool n_b = n \u0026amp; i, lim_b = lim \u0026amp; i, x = (n xor lim) \u0026amp; i; return (lim_b \u0026amp;\u0026amp; t[n_b] != nullptr ? t[n_b]-\u0026gt;cnt : 0) + (t[x] != nullptr ? t[x]-\u0026gt;countLess(n, lim, i / 2) : 0); } }; int countPairs(vector\u0026lt;int\u0026gt;\u0026amp; A, int low, int high) { return test(A, high + 1) - test(A, low); } int test(vector\u0026lt;int\u0026gt;\u0026amp; A, int x) { unordered_map\u0026lt;int, int\u0026gt; count, count2; for (int a : A) count[a]--; int res = 0; while (x) { for (auto const\u0026amp; [k, v] : count) { count2[k \u0026gt;\u0026gt; 1] += v; if (x \u0026amp; 1) if (count.find((x - 1) ^ k) != count.end()) res += v * count[(x - 1) ^ k]; } swap(count, count2); count2.clear(); x \u0026gt;\u0026gt;= 1; } return res / 2; } Monotonic Queue Attribute: there\u0026rsquo;re no smaller elements after item in an increasing stack A queue which:\nthe attribute A of items is monotonic, and unique the attribute B of items is also monotonic It neglects all items smaller than before, since they are useless.\nAttribute:\nthe item at the beginning is the max one in a range, if the begining one gets poped when the window left the adjacent items are the next smaller/bigger one to each other while pushing new item, the new value is the next bigger one to the value being pushed the insert item will repeated incounter only and all the previous bigger element Can be used to solve questions like\nsliding window with max/min values: the index of the max value is always kept at the beginning. If there is some bigger items with bigger index, the smaller in-between items are useless, because they will not be max values before the bigger items are removed, when they will be removed before. next index with bigger value: after removing smaller value in the end, the new value is the next-bigger value of the last value in queue finding the next smaller/bigger element of each: Subarray With Elements Greater Than Varying Threshold ","permalink":"https://mickjagger19.github.io/posts/leetcode/data-structures/","summary":"相对顺序 + 值顺序： Monotonic Queue\nFenwick tree struct BIT { vector\u0026lt;int\u0026gt; arr; int N; BIT(int n) { N = n + 1; arr = vector\u0026lt;int\u0026gt;(N, 0); } void add(int i) { i += 1; while (i \u0026lt; N) { arr[i] += 1; i += i \u0026amp; (-i); } } int query(int i) { int sum = 0; while (i \u0026gt; 0) { sum += arr[i]; i = i \u0026amp; (i - 1); } return sum; } }; Segment Tree class SegmentTree { public: int n; vector\u0026lt;int\u0026gt; tree; MaxSegmentTree(int n_) : n(n_) { int size = (int)(ceil(log2(n))); size = (2 * pow(2, size)) - 1; tree = vector\u0026lt;int\u0026gt;(size); } int max_value() { return tree[0]; } int query(int l, int r) { return query_util(0, l, r, 0, n - 1); } int query_util(int i, int qL, int qR, int l, int r) { if (l \u0026gt;= qL \u0026amp;\u0026amp; r \u0026lt;= qR) return tree[i]; if (l \u0026gt; qR || r \u0026lt; qL) return INT_MIN; int m = (l + r) / 2; return max(query_util(2 * i + 1, qL, qR, l, m), query_util(2 * i + 2, qL, qR, m + 1, r)); } void update(int i, int val) { update_util(0, 0, n - 1, i, val); } void update_util(int i, int l, int r, int pos, int val) { if (pos \u0026lt; l || pos \u0026gt; r) return; if (l == r) { tree[i] = max(val, tree[i]); return; } int m = (l + r) / 2; update_util(2 * i + 1, l, m, pos, val); update_util(2 * i + 2, m + 1, r, pos, val); tree[i] = max(tree[2 * i + 1], tree[2 * i + 2]); } }; Trie class TrieNode { public: TrieNode* child[26]; int count; TrieNode* insert(int c){ if (child[c] == nullptr){ child[c] = new TrieNode(); } return child[c]; } }; void build(const string \u0026amp;word) { auto ptr = root; for (char ch: word) { int idx = ch - \u0026#39;a\u0026#39;; ptr = ptr-\u0026gt;insert(idx); ptr-\u0026gt;count++; } } Disjoint Set(aka Union-Find) class UnionFind { private: vector\u0026lt;int\u0026gt; parent, rank; public: UnionFind(int size) { parent.","title":""},{"content":"Divide problems into sub problems:\nTop down(memoization) recursive function call, store results\napply cache to potential duplicate calculation\nAccords to the natural logic of the original problem description\nChoosed when there is some useless states, or no actual index concepts\nBottom up(Tabulation) iterative on the indices of sub problems\nbase on the pre-calculated results\nchoose and simplify the states, which will affect the results\nstate: Two finger\u0026rsquo;s position, or even the previous character(https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/) only the previous uncovered tiles, even not of carpetLen, since all of the former states can contribute to the previous one Minimum White Tiles After Covering With Carpets Rough process:\nIterate over the indices of the state, may be 2D even 3D Take all possible (optimal) actions on the current state build the relation from results of current state and the state after the action is taken. the relation may be derived from the natural thinking, and do a little math can contribute to ? In the Edit Distance case, the current state\u0026rsquo;s best result comes from 3 actions, and think about from prev state, apply 3 actions will lead to which future state\u0026rsquo;s best results. After the thinking is done, think backwards, build the reverse relation, by taking the future state as current state, and look for the 3 pre-action, and which one from the pre-state is the best results. forwarding recursive iterative loop, moving forward at each index based on prev results\nd[i] = d[j] + k： 使用 top_down 或 单次迭代可完成 top_down 可以忽略一些不必要的值 d[i] = d[j] + d[i - j] : 双循环 One pass dp The final result is calculated in one-pass, storing the possible extreme sub-result, assuming taking special conditions all-the-way [Minimum Time to Remove All Cars Containing Illegal Goods] [n-th song][different songs cnt] = number of playlists storing the cnt of different songs is enough, for us to calculate the plans for next song, as the next-song choice is only constrained by that. Number of Music Playlists * Optimize, by compressing the common state(length, value, etc) and **try on that possible state** Selling Pieces of Wood $dp[n] = min(max(A[i], B[i])$, A[i] increase, B[i] decrease Binary Search to find the i to make each part equal Super Egg Drop Also, tabulation seems intuitive here Classic\nMinimum Intervals covering the range [position] = minimum num of intervals to cover 0~ position Minimum Number of Taps to Open to Water a Garden Valid permutations with relative order between consecutives (1). Top-down: choosing every ID as the biggest, the remaining numbers can be chosed randomly, C(n, k) (2). Bottom-up: Next State should care about the unused digits, and the number of ways to choose next digits. Since the relative order of the previous digit in the unused digit is the only state we care about, the next digit can choose from every previous dp, from the previous relative index. dp[i][k] = dp[i - 1][k + 1: n - 1] It is tricky, but the remaining permutation can be viewed as permutation of random different digits, actually we don\u0026rsquo;t care about the exact values. For each possibility where the index of last digit is the same, the next-permutation is also the same Valid Permutations for DI Sequence Memoization Classic\nIf possible to fit numbers into boxes Try combinations of items on each boxes, box-size to numbers mask distribute repeated numbers Classic\nBitMasking to perform DFS\n[courses taken][courses last semester] = minimum days the courses of last semester should be stored, since it affects the courses available next semester.\nfor(int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i += 1){ int ex = 0; // get the possible next semesters courses for(int j = 0; j \u0026lt; n; j += 1) if((i \u0026amp; pre[j]) == pre[j]) ex |= 1 \u0026lt;\u0026lt; j; // get the unlearnt next semester courses ex \u0026amp;= ~i; // next semester, learn courses from ex for(int s = ex; s; s = (s - 1) \u0026amp; ex) if(__builtin_popcount(s) \u0026lt;= k){ dp[i | s] = min(dp[i | s], dp[i] + 1); } } Parallel Coursues2\nRecursively choose each item, top-down iterate over each choice, recursive call Stickers to Spell Word Ways to choose numbers(duplication), no order With vector\u0026lt;int\u0026gt; as used numbers key, and trying every type of num in each call Maximum Number of Groups Getting Fresh Donuts Divide problems into sub problems:\nTop down(memoization) recursive function call, store results\napply cache to potential duplicate calculation\nAccords to the natural logic of the original problem description\nChoosed when there is some useless states, or no actual index concepts\nBottom up(Tabulation) iterative on the indices of sub problems\nbase on the pre-calculated results\nchoose and simplify the states, which will affect the results\nstate: Two finger\u0026rsquo;s position, or even the previous character(https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/) only the previous uncovered tiles, even not of carpetLen, since all of the former states can contribute to the previous one Minimum White Tiles After Covering With Carpets Rough process:\nIterate over the indices of the state, may be 2D even 3D Take all possible (optimal) actions on the current state build the relation from results of current state and the state after the action is taken. the relation may be derived from the natural thinking, and do a little math can contribute to ? In the Edit Distance case, the current state\u0026rsquo;s best result comes from 3 actions, and think about from prev state, apply 3 actions will lead to which future state\u0026rsquo;s best results. After the thinking is done, think backwards, build the reverse relation, by taking the future state as current state, and look for the 3 pre-action, and which one from the pre-state is the best results. forwarding recursive iterative loop, moving forward at each index based on prev results\nd[i] = d[j] + k： 使用 top_down 或 单次迭代可完成 top_down 可以忽略一些不必要的值 d[i] = d[j] + d[i - j] : 双循环 One pass dp The final result is calculated in one-pass, storing the possible extreme sub-result, assuming taking special conditions all-the-way [Minimum Time to Remove All Cars Containing Illegal Goods] [n-th song][different songs cnt] = number of playlists storing the cnt of different songs is enough, for us to calculate the plans for next song, as the next-song choice is only constrained by that. Number of Music Playlists Optimize, by compressing the common state(length, value, etc) and try on that possible state Selling Pieces of Wood $dp[n] = min(max(A[i], B[i])$, A[i] increase, B[i] decrease Binary Search to find the i to make each part equal Super Egg Drop Also, tabulation seems intuitive here Classic\nMinimum Intervals covering the range [position] = minimum num of intervals to cover 0~ position Minimum Number of Taps to Open to Water a Garden Memoization Classic\nIf possible to fit numbers into boxes Try combinations of items on each boxes, box-size to numbers mask distribute repeated numbers Classic\nBitMasking to perform DFS\n[courses taken][courses last semester] = minimum days the courses of last semester should be stored, since it affects the courses available next semester.\nfor(int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i += 1){ int ex = 0; // get the possible next semesters courses for(int j = 0; j \u0026lt; n; j += 1) if((i \u0026amp; pre[j]) == pre[j]) ex |= 1 \u0026lt;\u0026lt; j; // get the unlearnt next semester courses ex \u0026amp;= ~i; // next semester, learn courses from ex for(int s = ex; s; s = (s - 1) \u0026amp; ex) if(__builtin_popcount(s) \u0026lt;= k){ dp[i | s] = min(dp[i | s], dp[i] + 1); } } Parallel Coursues2\nRecursively choose each item, top-down iterate over each choice, recursive call Stickers to Spell Word Ways to choose numbers(duplication), no order With vector\u0026lt;int\u0026gt; as used numbers key, and trying every type of num in each call Maximum Number of Groups Getting Fresh Donuts ","permalink":"https://mickjagger19.github.io/posts/leetcode/dp/","summary":"Divide problems into sub problems:\nTop down(memoization) recursive function call, store results\napply cache to potential duplicate calculation\nAccords to the natural logic of the original problem description\nChoosed when there is some useless states, or no actual index concepts\nBottom up(Tabulation) iterative on the indices of sub problems\nbase on the pre-calculated results\nchoose and simplify the states, which will affect the results\nstate: Two finger\u0026rsquo;s position, or even the previous character(https://leetcode.","title":""},{"content":" Find cycles(Aka Tarjan\u0026rsquo;s Bridge-Finding Algorithm) DFS, with dfn(time order) \u0026amp; low(lowest reachable time ordered from current root). $dfn(n) \u0026lt; low(v)$-\u0026gt; uv is a bridge. If a node with rank in-between, a cycle starts from that. Pick unvisited nodes to next round Partition Array Into Two Arrays to Minimize Sum Difference Max 4 neighbors sum To construct a valid sequence, start by selecting the middle part and extend it, with each node\u0026rsquo;s top 3 neighbors(a\u0026rsquo;s neighbor + a + b + the max remaining neighbour) Maximum Score of a Node Sequence ","permalink":"https://mickjagger19.github.io/posts/leetcode/graph/","summary":" Find cycles(Aka Tarjan\u0026rsquo;s Bridge-Finding Algorithm) DFS, with dfn(time order) \u0026amp; low(lowest reachable time ordered from current root). $dfn(n) \u0026lt; low(v)$-\u0026gt; uv is a bridge. If a node with rank in-between, a cycle starts from that. Pick unvisited nodes to next round Partition Array Into Two Arrays to Minimize Sum Difference Max 4 neighbors sum To construct a valid sequence, start by selecting the middle part and extend it, with each node\u0026rsquo;s top 3 neighbors(a\u0026rsquo;s neighbor + a + b + the max remaining neighbour) Maximum Score of a Node Sequence ","title":""},{"content":" Problem DS/Algorithm shortest path bfs connectivity disjoint set ","permalink":"https://mickjagger19.github.io/posts/leetcode/intuitions/","summary":" Problem DS/Algorithm shortest path bfs connectivity disjoint set ","title":""},{"content":" finding factors Multinomial Coefficient permutation of N1, N2\u0026hellip; Nn numbers, with Sum(Ni) = M: $M! / N1! * N2! * \u0026hellip; * Nn!$\nModular Multiplicative Inverse $(A / B) % mod = A * ( B ^ -1 ) % mod = A * (b ^ (mod -2))$\n// the order of a sequence in all its permutation for (int i = sz - 1; i \u0026gt;= 0; --i) { // only count sequence lower than i ~ sz here // xxxxcxxxxx cnt[s[i] - \u0026#39;a\u0026#39;] += 1; // fix the first number as lower // calculate the permutation of the remaining part auto prems = accumulate(begin(cnt), begin(cnt) + s[i] - \u0026#39;a\u0026#39;, 0l) * ft[sz - i - 1] % mod; for (int n : cnt) prems = prems * im[n] % mod; res = (res + prems) % mod; } Permutations Choose different balls with total cnt fixed // split through each kind of balls for (int j = 0; j \u0026lt;= A[i]; ++j) { // try different splits at the `i`-th element, i.e. a[i] + b[i] = A[i] a[i] = j; b[i] = A[i] - j; ans += dfs(A, a, b, i + 1, sa + a[i], sb + b[i]); } Choose Combination, then calculate Permutation ","permalink":"https://mickjagger19.github.io/posts/leetcode/mathematical/","summary":"finding factors Multinomial Coefficient permutation of N1, N2\u0026hellip; Nn numbers, with Sum(Ni) = M: $M! / N1! * N2! * \u0026hellip; * Nn!$\nModular Multiplicative Inverse $(A / B) % mod = A * ( B ^ -1 ) % mod = A * (b ^ (mod -2))$\n// the order of a sequence in all its permutation for (int i = sz - 1; i \u0026gt;= 0; --i) { // only count sequence lower than i ~ sz here // xxxxcxxxxx cnt[s[i] - \u0026#39;a\u0026#39;] += 1; // fix the first number as lower // calculate the permutation of the remaining part auto prems = accumulate(begin(cnt), begin(cnt) + s[i] - \u0026#39;a\u0026#39;, 0l) * ft[sz - i - 1] % mod; for (int n : cnt) prems = prems * im[n] % mod; res = (res + prems) % mod; } Permutations Choose different balls with total cnt fixed // split through each kind of balls for (int j = 0; j \u0026lt;= A[i]; ++j) { // try different splits at the `i`-th element, i.","title":""},{"content":" Goal: Key point: Classic\nFind patterns of the solutions of the problem There are two patterns which meets the requirements: (1). two circled person, and two arms. (2). an entire circle Maximum Employees to Be Invited to a Meeting Find the required pattern for the result Transform to Chessborad N = x + (x + 1)\u0026hellip;(x + n) = n * x + (n - 1) * n / 2 Counting odd factors Consecutive Numbers Sum Special Operation: Each time pushing a new element, try merging with the last one in the stack. Two way merge Replace Non-Coprime Numbers in Array Find number of intervals covering a value Meeting Roomes Template: Given some intervals and an array of value, returns the number of intervals covering that value Record the starting and endings of intervals with an array(arr[s]++, arr[e]\u0026ndash;). Iterate over value, adding the value of arr, sum of that will be number of intervals convering that value. [Number of Flowers in Full Bloom] Hard\nFinding the K-th biggest sum from an array Starts with maximum value, get the next-smaller values by (1). removing/adding the smallest positive/biggest negative value (2). removing previous selecition, move to next s/b value Find the K-Sum of an Array Hard\nFind number of subsequences with max and min fixed Three-pointer sliding window, number in window is within range, considering the valid range ending with i while iterating, which is $min(prevMin, prevMax) - prevBad$ Count Subarrays with fixed Bounds Gudge if there\u0026rsquo;s element appears odd times xor Seems like other kinds of appearing pattern can\u0026rsquo;t be decided in O(N) easily Find Longest Awesome Substring Hard, Classics\nWays to fill rectange with square Again, finding patterns help. The special case can be formed by 4 normal rectangular, and 1 rectangular in the middle Tiling a Rectangle with the Fewest Squares Find Number of different GCDs A number N can be a GCD, if and only if the gcd of all numbers divisible by N, is N itself. If g(N) = N already, it will holds later Number of Different Subsequences GCDs Reverse pairs A number N can be a GCD, if and only if the gcd of all numbers divisible by N, is N itself. If g(N) = N already, it will holds later Number of Pairs Satisfying Inequality If exists path with max edge length If exists, the paths consists of shorter edge \u0026lt;-\u0026gt; exist shorter edge make the path \u0026lt;-\u0026gt; exist shorter edge connects the point \u0026lt;-\u0026gt; All shorter edge connects the point https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/submissions/917168157/ If exists path with max edge length If exists, the paths consists of shorter edge \u0026lt;-\u0026gt; exist shorter edge make the path \u0026lt;-\u0026gt; exist shorter edge connects the point \u0026lt;-\u0026gt; All shorter edge connects the point https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/submissions/917168157/ Classic\nTwo-approach Maintain two data structure, to make the update/query more efficient Design a Text Editor Calculate 2d prefix, to judge if a rectangular contains something The last 2d prefix sum is tricky, since to make a cell stamped, that cell is not the only place to place the top-left of the stamp.The top-left can be placed anywhere within (x - w, y - h) ~ (x,y) Stamping The Grid Minimum number to pick up, with sum \u0026gt;= k Greedy, calculate max sum with i numbers picking up, always picking up the maximum number within reach Minimum Number of Refueling Stops Finding min(A[i], A[j]) * ( j - i ) - sum(A[i:j]) sum(h[front] - h[middle]), when h[i] \u0026gt; h[front], a new boundary starts, since the prev boundaray(h[front]) is lower Trapping Rain Water Strategy Goal: Strategy: Hard\nFind the least starting value The time we have the least money is, aftering finishing the last lossing-money cost, but not gaining the cashback yet (1). make sure we get through before, needs prev_loss + this_cost (2). make sure get the money to start next transaction Minimum Money Required Before Transactions find path 1XXXXXXX -\u0026gt; \u0026hellip; -\u0026gt; 11000000 -\u0026gt; 1000000 -\u0026gt; \u0026hellip; -\u0026gt; 0 Minimum One Bit Operations to Make Integers Zero maximum value of intervals (1). Priority Queue on value, line sweep, put start and end separatedly (2). Segment Tree Skyline Maximum times of multiple subtraction Very intuitive: a battery can no be taken more than answer hours Maximum Running Time of N Computers normalize, means indexing different numbers with unique id a Minimum number to pick up, with sum \u0026gt;= k Greedy, calculate max sum with i numbers picking up, always picking up the maximum number within reach Minimum Number of Refueling Stops Minimum prefix[A[i]] + B[i] Fixing the first i index, the answer is k(prefix[i] is also fixed) + B[i], so the minimum B should be selected last I nearly think of this solution, but skip that thought after taking the un-certainty of the prefix into consider. However, if we only focused at last position, the prefix is always fix Maybe only focus on one part, the remaining parts will be handled Earliest Possible Day of Full Bloom ","permalink":"https://mickjagger19.github.io/posts/leetcode/miscellaneous/","summary":"Goal: Key point: Classic\nFind patterns of the solutions of the problem There are two patterns which meets the requirements: (1). two circled person, and two arms. (2). an entire circle Maximum Employees to Be Invited to a Meeting Find the required pattern for the result Transform to Chessborad N = x + (x + 1)\u0026hellip;(x + n) = n * x + (n - 1) * n / 2 Counting odd factors Consecutive Numbers Sum Special Operation: Each time pushing a new element, try merging with the last one in the stack.","title":""},{"content":"DFS \u0026amp; BFS dfs: 验证连通性 bfs: 可以携带一些当前节点的状态，常用于求加权最短路径 Difference dfs 和 bfs 在时间复杂度上，由于 dfs 会保存一份context变量，而 bfs 会为每个状态保存一份变量，因此时间复杂度上不一致 To reduce search space: memorization could be: of visited paths(i to j) and associated values of new states and associated(minimum or maximum) values On bfs, the prioritized value is always increasing, so it should be exactly what the problem what, and returns as soon as it meets the requirement. On dfs, return earlier when the current cnt has passed previous extreme value when don\u0026rsquo;t know exact solutions, try greedy \u0026amp; (BFS|DFS) dfs + memorization roughly equals to bfs? dfs needs to enumerate all possibilities, and use cache to shorten search space bfs gives best solutions naturally 0-1 BFS 0-1 BFS Djikstra without priority queue: Minimum Obstacle Removal to Reach Corner\nPush unvisited neighbour with cost, to end of the queue Push unvisited neighbour with cost, to beginning of the queue So that the neighbor with lower cost will be visited first, and the cost of first visited is the minimum cost Optimization In BFS Store the visited path Store [visited notes][ending node] ","permalink":"https://mickjagger19.github.io/posts/leetcode/search/","summary":"DFS \u0026amp; BFS dfs: 验证连通性 bfs: 可以携带一些当前节点的状态，常用于求加权最短路径 Difference dfs 和 bfs 在时间复杂度上，由于 dfs 会保存一份context变量，而 bfs 会为每个状态保存一份变量，因此时间复杂度上不一致 To reduce search space: memorization could be: of visited paths(i to j) and associated values of new states and associated(minimum or maximum) values On bfs, the prioritized value is always increasing, so it should be exactly what the problem what, and returns as soon as it meets the requirement. On dfs, return earlier when the current cnt has passed previous extreme value when don\u0026rsquo;t know exact solutions, try greedy \u0026amp; (BFS|DFS) dfs + memorization roughly equals to bfs?","title":""},{"content":"Find different patterns\nChange the direction may help start considering the extreme candidate find the number of complete set to gain shortest impossible permutation ","permalink":"https://mickjagger19.github.io/posts/leetcode/sequence/","summary":"Find different patterns\nChange the direction may help start considering the extreme candidate find the number of complete set to gain shortest impossible permutation ","title":""},{"content":"SE, java(AM): 200460909 SE, java(AM): 200460940 SWE, C++ :200458465 SE, VR/AR: 200410760 AMP: 200462337 SE, distribute: 200323245\n","permalink":"https://mickjagger19.github.io/posts/profile/role-numbers/","summary":"SE, java(AM): 200460909 SE, java(AM): 200460940 SWE, C++ :200458465 SE, VR/AR: 200410760 AMP: 200462337 SE, distribute: 200323245","title":""},{"content":"Languages: Rust, C++, Java, Scala and others Work exprience involves compilers, frontend, ide \u0026amp; virtual machine\n","permalink":"https://mickjagger19.github.io/posts/profile/skills/","summary":"Languages: Rust, C++, Java, Scala and others Work exprience involves compilers, frontend, ide \u0026amp; virtual machine","title":""},{"content":"Qian Chengliang(English name as Mick) is a person, pursuiting jobs of creativity and crave for learning and exploring new technologies and skills.\nGraduated as a bachelor in Computer Sciende at ZJU(Zhejiang University), his acedemic record is among the top 20% in CS College, 10% in the last two years, which proves his ability to learn. At school, he interns at a big tech company in china for 2 months, and act as a major contributor of a transpiler project, which translates java code to scala, and beats the performance of the most competitors at that time.\nAnd because of that expierence, he found that a lot can be learnt from work, so he joined that company after graduating. In the two years of working there, he was a major contributor to some important projects, say, for example, an IDE written in Rust developed from scratch. He built the text-editor on his own, which is the essential part of the IDE, and its performance outbeats some of the most popular editors. Learning from the best-practice of the design of them, he put a lot of work to make the editor light and responsive, by exploiting the most suitable data structure and the advantage of Rust as a programming language.\nDetail-oriented, organized and meticulous employee. Remains consistently abreast of cutting-edge development and technology advancements. Always works the most effective in the team, to meet tight deadlines. Stepping out when there\u0026rsquo;s high-maintenance bugs. Values functionality, stability as well as performance of the software. Giving out creative \u0026amp; practical ideas on user-experience or technology problems.\n","permalink":"https://mickjagger19.github.io/posts/profile/third-person-self-introduction/","summary":"Qian Chengliang(English name as Mick) is a person, pursuiting jobs of creativity and crave for learning and exploring new technologies and skills.\nGraduated as a bachelor in Computer Sciende at ZJU(Zhejiang University), his acedemic record is among the top 20% in CS College, 10% in the last two years, which proves his ability to learn. At school, he interns at a big tech company in china for 2 months, and act as a major contributor of a transpiler project, which translates java code to scala, and beats the performance of the most competitors at that time.","title":""},{"content":"创建工程 你是IDE 内置引擎，你的任务是将通过自然语言描述的任务，转换成自然语言描述的子任务(可能包含的任务为: 创建文件/文件夹，设置文件内容等），并通过序号标出。例如，输入：“帮我创建一个 rust 工程, 将创建 cargo.toml, 名字为 toy，需要用到 tokio 作为依赖库”， 你需要输出“1. create project directory 2. Touch a cargo.toml with detailed content 3. open directory\u0026quot;。请注意，子任务中不能与 UI/交互等用户操作相关(包括点击，选择，等待, etc），而只能是可以由机器执行的指令。现在，帮我创建一个 空 andriod 应用工程，名字为 MyJavaApplication\nPrompt \u0026ldquo;你是帮我创建一个 rust 工程, 将创建 cargo.toml, 名字为 toy，需要用到 tokio 作为依赖库\u0026rdquo; ChatGPT split task: create directory touch cargo.toml edit cargo.toml open directory 模糊匹配到 VnextCommand ","permalink":"https://mickjagger19.github.io/posts/work/%E5%85%A8%E6%B5%81%E7%A8%8B/","summary":"创建工程 你是IDE 内置引擎，你的任务是将通过自然语言描述的任务，转换成自然语言描述的子任务(可能包含的任务为: 创建文件/文件夹，设置文件内容等），并通过序号标出。例如，输入：“帮我创建一个 rust 工程, 将创建 cargo.toml, 名字为 toy，需要用到 tokio 作为依赖库”， 你需要输出“1. create project directory 2. Touch a cargo.toml with detailed content 3. open directory\u0026quot;。请注意，子任务中不能与 UI/交互等用户操作相关(包括点击，选择，等待, etc），而只能是可以由机器执行的指令。现在，帮我创建一个 空 andriod 应用工程，名字为 MyJavaApplication\nPrompt \u0026ldquo;你是帮我创建一个 rust 工程, 将创建 cargo.toml, 名字为 toy，需要用到 tokio 作为依赖库\u0026rdquo; ChatGPT split task: create directory touch cargo.toml edit cargo.toml open directory 模糊匹配到 VnextCommand ","title":""}]