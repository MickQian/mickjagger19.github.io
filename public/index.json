[{"content":"Backend Backend 架构\nTokenizer Manager: tokenize: accepts the incoming chat completions request, forwarding to the Scheduler Scheduler: Infinite event loop to receive request from tokenizer manager ScheduleBatch ReqToTokenPool: 维护 req 中的连续 tokens 到 kv cache index 的映射 TokenToKVPool: 维护 每一个 layer 中的 token（用 kv cache index 表示） 到 kv cache(Tensor) 的映射 TpModelWorker: A tensor parallel model worker, forwards the batch to ModelRunner ModelWorkerBatch: ForwardBatch: Store all inputs of a forward pass ModelRunner: Runs the forward passes of the models. Also samples from logits holds CudaGraphRunner, which 加速 forward 过程 holds AttentionBackend(可以关闭): flashInfer | triton | torch_native AttentionBackend: Runs a forward for decode or extend [!NOTE] TD learning can learn from incomplete episodes\nPrefill Memory Pool Token to KV Pool: stores [AttentionLayerID][CacheLocation] = k or v Constrained Decoding sglang.srt.constrained\n通过排除 logits 中不合法（不符合格式）的 token，保证输出一定符合格式 常用思路： Outlines: 将 JSON Schema 中对 field 的约束用 regex 的方式描述，基于该 regex 在 token-level 构建 FSM。 FSM 在每个 state 只接受 某些特定的 token，因此可以作为偏置 Guidance: 把 JSON Scheme 拆分为两个类型的部分: chunked prefill: attribute ，固定名称，这部分不需要 LLM 生成，可以直接预填充，作为提前确定的输出 constrained decoding: 在预填充后指定生成 SGLang: Jump-Forward Decoding With a Compressed FSM XGrammar: 使用 CFG 代替 regex, 因此支持递归，更灵活 将 vocab 划分为: 上下文无关 token， 可以预先计算和缓存 上下文有关 token: 运行时动态检查 Attention 的类型: Prefill / Decode / Extend(Append) 对应了 LLM 应用的三个场景\nprefill: 生成 attention 和 hidden states 单次 forward 可以处理 所有 token 初始 context 计算强度 decode: 自回归生成所有 token 单次 forward 可以生成 单个 token 生成回复 带宽瓶颈：计算强度低，访存强度高 append(extend / verification): 追加新的token，适用于用户追加文本的场景 单次 forward 处理多个 token 用户追问 计算强度中 下图可以比较好地说明三个阶段的注意力计算方式（其中 Speculative Decoding 的 Draft Model proposal 和 Append 同属一个场景）: 其中注意力计算方式决定了计算强度\n下图是三种计算的屋顶模型：\nFlash Infer 一个加速 LLM 服务的算子库\n共享前缀批处理解码 online softmax: 更合理的 tiling 方案： GQA 分组自注意力：对于 key/values 使用比 query/output 更少的头数量 一个组内的 token 共享一个 query 向量和 attention 结果向量 牺牲组内注意力，降低计算量和访存 $A_{(N/block_size) * N * d_model} Paged Attention: KVCache 分块独立计算 attention，减少内存使用，提高并行度，降低延迟 物理和存储上优化，并没有改变计算方式本身 由于忽略了跨块 token 间的注意力，注意力丢失部分 A_{(block_size * N * d_model} Gemm Gemm 是一种常用的矩阵计算操作，在 transformer 中有广泛应用，现代 CPU/GPU 都对其进行了优化\nO(mnk)\n[!NOTE] QK^T / AV / 两个全连接层 / 输入/输出投影 都是 Gemm 计算\n优化细节 分块 tiling: 提高局部性，减少访存 Loop Reordering: 改变计算顺序 Vectorization: 使用 SIMD 指令/处理器的向量单元 Mixed-Precision Calculation 混合精度运算：使用FP16/BF16进行计算，FP32进行累加 GEMV（General Matrix-Vector Multiply） Gemm 的一个特例，部分输入和输出退化为 vector\nO(mn)\nFrontend interpreted python DSL: SGlang\nsglang: Speculative gen: Speculative Decoding StreamExecutor::_spec_gen\nbackground: 推理过程中，每个 token 的生成都需要将 weights 从存储单元传输到计算单元，因此传输过程（内存访问带宽）成为主要的瓶颈 method: 使用两个模型：原始模型和近似模型（更小，更快）。近似模型生成 n 个 token,就由原始模型验证这些 token 一次，只需要一次推理，减少了访存次数 验证：所有历史 logits(包含所有前缀) 在原始模型内进行一次 forward, 验证每个新生成 token 的正确性 利用单次 forward 能够验证多个 token（对于已经生成的 token, 可以组成一个 batch)， 而只能生成一个 token 的特性，在一个较为可靠且快速的近似模型上能够保证 验证为主，生成为辅导 如果近似模型的正确性得不到保证，可能总体生成速度更慢 Speculative Execution look at this example:\ns += context +“name：”+ gen(“name”，stop=”\\n”) +“job：”+ gen(“job”，stop=”\\n”) 正常来说一次 gen 发送一次调用 Speculative Execution 通过忽略 stop，让一次调用生成更多 token, 并用于匹配后续的 gen\n","permalink":"https://mickjagger19.github.io/posts/ai/inferenceengine/sglang/","summary":"\u003ch2 id=\"backend\"\u003eBackend\u003c/h2\u003e\n\u003cp\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \u003cfigure align=center class=\"figure d-block text-center\"\u003e\n  \u003cpicture align=center \u003e\n  \u003cimg class=\"figure-img img-fluid\" src=\"https://raw.githubusercontent.com/zhaochenyang20/Awesome-ML-SYS-Tutorial/3efcb236c8bc08f7305a6c9807acdc0194031a84/sglang/code-walk-through/sglang-architecture.svg\" alt=\"Backend 架构\" loading=\"lazy\" /\u003e\n\u003c/picture\u003e\n\n  \u003cfigcaption class=\"figure-caption\"\u003e\u003cp\u003eBackend 架构\u003c/p\u003e\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTokenizer Manager\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003etokenize: accepts the incoming chat completions request, forwarding to the Scheduler\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eScheduler\u003c/strong\u003e: Infinite event loop to receive request from tokenizer manager\n\u003cul\u003e\n\u003cli\u003eScheduleBatch\n\u003cul\u003e\n\u003cli\u003eReqToTokenPool: 维护 req 中的连续 tokens 到 kv cache index 的映射\u003c/li\u003e\n\u003cli\u003eTokenToKVPool: 维护 每一个 layer 中的 token（用 kv cache index 表示） 到 kv cache(Tensor) 的映射\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTpModelWorker\u003c/strong\u003e: A tensor parallel model worker, forwards the batch to \u003cstrong\u003eModelRunner\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eModelWorkerBatch\u003c/strong\u003e:\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eForwardBatch\u003c/strong\u003e: Store all inputs of a forward pass\u003c/li\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eModelRunner\u003c/strong\u003e: Runs the forward passes of the models. Also samples from logits\n\u003cul\u003e\n\u003cli\u003eholds \u003cstrong\u003eCudaGraphRunner\u003c/strong\u003e, which 加速 forward 过程\u003c/li\u003e\n\u003cli\u003eholds \u003cstrong\u003eAttentionBackend\u003c/strong\u003e(可以关闭): \u003ccode\u003eflashInfer | triton | torch_native\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAttentionBackend\u003c/strong\u003e: Runs a forward for decode or extend\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e[!NOTE]\nTD learning can learn from \u003cstrong\u003eincomplete\u003c/strong\u003e episodes\u003c/p\u003e","title":"SGlang"},{"content":"Immusia（读作 ɪˈmuːziə, 是拉丁语 Immersio (沉浸) 和 Musica (音乐) 的结合) 是我的第一个 Vision Pro App, 也是我的第一个 VR App\n本文记录了我的创作理念，和一些实现细节\n缘由 之所以想做这样的一个 app, 是因为我由于科幻作品的影响，产生的对 VR 设备的想象。更具体一点，是 Black Mirror。Black Mirror 擅长探讨 高科技对 人文/伦理/社会 的冲击，选材大胆，对我有着比较深的影响。在其最精彩的前几集，多次出现类似 头戴设备的概念，给了观影者极大的想象空间。\n核心功能 Immusia 的核心理念始终是 沉浸式 的音乐聆听体验。借助 “概念专辑” 这类已经被大众认可的丰富精神财产，音乐被赋予了更具像化的概念，从而使音乐可视化有了更合理的依据\n2D 资产 -\u0026gt; 3D 资产 有大量平面资源可以转为双目3D，动机很自然(Vision Pro 的相册 app 也在后来内置了这个功能）， 相关技术也随处可寻，但是视觉效果还是相当可观\n3D Player 为了充分发挥 VR 设备的空间优势，我对传统播放器做了以下改动：\n所有歌词文本都为具有深度的 3D 字体。尽管 Apple 不推荐这么做，我还是坚持使用它，原因是经过实测， depth 似乎赋予了歌词一种真实感 歌词的移动方向不再局限于 y 方向，而是可以结合 XY 和 Z。我最喜欢的移动方式，被我称为 \u0026ldquo;Water Fall\u0026rdquo;， 歌词会向 -Y 和 +Z 方向移动 Immersive Player Window Mode 由于 Swift API 的限制，app之间的 沉浸式空间是互斥的，因此纯沉浸式的 app 存在一些局限性。为了达到一个通用音乐播放器的最低要求，我加入了窗口模式，这样用户就可以在使用其他 app 时同时使用 Immusia\n窗口模式的大部分 UI 都和系统原生 Apple Music 保持一致。为了更方便查看艺术家信息和专辑信息，在左右两侧分别添加了小窗口。同时，沉浸模式下的 3D 播放器 也被保留。\n值得一提的是，为了体现空间感，我没有采用平铺的专辑列表，而是实现了一种非常类似 Apple 在 IPod 上曾经使用过的 Cover Flow 效果。它足够优雅和美观，也不会占用太多资源。\nEnvironments 环境 在 Environment 方面，我早就感到和知晓 RealityKit 的局限性和 Performance 问题，Metal(CompositorService, to be specific) 是最好的选择。然而我没有图形学方面的储备，所以花了一段时间尝试寻找合适的人选（外包团队）进行合作。显然我高估了国内在这一领域的人才储备，总之经过一段时间的尝试并无果之后，我就开始自学 Metal。在 Shadertoy和一些电子教材 的帮助之下，我得以对图形学入门，并创作了一些环境（场景）\nInterstellar Interstellar 是我搭建的第一个环境。在听太空主题的音乐时，脑海里一直有一些关于太空场景的想象，而且静态的太空场景也相对比较容易实现，对当时对图形编程不太熟悉的我来说是一个不错的上手项目\n起初我对 Interstellar 的构想比较简单：一个孤单的蓝色星球\n但是随着进度不断推进，我的想法越来越多，技术也逐渐成熟，因此我大胆地加入了不同元素：月球/太阳/星星/星云 等\n在这个过程中也遇到了很多问题，包括但不限于：\nColorSpace 的选取 透明场景下 BlendMode 和 Alpha 的设置 大量复杂 Shader 造成的计算问题，通过简化逻辑和烘焙纹理解决 CompareFunction 和 Winding 的不一致造成的遮挡错误问题 \u0026hellip; 所幸在 GPT 的帮助下，没有浪费我 太多 的时间\n这个场景中的很多元素都是我从 ShaderToy 移植而来，希望 License 不会有很大的问题\n在背景音乐的选择方面，此前选择的是现成的 太空背景音乐音效，现在正在考虑 realtime GPU Sound\n一些不错的生成结果：\nPlastic Beach Star Gate 一次和朋友闲聊，偶然听他提起正在为新歌制作一段类似 Daft Punk 的《Contact》 末尾的太空音效。我去 Youtube 上找到了一个粉丝为这首歌制作的一版 MV, 里面恰好选取了 《2001: A Space Odyssey》 中主人公 David Bowman 穿越时空隧道（Star Gate) 的片段，这一段视觉效果和音乐的节奏有着非常好的配合\n我很喜欢这个场景，于是它成为了我的第二个 Environment idea。\n一些想法 一个 VR app 涉及的技术栈太多：前端/后端/设计/GPU 渲染/UX 只是我能想起来的几个，而且互联网相对较丰富的也只是平面资源，在空间的视角下，每一部分都可以衍生出新的学问。Vision Pro 用于作为先行 Demo 的 Encounter Dinosaurs, 在 WWDC 上有一个专门的 Episode, 介绍其中的 UX 设计。这是一个全新的领域 Marketing: 我还没有进行任何形式的 Marketing 相关人才的欠缺：国内外在 VR 技术上的 技术和人才累积 似乎根本不在一个水平面上，国内的 App，即使是由大团队诸如 QQ 音乐/ 爱奇艺等，仍显粗糙；然而国外的小团队（最少1个人）都可以做出足够摘取 Apple Design Awards 的 App。这应该与当地电影工业的发展有着最直接的联系 ","permalink":"https://mickjagger19.github.io/posts/misc/the-making-of-immusia/","summary":"\u003cp\u003e\u003cstrong\u003eImmusia\u003c/strong\u003e（读作 \u003cstrong\u003eɪˈmuːziə\u003c/strong\u003e, 是拉丁语 \u003cstrong\u003eImmersio\u003c/strong\u003e (沉浸) 和 \u003cstrong\u003eMusica\u003c/strong\u003e (音乐) 的结合) 是我的第一个 Vision Pro App, 也是我的第一个 VR App\u003c/p\u003e\n\u003cp\u003e本文记录了我的创作理念，和一些实现细节\u003c/p\u003e\n\u003ch2 id=\"缘由\"\u003e缘由\u003c/h2\u003e\n\u003cp\u003e之所以想做这样的一个 app, 是因为我由于科幻作品的影响，产生的对 VR 设备的想象。更具体一点，是 Black Mirror。Black Mirror 擅长探讨 高科技对 人文/伦理/社会 的冲击，选材大胆，对我有着比较深的影响。在其最精彩的前几集，多次出现类似 头戴设备的概念，给了观影者极大的想象空间。\u003c/p\u003e\n\u003ch2 id=\"核心功能\"\u003e核心功能\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eImmusia\u003c/strong\u003e  的核心理念始终是 沉浸式 的音乐聆听体验。借助 “概念专辑” 这类已经被大众认可的丰富精神财产，音乐被赋予了更具像化的概念，从而使音乐可视化有了更合理的依据\u003c/p\u003e\n\u003ch3 id=\"2d-资产---3d-资产\"\u003e2D 资产 -\u0026gt; 3D 资产\u003c/h3\u003e\n\u003cp\u003e有大量平面资源可以转为双目3D，动机很自然(Vision Pro 的相册 app 也在后来内置了这个功能）， 相关技术也随处可寻，但是视觉效果还是相当可观\u003c/p\u003e\n\u003ch3 id=\"3d-player\"\u003e3D Player\u003c/h3\u003e\n\u003cp\u003e为了充分发挥 VR 设备的空间优势，我对传统播放器做了以下改动：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e所有歌词文本都为具有深度的 3D 字体。尽管 Apple 不推荐这么做，我还是坚持使用它，原因是经过实测， depth 似乎赋予了歌词一种真实感\u003c/li\u003e\n\u003cli\u003e歌词的移动方向不再局限于 y 方向，而是可以结合 XY 和 Z。我最喜欢的移动方式，被我称为 \u0026ldquo;Water Fall\u0026rdquo;， 歌词会向 -Y 和 +Z 方向移动\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"immersive-player\"\u003eImmersive Player\u003c/h3\u003e\n\u003ch3 id=\"window-mode\"\u003eWindow Mode\u003c/h3\u003e\n\u003cp\u003e由于 Swift API 的限制，app之间的 沉浸式空间是互斥的，因此纯沉浸式的 app 存在一些局限性。为了达到一个通用音乐播放器的最低要求，我加入了窗口模式，这样用户就可以在使用其他 app 时同时使用 Immusia\u003c/p\u003e","title":"(The Making Of) Immusia"},{"content":"Rocky Rocky 是 The Beatles 吉他手 George Harrison 的电吉他\nGeorge Harrison 本人曾在多个场合使用它：\nGeorge Harrison Performing With Rocky in 《Im a Walrus》\nGeorge Harrison With Rocky\nGeorge Harrison Playing Rock in Abbey Road Studio\n关于它的制作过程：\nStratocaster® guitars were almost impossible to find in England in the late 1950s and early 1960s, so when George Harrison actually found one in a shop during the pre-fame early days of the Beatles, he meant to get it but was scooped by the guitarist for Rory Storm and the Hurricanes (whose drummer went by the stage name Ringo Starr).\nA few dizzying years later, when the sessions for Beatles Help! album got under way in early 1965, Harrison had better luck - he and John Lennon sent roadie Mal Evans out to get one for each of them, and Evans soon returned with a matching pair of Sonic Blue Strat® guitars. Harrison\u0026rsquo;s guitar, serial number 83840, still bore a decal from a music store where it was purchased at one point - \u0026ldquo;Grimwoods; The music people; Maidstone and Whitstable\u0026rdquo;. Thus, Help! marks the first appearance of a Stratocaster in Beatles music; heard in the low drone throughout that album\u0026rsquo;s \u0026ldquo;Ticket to Ride\u0026rdquo; and in the solo for \u0026ldquo;You\u0026rsquo;re Going to Lose That Girl.\u0026rdquo; Near the end of 1965, both Strats were put to even more prominent use on groundbreaking album Rubber Soul, most notably on the ringing chordal solo in \u0026ldquo;Nowhere Man\u0026rdquo;, and again on mid-1966\u0026rsquo;s Revolver.\nIn 1967, sometime between the end of the Sgt. Pepper\u0026rsquo;s Lonely Hearts Club Band sessions and the June 25 live worldwide telecast of \u0026ldquo;All You Need is Love\u0026rdquo;, Harrison took up paint and brush himself to give his Stratocaster a multicolored psychedelic dayglo paint job. It also appeared prominently in the \u0026ldquo;I Am the Walrus\u0026rdquo; segment of 1967\u0026rsquo;s Magical Mystery Tour film. The guitar remained a favorite of Harrison\u0026rsquo;s for the rest of the decade, and by December 1969 Harrison had painted \u0026ldquo;Bebopalula\u0026rdquo; on the upper body, \u0026ldquo;Go Cat Go\u0026rdquo; on the pickguard and \u0026ldquo;Rocky\u0026rdquo; - the guitar\u0026rsquo;s nickname - on the headstock.\n\u0026mdash; 摘取自 # LIMITED EDITION GEORGE HARRISON ROCKY STRAT®\n其中提到，Rocky 是由一把 61\u0026rsquo; Stratocaster, 并且是由 George Harrison 本人改造而来。\n下面这段材料揭露了关于改装的细节（主要是颜料方面）：\n“During ’67, everybody started painting everything,” Harrison says, “and I decided to paint it. I got some Day-Glo paint, which was quite a new invention in them days, and just sat up late one night and did it.” (Harrison points out that some of his ex-wife Patti Boyd’s nail polish was used to paint the headstock.)\nThe guitar made appearances that year in the Beatles’ live performance of “All You Need Is Love” on Our World, the first global satellite TV program, and in the film Magical Mystery Tour, in the segment where the Beatles mime to “I Am the Walrus,”\nRocky 使用的主要颜料是 Day-Glo (Day-Glo Color Corp. 生产的一种荧光涂料), 而琴颈部位则是用他当时妻子 Patti Boyd 的指甲油涂绘而成\n我本人非常喜欢 Rocky 的配色，奈何负担不起 Rocky Custom Shop 的高昂费用，也由于墨产 Rocky Player Series 的低性价比而未选择入手\n恰巧我有一把 Fender Vintera 60\u0026rsquo;s Stratocaster, 从年代和琴型上都与原版相对接近。于是我把它送到一位网友那里，完成 Rocky 的复刻\n在改造前，它原本是日落色的，大概这样：\n日落色\n在使用 硝基漆 和一些荧光涂料改造之后：\n可以看到还原度很高，但同时保留了一些原创部分。喷绘的效果还是挺令我满意的\n我带着它参加了一些小型演出\nFender Blues Tweed Deluxe Blues Deluxe™ 是 Fender 的一款晶体管音箱，我选择它有两个原因：\n音色：我对吉他音箱研究不多，但是 Fender 音箱的清音不用多说，很悦耳 外观：这款复古气息的粗花呢黄色音箱本身就是一款装饰品 奈何功率太大，我很少使用它，最多拍视频的时候才想起来用一下\n","permalink":"https://mickjagger19.github.io/posts/music/my-gears/","summary":"A (brief) introduction of my gears","title":"My Gears"},{"content":" [! WARNING] This work is in progress\nNotations Meaning Classifier-guided Diffusion An implementation of Conditional Diffusion Models, which requires a classifier $\\nabla_{x}p(x|y)$ to guide its reverse process Classifier-free Diffusion An implementation of Conditional Diffusion Models, which doesn\u0026rsquo;t require a classfier, the condition serves as an input to its noise predictor Latent Diffusion Models(LDM) A type of Diffusion Models where diffusion processes are done in latent space Introduction Diffusion models usually choose a UNet as its backbone for Noise Predictor, first adopted by Ho et al [^1] , which was inherited from Pixel-CNN++(widely used as the generator in VAE) with a few changes. Although some works have introduced attention blocks into low-level design, its high-level remains intact.\nDiT is proposed to apply Transformer into Diffusion Models, adhering to the best practices of Vision Transformers(ViTs)\nAlso, the scaling behavios of transformers is also explored in DiT\nDiT Design Space Notations Meaning $C$ the channels of input image $I$ the dimension of $z$ $z \\in R^{I \\times I \\times C}$ The latents, also the input of $DiT$ Patch The unit of input. $p$ the dimension of a single patch Classifier-free Diffusion An implementation of Conditional Diffusion Models, which doesn\u0026rsquo;t require a classfier, the condition serves as an input to its noise predictor Latent Diffusion Models(LDM) A type of Diffusion Models where diffusion processes are done in latent space 1. Patchify Patchify is the first layer of DiT, which converts the spatial input $z$ into a sequence to $T$ tokens, each of dimension $d$: $$ z \\in R^{I \\times I \\times C} \\to T \\cdot Token $$ where:\n$Token \\in R^{p \\times p \\times C}$ $T = (\\frac{I}{p})^2$ 2. Positional Embeddings Following patchify, we apply standard ViT frequency-based positional embeddings (the sine-cosine version) to all input tokens: $Token \\to Patch$\n3. Transformer Blocks Following patchify, the input tokens are processed by a sequence of transformer blocks.\nIn-context conditioning In addition to noised image inputs, diffusion models sometimes process additional conditional information:\n$t$: noise timestamps (of DDPM) $c$: class labels c(of input images) natural language description(or caption) The conditions are represented as additional $Token$s, appened to the [input sequence](## 2. Positional Embeddings)\nCross-attention block The conditional tokens are send to the cross-attention block of transformer block\nAdaptie Layer Norm(adaLN) Block The Adaptive Layer Norm replaces the standard layer norm\n[! NOTE] To be completed\n4. Transformer Decoder After the transformer blocks, a transformer decoder is reponsible for decoding the each latent token back to tensor of size $p \\times p \\times C$.\nThe decoder is simply a standrad linear layer\nSora The following is some major takeaways of the tenichal report of Sora\nSora is a diffusion model/diffusion transformer based on DiT\nUnified Representation of Visual Data The major part of the technial report is about the Unified Representation, which is the training data of Sora\nSources We take inspiration from large language models which acquire generalist capabilities by training on internet-scale data\nBased on the description, Sora might crawl a huge amount of data from internet\nPatch Following the text token concept of LLM, and patch concept from [DiT](##1. Patchify), Sora has visual patches.\nThe transformation of videos into patches went through 2 steps:\nCompress videos into lower-dimensional latents Decompose the latents into spacetime patches [! TIP] spacetime implies that the tokens are embedded with timestep information\nWhile the original DiT tokens are fixed-sized based on the size of the latents, the spacetime patches used by Sora is derived from videos/images of variable resolutions, durations and aspect ratios. This gives huge flexibility in inference time, since the output is formed with any patches you like.\nScaling Transformers They find transformers scaled effectively as video models, same as in other domains, including language modeling,13,14 computer vision,15,16,17,18 and image generation.27,28,29\nData preprocessing Native size Different from prior approaches, which crops videos/images to standard size(e.g., 4 seconds videos at 256 * 256 resolution), they find that training on data at its native size benefits.\nNative aspect ratios They empirically find that training on videos at their native aspect ratios improves composition and framing. The model trained on square crops sometimes generates videos where the subject is only partially in view.\nLanguage understanding The language-understanding-ability is a crucial part of text-to-video models, as text is the major input\nRe-captioning Re-captioning is a technique to generate descriptive captions for images/videos with the help of a highly descriptive captioner model\nFirst introduced in the training of DALL$\\cdot$E, it is used in Sora, where GPT serves the role of captioner, who turn short user prompts into longer detailed captions\nPrompting with images and videos Being abled to be prompted with inputs other than text, including images and videos, Sora can perform a wide range of image and video editing tasks.\nSome applications not mentioned in the report Based on the presented applications, Sora might be able to do the tasks of:\nvideo generation conditioned on text/image: generate videos based on the given future/previous text and image Model and implementation details are not included in this report. \u0026ndash; video-generation-models-as-world-simulators\n","permalink":"https://mickjagger19.github.io/posts/ai/models/dit-sora-and-more/","summary":"Review on DiT and sora","title":"DiT, Sora, and more"},{"content":" title: Mamba summary: Mamba tags:\nSSM Mamba RNN author: Mick draft: false date: 2024-01-30T12:38:39+0800 math: true Notations Notations Meaning SSM A math model, used to describe and analyze the behavior of dynamic system. In DL, it helps to process sequence data, by projecting the data into latent space. State Equation and Observation Equation are two important components of a SSM Background The Transformer Family is notorious for $\\mathcal{O}(N^{2})$ time complexity when inferencing, but many of the model targeting this problem has less performance[[ ]]than Transformer.\nState Space Models SSMs(Structured State Space Sequence Models, S4) is defined by four invariant parameters: $(\\Delta, A, B, C)$ and a sequence-to-sequence transformation consisting of 2 phases: $$\n$$\nLinear Systems 1. Discretization $$ \\begin{align} (\\Delta, A, B) \u0026amp;\\to (\\bar A, \\bar B)\\ f_{A}(\\Delta, A) \u0026amp;= \\bar A \\ f_{B}(\\Delta, A, B) \u0026amp;= \\bar B \\end{align} $$\nwhere $(f_{A}, f_{B})$ is called discretization rules, where there are many candidates.\nDiscretization has deep connections with continuous time system, giving it additional properties:\nresolution invariant auto normalization [!NOTE] Discretization is necessary for calculation efficiency\n2. Computation There are two ways to compute\nNotations Meaning $A(\\cdot )$ State matrix Linear Time Invariance System The parameters calculated in Discretization is fixed in all timestampes, this property is called LTI.\nLTI fails from several reasons:\ninvariant dynamics can\u0026rsquo;t select correct information from the context, nor can it change the hidden state with input global convolution requires only time-awareness, but lacks content-awareness Mamba Motive: Selection as a compression A basic model of sequence modeling: Compress the context into a smaller state.\nInterpreting popular sequence models from this view:\nAttention: No explicit compression, but stores all the context in KV-cache Recurrent Model: Limited state, linear time training Strucuted SSMs maps each channel of input $x$ to output $y$ with high-dimensional implicit state $h$\nPrior work of SSms avoids the massive calculation of $DN$ with iterative computation path, with relies on time-invariant.\nSelection Mechainism Notations Notations Meaning Input-dependent dynamics A dynamic enabling sequence model to depend on input Mamba promote a Selection Mechanism: increase input-dependent dynamics, with requires a hardware-aware algorithm.\nA way of blending selection mechanism into model, is to let the inputs affects the parameters of sequence co-effects, e.g. inserting into the recurrent dynamics of RNN or convolution kernel of CNN.\nB and C is changed, to make it selective $\\Delta_{t}$ controls the focusness/neglection to current input $A$ is possibly selective, but for simplicity, it is not considered variant gap filters out the irrelavant noise labels within inputs ","permalink":"https://mickjagger19.github.io/posts/ai/models/mamba/","summary":"Brief introduction to Mamba","title":"Mamba"},{"content":"Terminologies Term Meaning Full fine-tuning Fine-Tune all the weights of a pretrained model Intrinsic dimension An attribute of a dataset, essentially the minimum variable needed to encode the data low intrinsic dimension A description of a dataset, describing that the intrinsic dimension of the dataset is low $h$ The output of the model Introduction PEFT(Parameter Efficient Fine-Tuning) is a technique to reduce the training cost of full fine-tuning by minimize the parameter count and the computation complexity.\nAccording to UniPELT, existing PELT usually involves following variants:\nThe functional form of $\\Delta h$ The form of insertion into Transformer Parallel: At input layer Sequential: At output layer The representation modifies attention layer ffn llayer Composition function of $h$ and $\\Delta h$ Adapter Tuning Only fine-tune the parameters of the layers close to downstream tasks.\nWhile training, the parameter of the original pre-train model is frozen, with a newly-added adapter structure:\nDown-project layer: project the high-dim feature to lower dimension Non-linear Up-project layer: project back to high-dim Skip-connection: $identity$ in the worst case Prefix Tuning Prefix: Prepend learnable task-related virtual tokens to input tokens at $W_{k} \u0026amp; W_{v}$ of each layer An MLP after prefix layer(only in training): down-project a smaller prefix $P_{\\theta}^{\u0026rsquo;}$ to actual prefix$P_ {\\theta}$, to stablize the training [! NOTE] Similar to text prompt, but continuous and implicit\nPrompt Tuning A simplified version of Prefix Tuning, with:\nPrefix virtual tokens prepended only at input layer MLP removed. P-Tuning Notice the problem of LLM: The expression of the prompt has a significant impact on downstream tasks\nP-Tuning is proposed to change the input Prompt to learnable embedding.\nLoRA All of the PEFT methods mentioned above has some problems:\neither: increase the model depth and inference time, e.g.Adapter Tuning or: with learnable parameters which are hard to train It is observed that low intrinsic dimension is the key part of LLMs. Based on this observation, the attention matrix can be re-designed as: $$ h = \\underbrace{W_{0}}{\\text{original weight}}x + \\underbrace{\\Delta W}{\\text{Adapte}}x = W_{0}x + BAx $$ where:\n$A \\in \\mathbb{R}^{d \\times r} \\sim \\mathcal{N}(0, \\sigma^{2})$ $B \\in \\mathbb{R}^{r \\times d}$ $d \u0026gt; r$ Advantages being:\nNo additional depth introduced UniPELT UniPELT provides a unified view of existing PEFTs, and compares each choices of variants:\nParallel insertion form is bettern than Sequantial Modified representation: When the amout of parameter modified is huge, ffn is better ffn is task-related Otherwise Attention attention captures the text pattern Scaling composition function is better ","permalink":"https://mickjagger19.github.io/posts/ai/rl/peft/","summary":"PEFTs","title":"Tuning"},{"content":"Terminologies Term Meaning Receptive field(a.k.a. sensory space) A concept originally from biology, adopted in modern artificial deep neural networks (especially CNN), describing the size of input image which can affects the output of neurons $d_{model}$ dimension of the word embedding(usually 512 = 64 * 8) $d_{k}$ dimension of $w_q, w_k$ $d_{v}$ dimension of $w_v$ $w_{q} \\in \\mathbb{R}^{d_{model} \\times d_{k}}$ $w_k \\in \\mathbb{R}^{d_{model} \\times d_{k}}$ $w_{v} \\in \\mathbb{R}^{d_{model} \\times d_{v}}$ $B$ Batch size $S$ Sequence Length $X$ input Structural Prior translation equivariance An attribute of model, the ability of model to recognize objects does not varies with the geometric transformations of the input(shift, rotate, projection, etc) The Attention of human Selective attention is a mechanism unique to human vision. By swiftly scanning the image, human acquires important areas(a.k.a. focus). After this, human pays more attention to these areas, as there are more valuable information.\nSelf-Attention Self Scaled-Dot Attention:\n$$ \\begin{align} X \u0026amp;= X_{text_encoding}+ X_{positional_embedding}\\ Q \u0026amp;= X \\cdot w_{q} \\in \\mathbb{R}^{S \\times d_{k}}\\ K \u0026amp;= X \\cdot w_{k} \\in \\mathbb{R}^{S \\times d_{k}}\\ V \u0026amp;= X \\cdot w_{v} \\in \\mathbb{R}^{S \\times d_{v}}\\ a \u0026amp;= softmax\\left(\\frac{Q \\cdot K^{\\top}}{d_{k}}\\right)\\in \\mathbb{R}^{S \\times S}\\ Attention \u0026amp;= a V\\in \\mathbb{R}^{S \\times d_{k}}\\ \\end{align} $$\n[!TIP]\nAttention is the weighted (attention score) v of each token over other tokens The major different between attention and typical RNN is: The generation of next token doesn\u0026rsquo;t rely on hidden state from previous timestamp, but instead alter the embedding of the token directly with positional embedding.\n[!TIP] Some researchers seems Attention as a kind of soft addressing\nCross-Attention Different from Self-Attention, the $Q, K$ of cross-attention comes from another sequence($X_{2}$): $$ \\begin{align} Q \u0026amp;= X_{1} \\cdot w_{q} \\in \\mathbb{R}^{n \\times d_{k}}\\ K \u0026amp;= X_{2} \\cdot w_{k} \\in \\mathbb{R}^{m \\times d_{k}}\\ V \u0026amp;= X_{2} \\cdot w_{v} \\in \\mathbb{R}^{m \\times d_{v}}\\ a \u0026amp;= softmax\\left(\\frac{Q \\cdot K^{\\top}}{d_{k}}\\right)\\in \\mathbb{R}^{m \\times n}\\ \\end{align} $$\nThus, the attention matrix $a$ represents the attention between $X_{1}$ and $X_{2}$\nFeatures Multi-head $$ MultiHeadAttention(Q, K, V) = Concat(Attention_{i})W^{O}, i \\in (0, h) $$\nlet each head focus on one part of input, concatenating and increasing the receptive field of the NN Grammar \u0026amp; Context \u0026amp; Rare words are what heads are focusing on Compared to multi-layer attention, it can be trained parallelly Parallelism $$ Attention_{0:t, 0:t} =concat(Attention_{0:t-1, 0:t-1}, Attention_{0:t-1, t}) $$\nmaking it possible to train parallelly.\nScaling with $d_{k}$ without scaling, Softmax can easily causes gradient vanishing $\\sqrt{d_{k}}$: the variance of $q \\cdot k \\to d_{k}$, to let the variance close to 1: $Var(A \\cdot B) = Var\\left(\\sum\\limits{A_{ij}B_{ji}}\\right)=\\sum\\limits Var(A_{ij}B_{ji}) = d_{k}^{2}$ Production \u0026amp; Multiplication production: increase representation ability? multiplication: faster. performance increase along with $d_{k}$ Layer Norm \u0026amp; Batch Norm LN: Apply normalization to a whole batch. BN: Apply normalization to one position across different batches BN is often applied by CNN\nFor sequences with different lengths, same feature across sequences is irrelevant(BN is not designed to deal with variant-length sequences), so NLP prefers normalization within a sequence : LN.\nParallelism Encoder: sequential Decoder: only in training, using sequence mask(predicting next tokens of different sequences at the same time) Long-Distance Dependency Self-Attention can capture the co-dependent features in long-distance, since it avoids accumulating \u0026amp; calculating hidden states for several timestamps.\nFundamental Ideas $Q, K ,V$ is essentially a database with global semantic relationship.\nSparse Attention In standard attention mechanism, the attention between tokens are pair-wise\nHowever, it is observed that most of the time, the attention matrix $A$ is sparse\nSparse Attention Notation Meaning Attention kernel The tokens required for the attention to predict next token OpenAI reduces the time complexity by \u0026ldquo;keep the value in small region, enforcing most elements as zero\u0026rdquo;\nIt is observed that attention has gained inductive bias similar in CNN:\nshallow layers: patterns in local connection deep layers: global patterns To introduce the sparse feature of CNN into attention, they introduce a concept: Connectivity Pattern: $$ S = {S_{1}, \u0026hellip; , S_{n}} $$\nwhere $S_{i}$ is the indices at timestamp i.\nAnd attention is transformed to:\n$$ \\begin{align} a(x_{i}, S_{i}) = softmax\\left(\\frac{(W_{q}x_{i})K_{S_{i}}^{\\top}}{\\sqrt{d}}\\right)V_{S_{i}}\\ \\end{align} $$\ndecompose the full attention with sparse attentions However:\nthe kept attention region is decided by human, not dynamic Position-based Sparse Attention Atomic Sparse Attention Single-form connection of attention units\nGlobal Attention: adding some global nodes as the center of information broadcast Band Attention(a.k.a sliding window attention, or local attention): Due to the strong locality of data, limit the query of its neighboring nodes Dilated Attention: Increase inductive field by using expanding window with a hole Random Attention: 为了增加非局部交互的能力，每个查询随机采样一些边缘。这是基于观察随机图可以与完整图具有相似的光谱属性 Block Local Attention: Split the input sequence into query blocks, each block is associated with a local memory block. A query block would only focus on the key from its memory block Compound Sparse Attention Combination of the atomic attentions mentioned above\nExtended Sparse Attention Design special sparse structure for specific data\nContent-based Sparse Attention Build sparse graph on input content\nLinearized Attention Though being able to parallize, it has the complexity of $\\mathcal{O}(n^{2})$ in both time and space.\nSome work have achieved linear complexity in various way\n[!TIP] The time complexity of multipling $\\mathbb{R}^{a \\times b} \\cdot \\mathbb{R}^{b \\times c}$ is $\\mathcal{O}(abc)$\nRemove Softmax The existence of Softmax enforce the calculation of $QK^{\\top}$, which is the source of $\\mathcal{O}(n^{2})$.\nRemoving the softmax, the attention became: $A = QK^{\\top}V$:\nCalculate $K^{\\top}V$: $\\mathcal{O}(d^{2}n) \\approx \\mathcal{O}(n)$ Calculate $Q(K^{\\top}V)$: $\\mathcal{O}(nd^{2}) \\approx \\mathcal{O}(n)$ Replace Softmax with sim By rewriting the $e^{q_{i}^{\\top}k_{j}}$ with normal similarity function: $$ \\begin{equation} Attention(\\boldsymbol{Q},\\boldsymbol{K},\\boldsymbol{V}){i} = \\frac{\\sum\\limits{j=1}^{n} \\text{sim}(\\boldsymbol{q}{i}, \\boldsymbol{k}j)\\boldsymbol{v}{j}}{\\sum\\limits{j=1}^{n} \\text{sim}(\\boldsymbol{q}{i}, \\boldsymbol{k}{j})} \\end{equation} $$\nAdding non-negative activation function(kernal method) to $q, k$: $sim(q_{i}, k_{j}) = \\phi(q_{i})\\varphi(k_{j})^{\\top}$ 《Transformers are RNNs: Fast Autoregressive Transformers with Linear Attention》: $\\phi(x) = \\varphi(x) = \\text{elu}(x) + 1$ Apply Softmax to $Q, K$ separately: $\\begin{equation}Attention(\\boldsymbol{Q},\\boldsymbol{K},\\boldsymbol{V}) = softmax_2\\left(\\boldsymbol{Q}\\right)softmax_1(\\boldsymbol{K})^{\\top}\\boldsymbol{V}\\end{equation}$ , where $softmax_{i}$ means softmax in $i$-th dimension 《Efficient Attention: Attention with Linear Complexities》 Apply taylor expansion to $e^{\\boldsymbol{q}_i^{\\top}\\boldsymbol{k}_j}$: $\\begin{equation}\\text{sim}(\\boldsymbol{q}_i, \\boldsymbol{k}_j) = 1 + \\left( \\frac{\\boldsymbol{q}_i}{\\Vert \\boldsymbol{q}_i\\Vert}\\right)^{\\top}\\left(\\frac{\\boldsymbol{k}_j}{\\Vert \\boldsymbol{k}_j\\Vert}\\right)\\end{equation}$ Reformer Approximately find the maximum Attention quickly, by LSH(Locality Sensitive Hashing)\nThis inspires us to reduce time complexity by:\nintroducing the sparse bias into attention mechanism combine structural bias(deleting connections in some neurons) Linformer Project $K, V$ with two matrixes before Attention:\n$$ \\begin{align} E, F \u0026amp;\\in \\mathbb{R}^{m \\times n}\\ Attention(Q, K,V) \u0026amp;= softmax(Q(EK)^{\\top})FV \\end{align} $$\n[!TIP] Linformer is sub-sampling the sequence, so it\u0026rsquo;s nature to think of pooling\nby disentangle attention matrix with kernal feature map\nLow-rank Self-Attention it is observed that most of the time, the attention matrix $a$ is low-rank\nLow-rank Parameterization Parameterize the attention matrix with simpler structure, as an inductive bias\nLow-rank Approximation Approximate attention matrix with a low-rank matrix\nAttention with Prior Replace standard attention with prior attention distribution\nPrior that Models locality Prior from Lower Modules Adopt prior(attention) from previous attention layer\nAttention with Prior Only Derive the attention only with prior, not from the pari-wise dependency of input sequence\nImproved multi-head Head Behavior Modeling It is not guaranteed that multi-head can increase the inductive field, some works have tried:\nIncrease the feature representation ability of each head guide the interactions between each heads to achieve taht. Multi-head with restricted Spans It might be helpful to combine global heads and local heads, reasons being:\nLocality Effenciency Multi-head with Refined Aggregation Aggregate the output of each head with more complexity, rather simple concatenating them.\nImproved FFN Activation Position-wise FFN Variants GLU [GLU](Gated Linear Unit) replaces the FFN with: $$ O = (U \\odot V)W_{o}, U = \\phi_{u}(XW_{u}), V = \\phi_{v}(XW_{v}) $$ In comparison, FFN: $$ O = \\phi(XW_{u})W_{o} $$\n[!NOTE] GLU replaces first MLP with the dot-product of two MLPs\nFlash Attention GAU Simplified attention: $$ A = \\frac{1}{n}\\text{relu}^{2}\\left(\\frac{Q(Z)K(Z)^{T}}{\\sqrt{s}}\\right)= \\frac{1}{ns}\\text{relu}^{2}(Q(Z)K(Z)^{T}), Z = \\phi_{z}(XW_{z}) $$\nMove the activation before QK-step Removes the V replace softmax with relu With Time Complexity $O(n^2)$\nApplications NLP Computer Vision Audio Multi-modal ","permalink":"https://mickjagger19.github.io/posts/ai/models/the-attention-mechanism/","summary":"Attention","title":"The Attention Family"},{"content":"Introduction The mathematics in GAN and WGAN\nNotations Notation Meaning Jensen-Shannon Divergence An improved, symmetric version of $KL$ Divergence:\n$$D_{JS}(p||q) = \\frac{1}{2} D_{KL}\\left(p | \\frac{p+q}{2}\\right)+ \\frac{1}{2} D_{KL}\\left(q | \\frac{p+q}{2}\\right)$$ GAN Notation Meaning $p_{z}$ distribution of noise input $z$ $p_{g}$ distribution of generator output $x$ $p_{r}$ distribution of real sample $x$ Arch The original GAN is an architecture (does not define the implementation details) consisting of two models:\nDiscriminator $D$: Estimates the probability of a given sample comes from the real dataset Generator $G$: Generates synthetic samples with a noise variable input $z$ (for diversity) These two models compete against each other, forming an adversarial relationship.\nObjective Design The objective function is defined as the combinations of performances of $D$ and $G$:\n$$ \\mathcal{L}(D,G) = \\underbrace{\\mathbb{E}_{x \\sim p_{r}(r)}[\\log D(x)]}_{\\text{for D to identify real samples}} + \\underbrace{\\mathbb{E}_{z \\sim p_{z}(z)}[\\log (1 - D(G(z)))]}_{\\text{for G to generate fake samples}} $$ Using the same objective function, the direction of optimization varies:\n$D$: $D(x) \\to 1, D(G(z)) \\to 0$, so for $D$ it\u0026rsquo;s maximize $G$: $p_{g} \\to p_{r}$, since $D(p_{r}) \\to 1$, so for $G$ it\u0026rsquo;s minimize [!TIP] Other interpretations of objective function:\nThe JS-Divergence of $p_{r}, p_{g}$: $G$ tries to minimize Energy: $D$ tries to model energe-function $U(x)$, $G$ tries to generate sample $\\hat{x}$ with (local) minimum energy $U(x)$ Optimal We derive the optimal status for both models for xxx reasons.\nDiscriminator Rewrite objective function $\\mathcal{L}(D,G)$:\n$$ \\begin{align*} \\mathcal{L}(D,G) \u0026= \\mathbb{E}_{x \\sim p_{r}}[\\log D(x)] + \\mathbb{E}_{z \\sim p_{z}}[\\log (1 - D(G(z)))]\\\\\\\\ \u0026= \\mathbb{E}_{x \\sim p_{r}}[\\log D(x)] + \\mathbb{E}_{x \\sim p_{g}}[\\log (1 - D(x))]\\\\\\\\ \u0026= \\int_{x}{p_{r}\\log D(x) + p_{g}\\log (1 - D(x))}\u0026 \\text{actually L(D)}\\\\\\\\ \\end{align*} $$ $$ \\begin{align*} \u0026amp;\\frac{d(L(D^{\\ast}))}{ dD^{\\ast}} = \\frac{p_{r}}{D(x^{\\ast})} + \\frac{p_{g}}{1 - D(x^{\\ast})} = 0\\\\ \u0026amp;\\Rightarrow D^{\\ast}(x) = \\frac{p_{r}}{p_{r} + p_{g}}\\\\ \u0026amp;\\Rightarrow D^{\\ast}(x) = \\frac{1}{2} \\end{align*} $$\nThat is to say, when $G$ is trained to optimal, $D$ will output probability as 0.5\nGenerator $$ \\mathcal{L}(G) = \\mathcal{L}( D = D_{0}, G) = 2D_{JS}(p_{r}||p_{g}) - 2 \\log 2 $$ So the target of training $G$ can be interpreted as increasing the distance between $p_{r}$ and generated distribution $p_{g}$:\n$$ \\mathcal{L}( D, f^{\\ast}) = \\mathbb{E}_{x \\sim p_{r}}[f(x) ] - \\mathbb{E}_{z \\sim p_{z}}[f(G(z))] $$ [!TIP] Almost in all GANs, for $G$, the objective can always be interpreted as (some kind of) difference between $p_{r}$ and $p_{g}$\nProblems of GAN Hard to achieve Nash Equilibrium Ideally, two models are trained simultaneously(or iteratively) to find a Nash Equilibrium to a two-player non-cooperative game. However, they update independently without coordination, so the convergence is not guaranteed.\nA simulation of $D$ and $G$ to update regardless of each other\n[!NOTE] Maybe the idea of advesarial and cooperative(for a better overall result) are fundamentally contradictory\nVanishing gradient When $D$ does a great job but $G$ does not, $D(x) \\to 1, x \\in p_{g}$, which is a constant value, this will lead to objective function being a fixed constants, thus the $\\ell \\to 0$.\nThe log_gradients of the generator decays quickly. Also, the better the $D$, the smaller the gradient\nHence, the ability of $D$ is faced with a dilemma: it can be neither too good or too gad.\nMode Collapse During training, the generator may collapse to a setting where it always produces same outputs. This is a common failure case for GANs, commonly referred to as Mode Collapse(or Mode Dropping).\n[!TIP] The reason of mode collapse can be interpreted as: the generator finds a local optima where the loss-map is really sharp, leading to lack in diversity, due to the nature of KL-divergence\nLack of a reliable evaluation metric The score given by $D$ does not provide an objective metric of the quality of image.\nSGAN Notations Meaning $\\delta$ distribution: Dirac delta function A function, whose value is zero everywhere except at zero, and $\\int \\delta = 1$ $T$ SGAN designs the Discriminator loss as:\n$$ \\begin{equation}\\mathcal{D}{SGAN}[p(x),q(x)] = \\max{T}, \\frac{1}{2}\\mathbb{E}{x\\sim p(x)}[\\log \\sigma(T(x))] + \\frac{1}{2}\\mathbb{E}{x\\sim q(x)}[\\log (1 - \\sigma(T(x)))] + \\log 2\n\\end{equation} $$ which is basically a dual form of JS-Divergence.\nConsider a case, where $p(x)$ and $q(x)$ has no intervention: $$ \\begin{equation}p(x)=\\delta(x-\\alpha),q(x)=\\delta(x-\\beta)\\end{equation} $$ This changes loss function into: $$ \\begin{equation}\\mathcal{D}[p(x),q(x)] = \\max_T, \\frac{1}{2}[\\log \\sigma(T(\\alpha))] + \\frac{1}{2}[\\log (1 - \\sigma(T(\\beta)))] + \\log 2\\end{equation} $$\nAnd while training, $T(\\alpha) \\to +\\infty, T(\\beta) \\to -\\infty$\nWGAN Notation Meaning Wasserstein Distance(a.k.a. Earth Mover’s distance, short for EM distance) $\\mathcal{W}$ A measure of the distance between two PD, as the minimum energy cost of moving and transforming two PDs for them to be the same, a.k.a. the optimal transport cost. $$\\mathcal{W}(p,q) = \\inf_{\\gamma \\sim \\prod(p,q)}{\\mathbb{E}_{(x,y) \\sim \\gamma}[c(x,y)]}$$ Lipschitz continuity A strong form of uniform continuity for functions. If $\\vert f(x_{1} - f(x_{2})\\vert \\le K\\vert x_{1} - x_{2}\\vert$, f is called $K$-Lipschitz, formally $\\vert f\\vert _{L} \\le K$ infimum $\\inf$ the greast lower bound, in most cases the minimum supremum $\\sup$ the least upper bound, in most cases the maximum critic $f(.)$ the form of $D$ in WGAN. No longer outputting the realism (a probability) of sample, it learns a specific distance (or a score, of distributions) from samples. $f(x) = D(x)$ [!TIP] W-Distance is better than JS and KL for providing a smooth measure of distributions, even when they are disjoint\nWGAN(Wasserstein Generative Adversarial Nets) is proposed to replace JS-divergence with W-distance, due its smooth-measurement nature.\nStarting from the W-Distance of $p_{r}, p_{g}$, the objective function of WGAN is derived into the form:\n$$ \\mathcal{L} = \\mathcal{W}_{K}(p_{r}, p_{g}) = \\sup_{f, |f|_{L} \\le K}{\\mathbb{E}_{x \\sim p_{r}}[f(x) ] - \\mathbb{E}_{x \\sim p_{g}}[f(x)]} $$ WGAN consists of :\n$f(.)$ : Be used to approximate the W-Distance between two distributions to whom inputs belongs. It is trained by maximizing the objective function, formally, the subtraction of two scores. It is meant to find the maximum from all possible $f$ $G$: Generates samples. It is trained to minimize the objective function [!TIP]\nIn order to let critic $f$ subject to Lipschitz continuity, weight clipping is applied to indirectly achieve that. Unlike original GAN, critic can be trained as good as possible but not leading to problems like gradient vanishing and mode collapse WGAN-GP Although improved, WGAN sometimes suffer from problems like Hard to achieve Nash Equilibrium, still.\nIdentifying and proving weight clipping as a reason of that, authors of WGAN-GP replace it with gradient penalty(GP):\n$$ \\begin{align} \\mathcal{L} = \\underbrace{\\mathbb{E}_{\\tilde x \\sim p_{g}}[D(\\tilde x)] - \\mathbb{E}_{\\tilde x \\sim p_{r}}[D(x)]}_{\\text{Original critic loss}} + \\underbrace{\\lambda\\mathbb{E}_{\\tilde x \\sim p_{\\tilde x }}[(||\\nabla_{\\hat x}(D(\\hat x))||_{2}- 1)^2]}_{\\text{gradient penalty}} \\end{align} $$ GAN-QP Consider the following divergence: QP-div, quadratic potential divergence: $$ \\begin{equation}\\begin{aligned}\u0026amp;\\mathcal{D}[p(x),q(x)] \\ =\u0026amp; \\max_{T}, \\mathbb{E}_{(x_r,x_f)\\sim p(x_r)q(x_f)}\\left[T(x_r,x_f)-T(x_f,x_r) - \\frac{(T(x_r,x_f)-T(x_f,x_r))^2}{2\\lambda d(x_r,x_f)}\\right]\\end{aligned}\\end{equation} $$ where:\n$\\lambda \u0026gt; 0$ $d$ is any distance function It\u0026rsquo;s natural to build Loss Function for $D$ and $G$ with the Divergence, but for $G$, the quadratic term is neglected, since minimizing the denominator $d$ is not feasible. $$ \\begin{equation}\\begin{aligned}\u0026amp;T= \\mathop{\\arg\\max}T, \\mathbb{E}{(x_r,x_f)\\sim p(x_r)q(x_f)}\\left[T(x_r,x_f)-T(x_f,x_r) - \\frac{(T(x_r,x_f)-T(x_f,x_r))^2}{2\\lambda d(x_r,x_f)}\\right] \\ \u0026amp;G = \\mathop{\\arg\\min}G,\\mathbb{E}{(x_r,x_f)\\sim p(x_r)q(x_f)}\\left[T(x_r,x_f)-T(x_f,x_r)\\right]\\end{aligned}\\end{equation} $$\nf-GAN Notation Meaning f-divergence A generalized version of KL-divergence and JS-divergence: $$\\mathcal{D}_{f}(P|Q) = \\int{q(x)f(\\frac{p(x)}{q(x)})dx}$$, where $f$ is a convex function with measures the difference between PDs $T$ The gradient of $f = \\frac{p(x)}{q(x)}$ In a nutshell, the $f$-GAN:\nDecide an $f$ Learn a model $\\mathcal{D}$ to score the input $x \\sim p_{r}, y \\sim p_{g}$, whose results can be used to approximate the $f$-divergence between $p_{r}$ and $p_{g}$ Formulate the objective function as: $$\\mathcal{L} = \\mathbb{E}_{x \\sim P_{\\text{data}}} [T^*(D(x))] - \\mathbb{E}_{z \\sim P_z} [f^*(T^*(D(G(z))))]$$ BiGAN Changes the task of $D$, $D(x, z)$ outputs the possibility of $x$ coming from real image.\nBesides, the divergence of $p(x|z)$ and prior $\\mathcal{N}(0, I)$ is no longer included in the loss, the target is achieved by optimizing $D$\n$$ \\mathcal{L} = (0 - D_{x\\sim p_{g}, z\\sim \\mathcal{N}(0, I)}(x,z)))^{2} + (1 - D_{x\\sim p_{r}, z\\sim p(z|x)}(x,z)))^{2} $$\nSAGAN GAN fails to capture the invariant geometric pattern within some categories, e.g. the fur of dogs. This is not brought by GAN itself, since it doesn\u0026rsquo;t imply any implementation, but brought by relying on Convolution to capture dependency between different regions.\nSAGAN(Self-Attention GAN) proproses two changes:\nIntroduce self-attention into GAN: promotes the long-distance dependency and description of geometric features of image generation Introduce spectral normalization into experiments, achieving better results Set different learning rates for $G$ and $D$: $l_{r_{D}}$ = 4e-4, $l_{r_{G}}$ = 1e-4 hinge adversarial loss: $L_{D} = -\\mathbb{E}{(x,y)\\sim p{data}}[min(0, -1 + D(x,y))] -\\mathbb{E}{z\\sim p{z,}y \\sim p_{data}}[min(0, -1 - D(G(z),y))]$, restricting ability of $D$ BigGAN Notations Notations Meaning Orthogonal matrix A matrix, which row/column vectors are unit vector, and co-orthogonal. The reverse matrix of an orthogonal matrix is equal to its transpose matrix, $A^{T}A = AA^{T} = I$. The transpose of a real-valued orthogonal matrix is orthogonal. Conjugate transpose A matrix as a result of taking the conjugate of each elements, then transpose the original matrix. For real-valued matrixs, conjugate transpose is equal to transpose, since the conjugate of a real value is itself Singular Value Decomposition(SVD) An algorithm for decomposing matrix as eigenvector and eigenvalue, representing $A$ as: $A = U\\Sigma V^{\\ast}$, where $\\Sigma$ is eigenvalue, $U$ is left eigenvector, $V$ is right eigenvector Eigenvalue Special value of a matrix, indicating the energy of a matrix in according eigenvector direction. In the direction of a eigenvector with bigger eigenvalue, data varies faster(e.g. the variation of the projected-matrix is bigger in the direction), so keeping the biggest eigenvalues is ideal in data compresion/dimension reduction Singular Value eigenvalue of the matrix Spectral Norm (a.k.a. Induced 2-norm) Maximum Singular value of the matrix:$$|A|{2} = \\max{|x|{2}\\ne0} \\frac{|Ax|{2}}{|x|_2}$$By restricting spectral norm, Lipschitz can also be controlled. BigGAN bases on SAGAN, introduce several improvements:\nSend $z$ to multiple layers of $G$ with skip-net instead of input layer only Truncation trick: Truncate $z$ by setting threshold, exceeded sample is resampled until falling into the range Hinge adversarial loss: Spectral Norm VAE-GAN The original output of VAE is blurry. By adding a discriminator, we hope it will recognize the blurs in the image.\n","permalink":"https://mickjagger19.github.io/posts/ai/models/the-gan-family/","summary":"Personal takeaways of GAN \u0026amp; its variants","title":"GAN \u0026 Variants"},{"content":"Terminologies General:\nTerm Meaning Reinforcement Learning A branch/paradigm of machine learning, concerned with how an intelligent agent behaves in a dynamic environment. BLUE(bilingual evaluation understudy) An algorithm for evaluating the quality of text which has been machine-translated from one natural language to another Reward Model(Actor model) A model aligned with human feedback, predicting the reward of given actions $G_{t}$ Return(aka the future reward), total sum of discounted rewards after time $t$: $G_{t} = {\\sum}^{\\infty}_{k = 0}\\gamma^{k}R_{t + k + 1}$ $V_{\\pi}(s)$ State-value function, measures the expected return of state $s$: $V(s) = \\mathbb{E}_{\\pi}[G_{t}\\vert S_{t} = s]$ under $\\pi$ $Q_{\\pi}(s,a)$ Action-value function, measures the expected return of action $a$ under state $s$: $Q_{\\pi}(s, a) = \\mathbb{E}_{\\pi}[G_{t} \\vert S_{t} = s, A_{t} = a]$ under $\\pi$ Bellman Equations A set of equations that decompose the value function into immediate reward + discounted future values $A_{q}$ the action to update $Q$ $A_{t+1}$ the actual taken action In RL Algorithms (mostly adjectives):\nTerm Meaning Model-based Algorithms of RL relying on a (environment dynamic) model, which defines $P(s\u0026rsquo;\\vert s,a), R(s,a)$ Model-free Algorithms of RL learning by the interaction of the model with environment Policy-Based(Policy Gradient) Methods A branch of RL: quantize each action as PDF Value-Based Methods A branch of RL: quantize each action as value(PMF ? ) Current policy The policy(actions) actually taken by an agent in an episode On-policy Using the action in current(actually exploited/taken) policy to update $V$ Off-policy Using an action not from current policy to update $V$ Introduction Value-based Dynamic Programming We can use Dynamic Programming to iteratively update and query value functions ($V_{\\pi}$), with the help of Bellman equations, when the model is fully known.\nMonte-Carlo #model_free\nInstead of modeling the environment, MC methods learns from episodes of raw experience, approximating the observed mean return as expected return.\nTo optimally learn in MC, we take following steps:\nImprove the policy greedily: $\\pi(s) = \\underset{a}{argmax}Q(s, a)$ Generate a new episode with the combination of the new policy $\\pi$ and randomness(e.g. $\\epsilon$-greedy), balancing between exploitation and exploration Estimate $Q$ with the generated episode $\\pi$ Temporal Difference methods #model-free\n[!NOTE] TD learning can learn from incomplete episodes\nBootstrapping Estimate the rewards, rather than exclusively carrying out the episode.\nValue Estimation The estimated Value funciont $V$ is updated towards an estimated return $R_{t+1} + \\gamma V(S_{t+1})$\nSARSA #on-policy\n[!TIP] Define $A_{q}$ as the action to update $Q$\nState-Action-Reward-State-Action In each $t$:\nChoose $A_{t} = \\underset{a \\in A}{argmax}{Q(S_{t}, a)}$ with $\\epsilon$-greedy Obtain $R_{t + 1}$ Set $A_{t+1} \\sim \\pi(\\cdot|s) = A_{q}$, under current policy Update $Q$ with the advantage of actual $A_{t+1}$ over expected reward: $$ Q(S_{t}, A_{t}) \\leftarrow Q(S_{t}, A_{t}) + \\alpha(\\underbrace{R_{t+1} + \\gamma Q(S_{t + 1}, A_{t + 1})}_{\\text{value of current policy, on-policy}} - \\underbrace{Q(S_{t},A_{t})}_{\\text{expected value}}) $$ $t = t + 1$ [!NOTICE] $A_{q} == A_{t + 1}$, making it on-policy\nQ-Learning #off-policy\nQ-learning is an off-policy method, with the steps in one episodes ($t, S_{t}$) being:\nChoose $A_{t} = \\underset{a \\in A}{argmax}Q(S_{t}, a)$ with $\\epsilon$-greedy Obtain $R_{t + 1}$ Set $A_{t+1} \\sim \\pi(\\cdot|s)$, $A_{q} = \\underset{a \\in A}{\\max} Q(S_{t + 1}, a)$ Update $Q$ with the advantage of optimal $A_{t + 1}$ over expected reward:\n$$Q(S_{t}, A_{t}) \\leftarrow Q(S_{t}, A_{t}) + \\alpha(\\underbrace{R_{t+1} + \\gamma \\underset{a \\in A}{\\max} Q(S_{t + 1}, a)}_{\\text{best value after $A_{t}$, off-policy}} - \\underbrace{Q(S_{t}, A_{t})}_{\\text{expected value}}) $$ $t = t + 1$ [!NOTICE] $A_{q} = \\underset{a \\in A}{\\max} Q(S_{t + 1}, a) \\ne A_{t + 1}$, making it off-policy\nDQN #off-policy\nDeep Q-Network, An improvement of Q-Learning:\nExperience Replay: All the episode steps $e_{t} = (S_{t}, A_{t}, R_{t}, S_{t+1})$ are stored in one replay memory $D_{t} = {e_{1}, \u0026hellip;, e_{t}}$. During Q-learning updates, samples are drawn at random from the replay memory and thus one sample could be used multiple times. Periodically Updated Target: Q is optimized towards target values that are only periodically updated(not updated in each iteration anymore). The Q network is cloned and kept frozen as the optimization target every C steps (C is a hyperparameter). [!WARNING] Known for overestimating value function $Q$\nPolicy Gradient $$ \\begin{align*} J(\\theta) = \\underset{s \\in S}{\\sum\\limits} d^{\\pi}(s)V^{\\pi}(s) = \\underset{s \\in S}{\\sum\\limits} d^{\\pi} \\underset{a \\in A}{\\sum\\limits} \\pi_{\\theta}(a|s)Q^{\\pi}(s,a) \\end{align*} $$ Actor-Critic Actor-Critic learns the value function in addition to the policy, assisting the policy update.\nIt consists of two models:\nActor updates the policy $\\theta$ of $\\pi_\\theta(a|s)$, suggested by critic Critic updates the value estimation function $Q(a|s) | V_{w}(s)$ The main process being, for $t \\in (1, T)$:\nSample $a \\sim \\pi_{\\theta}(a|s), r_{t} \\sim R(s,a), s\u0026rsquo; \\sim P(s\u0026rsquo;|s,a)$, next action $a\u0026rsquo; \\sim \\pi_{\\theta}(a\u0026rsquo;|s\u0026rsquo;)$ Update Actor $\\theta$: $$ \\theta \\leftarrow \\theta + \\alpha_{\\theta} Q_{w}(s,a)\\nabla_{\\theta} ln \\pi_{\\theta}( a|s) $$\nto maximize the reward 5. Compute the correction (TD error, measures the quality of current policy $a\u0026rsquo;$): $$ \\delta_{t} = \\underbrace{r_{t} + \\gamma Q_{w}(s', a')}_{\\text{Action-Value of a'}} - \\underbrace{Q_{w}(s,a)}_{\\text{actual reward}} $$ 6. Update Critic: $w \\leftarrow w + \\alpha_{w}\\delta_{t}\\nabla_{w}Q_{w}(s,a)$ to reduce estimate error (ideally, $\\delta_{t} \\leftarrow 0$, as $a\u0026rsquo; \\sim \\pi_{\\theta}(a\u0026rsquo;|s\u0026rsquo;)$) 7. Update $a \\leftarrow a\u0026rsquo;, s \\leftarrow s'$\n[!TIP] Adversarial training, resembles GAN: (generator, discriminator)\nA2C Model Meaning Actor $\\pi_{\\theta}$ The target model Critic Estimate $V$ $$ L(\\theta) = -\\log \\pi_{\\theta}(a_{t}|s_{t})\\hat A_{t} $$\nwhere:\n$\\hat A$: advantage function, the advantage of $a_{t}$ compared with average, normally $V$ [!WARNING] This objective function can lead to massive change to policy\nA3C Asynchronous Advantage Actor-Critic focuses on parallel training. Multiple actors are trained in parallel and get synced with global parameters.\nDPG #model-free #off-policy\nDeterministic Policy Gradient models the policy as deterministic function $a = \\mu(s)$.\nIt is trained by maximizing the objective function: the expected discounted reward:\n$$ J(\\theta) = \\int_{S}\\rho^{\\mu}(s)Q(s, \\mu_{\\theta}(s))ds $$\nwhere:\n$\\rho^{\\mu}(s\u0026rsquo;)$: discounted state distribution $\\mu$: the deterministic action predictor DDPG #model-free #off-policy\nDeep Deterministic Policy Gradient\nCombining DQN (experience replay, freezing target model) and DPG\nKey design:\nBetter exploration: $\\mu’(s) = \\mu_{\\theta}(s) + \\mathcal{N}$, adding noise $\\mathcal{N}$ to policy Soft updates: Moving average of parameter $\\theta$ TD3 Twin Delayed Deep Deterministic applied tricks on DDPG to prevent overestimating value function:\nClipped Double Q-learning: Action selection and Q-value estimation are made by two networks separately. Delayed update of target the policy network: Instead of updating actor and critic in one iteration, TD3 updates the actor at a lower frequency than critic, waiting for it to become stable. It helps reducing the variance. Target policy smoothing: Introduce a smoothing regularization strategy by adding $\\epsilon \\sim clip(\\mathcal{N}(0, \\sigma), -c , +c)$ to the value function $Q_{w}(s\u0026rsquo;, \\mu_{\\theta}(s\u0026rsquo;) + \\epsilon))$. It mitigates the risk of deterministic policies overfitting the value function. SAC Soft Actor-Critic learns a more random policy by incorporating the entropy of the policy $H(\\pi)$ into the reward.\nThree key components:\nAn actor-critic architecture An off-policy approach Entropy Maximization to encourage exploration The policy is trained by maximizing the objective function: expected return + the entropy $$ J(\\theta) = \\sum\\limits_{t = 1}^athbb{E}_{s_{t},a_{t} \\sim \\rho_{\\pi_ {\\theta}}} [r(s_{t},a_{t}) + \\alpha \\mathcal{H}(\\pi_{\\theta}(* | s_{t}))] $$ PPO (Proximal Policy Optimization) #on-policy\n[!TIP]\nclipped objective Proximal stands for Reward Model As a successor of A2C, PPO defines 2 more models:\nModel Meaning Reward $r_{\\theta}$ Calculate $R$ Reference $\\pi_{ref}$ Apply constraint and guidance to Actor $r^{\\ast}$ Ground-truth reward function $r_\\phi$ MLE of $r^{\\ast}$ $$ L(\\theta) = \\underbrace{-\\hat A_{t} \\cdot min(r_{t}(\\theta), clip(r_{t}(\\theta), 1 - \\epsilon, 1 + \\epsilon))}{\\text{A2C loss, $\\le 1$ + $\\epsilon$}} - \\underbrace{\\beta D{KL}(\\pi_{\\theta}(y|x)||\\pi_{ref}(y|x))}_{\\text{penalty of being too distant to normal response}} $$\nwhere:\n$r_{t}(\\theta) = \\frac{\\pi_{\\theta}(a_{t}|s_{t})}{\\pi_{\\theta_{old}}(a_{t}|s_{t})}$: the ratio of new policy to old policy $\\epsilon$: normally 0.1 or 0.2 Generate two outputs from same input $x$: $y_{1}, y_{2}$ Objective: $\\mathcal{L} = \\underset{\\pi_{\\theta}}{\\max}\\mathbb{E}[r_{\\theta}(x,y_{2})]$ Update: Optimize with the reward of current batch TRO(Trust Region Optimization): using gradient constraint to make sure the update process doesn\u0026rsquo;t sabotage the stability of learning process. [!TIP]\n$r$ and $\\pi$ can be optimized iteratively. RLHF and PPO is difficult to train. DPO(Direct Preference Optimization) [!NOTE] The major difference Direct: directly optimize with reward, rather than $V | Q$: expected rewards from a reward model\nRewrite objective:\n$$ \\begin{align*} \\pi \u0026amp;= \\underset{\\pi}{\\max}(r_{\\phi}(x,y) - \\beta D_{KL}(\\pi_{\\theta}(y|x)||\\pi_{ref}(y|x)))\\\\ \u0026amp;= \\underset{\\pi}{\\max}(r_{\\phi}(x,y) - \\beta \\log \\frac{\\pi_{\\theta}(y|x)}{\\pi_{ref}(y|x)})\\\\ \u0026amp;= \\underset{\\pi}{\\min}( \\log \\frac{\\pi_{\\theta}(y|x)}{\\pi_{ref}(y|x)} - r_{\\phi}(x,y)/\\beta)\\\\ \u0026amp;= \\underset{\\pi}{\\min}( \\log \\frac{\\pi_{\\theta}(y|x)}{\\pi_{ref}(y|x) e^{r_{\\phi}(x,y)/\\beta} }) \\end{align*} $$\n^0639d4\nDefine partition function: $Z = \\Sigma_{y}{\\pi_{ref}(y|x) e^{r_{\\theta}(x,y)/\\beta}}$, which relates to the reward of $\\theta$ over $ref$\nWe can get the optimal strategy $\\pi^{\\ast}$ under $r_{\\phi}$(irrelevant of $\\theta$):\n$$ \\pi^{*}(y|x) = \\pi_{ref}(y|x)e^{\\frac{r_{\\phi} (x,y)}{\\beta}} \\frac{1}{Z(x)} $$\n^5ee375\nThen Eq [[#^0639d4]] became:\n$$ \\begin{align*} \\pi \u0026amp;= \\underset{\\pi}{\\min}\\left( \\log \\frac{\\pi_{\\theta}(y|x)}{\\pi_{ref}(y|x) e^{r_{\\phi}(x,y)}{\\beta}}\\right)\\\\ \u0026amp;= \\underset{\\pi}{\\min}\\left( \\log \\frac{\\pi_{\\theta}(y|x)}{\\pi^{\\ast}(y|x) Z(x)}\\right)\\\\ \u0026amp;= \\underset{\\pi}{\\min}\\left( \\log \\frac{\\pi_{\\theta}(y|x)}{\\pi^{\\ast}(y|x)}\\right)\\\\ \u0026amp;= \\underset{\\pi}{\\min}\\left( D_{KL}(\\pi_{\\theta}(y|x) || \\pi^{\\ast}(y|x))\\right) \\end{align*} $$\nApparently, the optimal $\\pi$ is: $\\pi_{\\theta} \\to \\pi^{*}$.\nNoticing that the reward function of E.Q. [[#^5ee375]] can be rewritten(reparameterized) as(where $\\pi_{ref}$ is the human-preference data as ground-truth):\n$$ r_{\\phi} (x,y) = \\beta \\log \\frac{\\pi^{\\ast}(y|x)}{\\pi_{ref}(y|x)} + \\beta \\log Z(x) $$\n[!TIP] the reward function can be represted with best policy trained under it\nBy replacing $r_{\\phi} (x,y)$ in the objective of RLHF as $\\pi^{*}$, we get an objective function without the reward function:\n$$ \\begin{align} \\mathcal{L}_{\\text{DPO}}(\\pi_{\\theta}; \\pi_{ref}) = -{{\\mathbb{E}_{(x, y_{w}, y_{l}) \\sim D}[\\log \\sigma{({\\beta \\frac{\\pi_{\\theta}(y_{w}|x)}{\\pi_{ref}(y_{w}|x)} - \\beta\\frac{\\pi_{\\theta}(y_{l}|x)}{\\pi_{ref}(y_{l}|x)} }})]}} \\end{align} $$ From this equation, we found that: Training the reward model in RLHF is equivalent to training $\\pi_{\\theta}$ with the derived objective function.\nThat is to say, no need of 4 models, we can achieve the same target of RLHF with directly training $\\pi_{\\theta}$.\nMethods RLHF RLHF(Reinforcement learning from human feedback) is a technique that trains a reward model.\nIt has following key concepts:\nReward Model: trained in advance directly from human feedback human feedback: data collected by asking humans to rank instances of the agent\u0026rsquo;s behavior The procedure is given by 3 steps\n1. SFT Pre-train a (target) model: $\\pi^{SFT}$\n2. Reward Modeling Phase Train a reward model: $r_{\\phi}(x,y) = r, r \\in (0, + \\infty)$, where $r$ is the reward of the given input.\nInitialization: Often initialized from Pretrained Models\nData:\n$D$: $Prompt: x \\to (Generation: y, Reward: r)$, generated by human or models Human Feedback: Ranking the outputs of different models under same prompt with $r$ effective ways of ranking: Comparing two/ ELO $(y_{win}, y_{loss})$ : sampled from generation Train the RM with Data The Objective is (negative log-likelihood loss): $$ \\begin{align*} \\mathcal{L}_{R}(r_{\\phi}, D) = -{{\\mathbb{E}_{(x, y_{w}, y_{l}) \\sim D}[\\log{\\sigma({r_{\\phi}(x, y_{w}) - r_{\\phi}(x, y_{l})}})]}} \\end{align*} $$ maximize the gap of rewards between better/worse response\n3. RL Fine-Tuning Phase: $\\pi_{\\theta}(x) = p(y)$ In the past, training LM with RL was considered impossible. One of the proposed feasible plan is PGR(Policy Gradient RL)/PPO(Proximal Policy Optimization) Conclusion ","permalink":"https://mickjagger19.github.io/posts/ai/rl/reinforcement-learning/","summary":"Personal takeaways of RL/RLHF/DPO","title":"Reinforcement Learning"},{"content":"Terminologies Term Meaning Diffusion Models models that can sample from a highly complex probability distribution(e.g. images of cars) Non-equilibrium thermodynamics a branch of thermodynamics that deals with physical systems that are not in thermodynamic equilibrium, where \u0026ldquo;there are no net macroscopic flows of matter nor of energy within a system or between systems\u0026rdquo;. It is often used by diffusion models as a technique to sample from distribution. Diffusion the net movement of anything, generally from a region of higher concentration to a region of lower concentration. Also a technique of Non-equilibrium thermodynamics DDPM model that improves the performance of diffusion models by variational inference DDIM a generalized version of DDPM, with better performance and less diversity and quality Jensen inequality $f(\\sum\\limits a_{i}x_{i}) \\le \\sum\\limits a_{i}f(x_{i})$, where $a \\ge 0, \\sum\\limits a_{i} = 1$\nIn other words, the Expected Value of a convex function $\\ge$ the value of the function at the Expected Input Variational Lower Bound(short for VLB, a.k.a. Evidence Lower BOund, short for ELBO) A easy-to-train lower bound of Log-Likelihood, derived by using a prior $p(z)$ to approximate (implies variational) an intractable posterior $q$. Jacobian matrix A matrix derived from a vector of function of several variables, with all its first-order partial derivatives. Suppose $f: R^{n} \\to R^{m}$:\n$$\nJ = [\\frac{\\partial{f}}{\\partial{x_{1}}}\u0026hellip;\\frac{\\partial{f}}{\\partial{x_{n}}}]\n$$ Notations Notation Meaning $x_{0}$ the data point, where $t$ is the total count of timestamp $x_{t}$ the data after applying $t$ times of forward iteration $\\epsilon_t$ the (standard gaussian) noise $\\epsilon_{\\theta}(x_t,t)$ our model to predict the noise at each timestamp $\\mu_{\\theta}(x_t, t)$ parameterized model to predict $x_{t-1}$ at time $t$ $p(x_{0:T})$ the joint distribution of $x_{0}, x_{1} \u0026hellip; x_{T}$ Introduction This article will introduce the definitions of DDPM and DDIM.\nAs stated earlier, the work of DDIM is based on DDPM.\nDDPM Diffusion Models often involves modeling two processes:\nforward process: noise data($x_{0}$) to data point($x_{t}$) reverse process: data point to noise data, the reversion of forward process Forward Process As a improvement of Diffusion Models, DDPM models the forward process as:\n$$ \\begin{equation} x_{t} = \\alpha_{t} x_{t-1} + \\beta_{t}\\epsilon_{t}, \\epsilon_{t} \\sim \\mathcal{N}(0,1), 0 \\le t \\le T, t \\in \\mathbb{Z} \\end{equation} $$\nwhere $\\alpha, \\beta \u0026gt; 0, \\alpha_{t}^{2}+ \\beta_{t}^{2} = 1$. This can be viewed as:\nthe remains from the previous data: $\\alpha_{t} x_{t-1}$ the destruction by introducing noise $\\epsilon_{t}$ Accordingly, the conditional probability of $x_t$ would be: $$ p(x_{t}| x_{t-1}) = \\mathcal{N}(x_{t};\\alpha_{t}x_{t-1}, \\beta_{t}^{2}I) $$\n[!NOTE]\nAll $\\alpha, \\beta, T$ are constants Apparently, this is a Markovian process Reverse Process By applying the forward process for $T$ times, we have $t$ pairs of $(x_{t-1}, x_{t})$. This is our training data.\nReversing the forward process, the task of the reverse process should be: learn how to get $x_0$ from $x_{t}$, formally $x_0 \\to x_{t}$.\nDDPM splits this process into $t$ steps of $x_t \\to x_{t-1}$.\n[!TIP] The Methodology of DDPM DDPM is a Likelihood-based Model.\nIn the paper, they model each single step as a gaussian transition: $$ p_{\\theta}(x_{t-1}|x_{t}) = \\mathcal{N}(x_{t-1};\\mu_{\\theta}(x_{t}, t), \\Sigma_{\\theta}(x_{t},t)) $$ where:\n$\\mu_{\\theta}(x_{t}, t)$: the mean value $\\Sigma_{\\theta}(x_{t},t)$: the variance predictor (of reverse process). [!NOTE]\nThe noise is not gaussian noise multiplied by a factor, but predicted directly. Not to confuse: * $\\Sigma_{\\theta}(x_{t},t)$: the noise in reverse process. It has been tested positive to the reverse process * $\\epsilon_\\theta(x_{t},t) \\to \\epsilon_{t}$ : the noise predictor (of forward process) Mean Value Predictor: $\\mu_{\\theta}(x_{t}, t)$ In order to model the $\\mu_{\\theta}(x_{t}, t)$, from Bayes\u0026rsquo; Theorem we have: $$ p(x_{t-1}| x_{t},x_0)= \\frac{p(x_t|x_{t-1}) p(x_{t-1} | x_0)}{p(x_{t}|x_{0}) } $$\nThe process of induction would be:\nPredict $x_t$, $x_{t-1}$ from $x_0$ Replace all the variables($x_{0}$) with $x_{t}$ in Equation 4 Predict $x_{0}$ with $x_{t}$ Applying forward process $p(x_{t}|x_{t-1})$ for $t$ times, we can rewrite $x_{t}$ as:\n$$ x_{t} = \\bar \\alpha_{t} x_{0} + \\bar{\\beta_{t}} ^ {2}\\epsilon_{t}, \\bar \\alpha_{t} = \\prod \\alpha_{i}, \\bar \\beta_{t} = \\sqrt{1-\\bar \\alpha_{t}^{2}} $$ And the probability version: $$ p(x_t|x_{0}) = \\mathcal{N}(x_{t}; \\bar \\alpha_{t} x_{0}, \\bar \\beta_{t} ^ {2}I) $$\nNow that we have $x_t$ from $x_0$, update Eq 4 (since $\\mathcal{N}$ can be represented as probabilities, the result is conformed to $\\mathcal{N}$ as well):\n$$ p(x_{t-1}| x_{t},x_{0}) = \\mathcal{N}\\left(x_{t-1}; \\underbrace{\\frac{\\alpha_{t}\\bar \\beta_{t-1}^{2}}{\\bar \\beta_{t}^{2}}x_{t} + \\frac{\\bar \\alpha_{t-1}\\beta_{t}^{2}}{\\bar \\beta_{t}^{2}}x_{0}}_{\\text{$\\tilde \\mu_t(x_{t}, x_{0})$}},\\frac{\\bar \\beta_{t-1}^{2}\\beta_{t}^{2}}{\\bar \\beta_{t}^{2}}I\\right) $$ Let\u0026rsquo;s define the predicted mean value of $x_{t-1}$ as $\\tilde \\mu_t(x_{t}, x_{0}) = \\frac{\\alpha_{t}\\bar \\beta_{t-1}^{2}}{\\bar \\beta_{t}^{2}}x_{t} + \\frac{\\bar \\alpha_{t-1}\\beta_{t}^{2}}{\\bar \\beta_{t}^{2}}x_{0}$.\nNotice the meaning of it: With Bayes\u0026rsquo; Theorem, using $x_{t}$ and $x_{0}$, we can derive the mean value of $x_{t-1}$.\nSo naturally, we can make our $\\mu_{\\theta}(x_{t}, t)$, who have the same estimated output as $\\tilde \\mu_t(x_{t}, x_{0})$, learn the distribution of it: $$ \\mu_{\\theta}(x_{t}, t) = \\tilde \\mu_t(x_{t}, x_{0}) $$\n[!NOTE] Different ways of modeling $\\mu_\\theta$ is also acceptable, it\u0026rsquo;s just that this is a better way (or not)\nHowever, we don\u0026rsquo;t have $x_0$ to pass to $\\tilde \\mu_t(x_{t}, x_{0})$. Luckily, we can predict $x_0$ from rewriting Equation 7: $$ x_{0}= \\frac{x_{t} - \\sqrt{1- \\bar \\alpha_{t}}}{\\sqrt{\\bar \\alpha_{t}}}\\epsilon_{t} $$\n[!TIP] This is actually an embodiment of the predictor–corrector method\nSince we don\u0026rsquo;t have $\\epsilon$ in the reverse process, we can make a neural work to learn it: $\\epsilon_\\theta(x_t,t) \\to \\epsilon_t$ : $$ x_{0}= \\frac{x_{t} - \\sqrt{1- \\bar \\alpha_{t}}}{\\sqrt{\\bar \\alpha_{t}}}\\epsilon_{\\theta}(x_{t}, t) $$\nUpdate the Eq 10: $$ \\mu_{\\theta}(x_{t}, t) = \\tilde \\mu_t(x_{t}, x_{0}) = \\tilde \\mu_t\\left(x_{t}, \\frac{x_{t} - \\sqrt{1- \\bar \\alpha_{t}}}{\\sqrt{\\bar \\alpha_{t}}}\\epsilon_{\\theta}(x_{t}, t)\\right)= \\frac{1}{\\alpha_{t}}\\left(x_{t} - \\frac{\\beta_{t}^2}{\\bar\\beta_{t}}\\epsilon_{\\theta}(x_{t},y, t)\\right) $$\nReverse Noise Predictor: $\\Sigma_{\\theta}(x_{t},t)$ It still remains to design $\\Sigma_{\\theta}(x_{t},t)$, since it encourages diversity.\nThe DDPM paper suggested not learning it, since it:\nresulted in unstable training and poorer sample quality\nBy fixing it at some value $\\Sigma_{\\theta}(x_{t},t) = \\sigma_{t}^{2}I$ , where either $\\sigma_{t}^{2} = \\beta_{t}$ or $\\tilde{\\beta_t}$ yielded similar performance.\nTraining \u0026amp; Defining Loss Conclusively, we have only defined one trainable model: $\\epsilon_{\\theta}(x_t, t)$\nTo reconstruct $x_{0}$ The training target can be MLE, the objective function being log-likelihood of reconstructing $x_{0}$:\n$$ \\begin{align*} \\ln p(x_{0}) \u0026= \\int{\\ln p(x_{0:T})dx_{1:T}} \u0026 \\text{marginalization of marginal distribution}\\\\\\\\ \u0026= \\ln \\int{p(x_{0:T})dx_{1:T}}\\\\\\\\\\\\ \u0026= \\ln \\mathbb{E}_{q(x_{1:T}|x_{0})}[\\int{\\frac{p(x_{0:T})}{q(x_{1:T}|x_{0})}}]\\\\\\\\ \u0026\\ge \\mathbb{E}_{q(x_{1:T}|x_{0})}\\left[\\ln \\frac{p(x_{0:T})}{q(x_{1:T}|x_{0})}\\right] \u0026 \\text{Jensen Inequality of $\\log$}\\\\\\\\ \u0026= \\underbrace{\\mathbb{E}_{q(x_{1}|x_{0})}\\left[\\ln p_{\\theta}({x_{0}|x_{1}})\\right]}_{\\text{reconstruction term}} - \\sum_{t = 2}^{T}\\mathbb{E}_{q(x_{t}|x_{0})}\\left[D_{KL}(q(x_{t-1}|x_{t},x_{0})||p_{\\theta}(x_{t-1}|x_{t}))\\right]\\\\\\\\ \u0026= \\sum\\limits_{t=1}^{T} \\gamma \\mathbb{E}_{q(x_{t}|x_{0})}[||\\epsilon_{t} - \\epsilon_{\\theta}(x_{t}, t) || ^{2}] \u0026 \\text{$\\gamma$ being some constants} \\end{align*} $$ To optimize the pixels We design the loss function of $\\theta$ as the Euclidean distance of the true and predicted mean of $x_{t-1}$: $$ \\begin{align*} \\ell \u0026amp;= ||x_{t-1} - \\hat x_{t-1}|| ^ 2 \\newline \u0026amp;= ||x_{t-1} - \\mu_\\theta(x_{t},t)|| ^ 2 \\newline \u0026amp;=|| (\\frac{1}{\\alpha_{t}}(x_{t} - \\beta_{t}\\epsilon_{t}) ) ^ {2} - \\frac{1}{\\alpha_{t}}(x_{t} - \\beta_{t}\\epsilon_{\\theta}(x_{t}, t)) ^ {2}||\\newline \u0026amp;= \\frac{\\beta_{t}^{2}}{\\alpha_{t}^{2}} ||\\epsilon_{t} - \\epsilon_{\\theta}(x_{t}, t) || ^2 \\end{align*} $$\nDDIM While the original DDPM is capable to generate satisfying images, it is known for poor performance: since the denoising(reverse) diffusion process usually take $T \\sim 1000$ times of noise-prediction.\nDDIM is proposed to boost the reverse process as Non-Markovian Process, by directly taking any model trained on DDPM and sampling only $T_{ddim}, T_{ddim} \\le T$ timestamps, with some timestamps skipped. As a side-effect, the quality is compromised a little.\nReverse Process It still takes the same approach as DDPM: predict $x_0$ from $x_t$ first.\nFrom Eq 4, we can see that the sampling/training do involves $x_t$, but doesn\u0026rsquo;t actually involves $p(x_{t-1}|x_{t})$ (which is defined in our reverse model). Instead, it defines:\n$$ q_\\sigma(x_{t-1}|x_{t}, x_0) = \\mathcal{N}(x_{t-1};\\sqrt{\\bar \\alpha_{t-1}}x_0 + \\sqrt{1 - \\bar \\alpha_{t-1} - \\sigma_t^2}\\frac{x_t - \\sqrt{\\bar \\alpha_t}x_0}{\\sqrt{1 - \\bar \\alpha_t}}, \\sigma_t^2I) $$\nHence, the relation between $x_{t-1}$ and $x_t$ is:\n$$ x_{t-1} = \\sqrt{\\alpha_{t-1}} \\underbrace{\\left( \\frac{x_t - \\sqrt{1 - \\alpha_{t}}\\epsilon_{\\theta}(x_{t},t)} {\\sqrt{\\bar \\alpha_{t}}} \\right)}_{\\text{predicted $x_0$}} + \\underbrace{\\sqrt{1 - \\bar \\alpha_{t-1} - \\sigma_{t}^{2}\\epsilon_{t}(x_{t},t)}}_{\\text{predicted noise}} + \\underbrace{\\sigma_{t} \\epsilon_{t}}_{\\text{random noise}} $$ where: $$ \\sigma_t = \\eta \\sqrt{(\\frac{1 - \\bar \\alpha_t}{1 - \\bar \\alpha_{t-1}}) \\left(1 - \\frac{\\bar \\alpha_t}{\\bar \\alpha_{t-1}}\\right)} $$ where $\\eta \\in (0,1)$ is a constant, indicating the level of random noise:\n$\\eta = 1$: The random noise is maximized, which is DDPM. $\\eta = 0$: The random noise is totally removed, making it a deterministic process/Implicit model, which is DDIM. It relies entirely on the predicted noise, while sacrificing some diversity with lowering random noise level. As for the timestamps chosen, they are determined empirically.\nTip\nIn fact, $\\eta$ represents the degree of moving some of the noise from predicted noise $\\epsilon_t$ to sampled noise $\\epsilon$: the bigger the $\\eta$, the less deterministic, the larger random noise will be introduced to the reverse process.\nShort Summary Conclusively, both models apply the same forward process, and have the same target: $x_{t} \\to x_{0}$, though they have differences in the reverse process:\nDDPM maximize the random noise, and in order to mitigate the negative effects it has, takes more timestamps in the reverse process DDIM boost the performance by only selecting some of the timestamps, and reduce the random noise level Conditioned Generation While being able to generate high quality images with reasonable speed with the models mentioned above, it is a common feature to generated conditioned output.\nGiven condition $y$, our goal is to derive $p(x_{t-1}|x_{t},y)$\nClassifier Guided Diffusion Using bayes\u0026rsquo; rule, we have: $$ p(x_{t-1}|x_{t},y) = \\frac{p(x_{t-1}|x_{t})p(y|x_{t-1},x_{t})}{p(y|x_{t})} $$\nUsing the notations in Reverse Process: $$ p(x_{t-1}|x_{t},y) \\propto \\exp(-||x_{t-1}-\\mu(x_{t})-\\Sigma_{t}^{2}\\underbrace{\\nabla_{x_{t}}\\log p(y|x_{t})}{\\text{classifier}}||^{2}/2\\Sigma{t}^{2}) $$\nSo $\\mu_{\\theta}(x_{t}, t,y) = \\mu(x_{t})+\\Sigma_{t}^{2}\\nabla_{x_{t}}\\log p(y|x_{t})), \\Sigma_{t} = \\sigma_{t}$\n[!NOTE]\nThe gradient of the prob is easy to get with autograd, if the classifier can output the prob The classifier guides the model only when inferencing Classifier-Free Diffusion To infer without a classifier, we need to blend the condition $y$ into training process.\nBy directly modeling the conditioned reverse process as $p(x_{t-1}|x_{t},y) = \\mathcal{N}(x_{t-1};\\mu(x_{t},y), \\sigma_{t}^{2}I)$, following the modeling of Eq. 11, we have: $$ \\mu(x_{t}, y) = \\frac{1}{\\alpha_{t}}\\left(x_{t} - \\frac{\\beta_{t}^2}{\\bar\\beta_{t}}\\epsilon_{\\theta}(x_{t},y, t)\\right) $$\nThe $\\epsilon_{\\theta}(x_{t},y, t)$ can be trained to predict the noise under condition.\n[!WARNING] The conditioned noise predictor depends on $y$, so retraining is required if the $y$ is changed\nScore-based generative models Notation Meaning Ancestral Sampling A sample method, auto-regressive Score Distillation Sampling A sampling method(sampler) to generate samples from a diffusion model by optimizing a loss function. Basically, it utilizes(distills) the score function of a teacher diffusion model, to train a larger model, with the final result as a sample (as $t \\to 0$). score function The gradient of the log-likelihood function $U(x) = -\\log q(x)$ An energy function. The lower the likelihood, the higher the energy $\\mu_{\\theta}(x_t, t)$ parameterized model to predict $x_{t-1}$ at time $t$ $p(x_{0:T})$ the joint distribution of $x_{0}, x_{1} \u0026hellip; x_{T}$ Langevin dynamic A Markov chain Monte Carlo(MCMC) method for obtraining random samples Fisher Divergence Most often, we don\u0026rsquo;t care about the probability $q(x)$ of a certain input $x$, but how it changes through time: therefore, we can utilize score function(gradient, changes) $s(x):=\\nabla_{x}\\log q(x)$\n[!TIP] It is also an advantage of modeling the score: don\u0026rsquo;t have to make sure probability sum up to 1\nWith $s(x)$ allowing us to sample from $q(x)$ using thermodynamics, our goals changes to: model $q(x)$\n$$ dx_{t} = \\nabla \\log q(x) d_{t} + d{W_{t}} $$\nLoss We learn a model $s_{\\theta}$ to match(approximate) the score $\\nabla \\log q$:\n$$ s_{\\theta} \\approx \\nabla \\log q(x) $$ \u0026ndash; This is score matching.\nTypically, score matching is formalized as minimizing Fisher divergence function . By expanding the integral, and performing an integration by parts, we have our loss function: $$ \\mathcal{L} = \\mathbb{E}{q}[||s{\\theta}(x) - \\nabla \\log q(x)||^{2}] $$ However, it\u0026rsquo;s infeasible since it requires access to unknown score $\\nabla \\log q(x)$.\nFortunately, we have score matching techniques(e.g. Hyvärinen scoring rule) which minimize the Fisher divergence without knowledge of the gorund-truth score: $$ \\mathcal{L} = \\mathbb{E}{q}\\left[\\nabla{x} s_{\\theta}(x)+ \\frac{1}{2}||s_{\\theta}(x)||_{2}^{2}\\right] $$\nSince $s_{\\theta}$ is modeled by ourself, its output and gradients can be easily calculated. We use Monte-Carlo methods with gradient descent to optimize it.\nSample / Inference But how do we generate a sample.\nOnce we have trained a score-based model $s_{\\theta}(x)$, we can use an iterative procedure called Langevin dynamics to draw samples from it: $$ x_{i + 1} \\leftarrow x_{i} + \\epsilon \\nabla_{x} \\log p(x) + \\sqrt{2\\epsilon} z_{i}, z_{i} \\sim \\mathcal{N}(0, I) $$ Notice some white noise is injected, to avoid all samples collapse into some limited local optimas.\nThis seems decent, but in fact: in low-density regions, the estimated scores are inaccurate.\nIt\u0026rsquo;s natural to augment the low-density regions by perturbing our datapoint: injecting $\\mathcal{N}$. It can solve the problem in low-density, however since the training data is perturbed, the generated samples are too.\nMultiple (decreasing) noise levels $\\sigma$ are applied as an input to score funcion $s$, with the output of previous model $i$ as the input of the next model $i+1$. The whole process resembles an Anneald Langevn Dynamics\nSDE Notation Meaning SDE A DE in which one or more of the terms is a stohastic process $\\mathcal{U}(T_{a},T_{b})$ Uniform distribution over the time interval $[T_{a}, T_{b}]$ In DDPM, we define $t$ as discrete timestamps, however it\u0026rsquo;s more natural to model it as continuous time. Forward Process With this premise, we model the forward process with Stochastic DE(Differential equation), but not funtion on timestamps: $$ dx = f_{t}(x) + g_{t}dw $$\nReverse Process Similarly, we want to model $p(x_{t}|x_{t + \\Delta{t}})$: $$ \\begin{align} p(x_{t}|x_{t + \\Delta{t}}) \u0026amp;= \\frac{p(x_{t + \\Delta_{t}} | x_{t})p(x_{t})}{p(x_{t+ \\Delta{t}})} \\\\ \u0026amp;= p(x_{t + \\Delta{t}} | x_{t})\\exp(\\log p(x_{t}) - \\log p(x_{t+\\Delta{t}})) \\\\ \u0026amp;\\propto \\left(-\\frac{||x_{t + \\Delta_{t}} - x_{t} - f_{t}(x_{t})\\Delta{t}||^{2}}{2g_{t}^{2}\\Delta t}+ \\log p(x_{t}) - \\log p(x_{t+\\Delta{t}})\\right) \\end{align} $$\nIn order to calculate the unknown diff, we apply Taylor expansion: $$ \\log p(x_{t+\\Delta{t}}) \\approx \\log p(x_{t}) + (x_{t+\\Delta t} - x_{t}) \\cdot \\nabla_{x_{t}}\\log p(x_{t}) + \\underbrace{\\Delta t \\frac{\\partial \\log p(x_{t})}{\\partial t}}{\\text{$x{t}$\u0026rsquo;s deritive of $t$}} $$\nUpdate Equation 26-3 with it, we have: $$ p(x_{t}|x_{t + \\Delta{t}}) \\sim \\mathcal{N}(f_{t+\\Delta t}(x_{t + \\Delta t}) - g_{t + \\Delta t}^{2}\\nabla_{x_{t + \\Delta t}} \\log p(x_{t + \\Delta t})\\Delta t; g_{t + \\Delta t}^{2}\\Delta t I) $$\nand the SDE of reverse process: $$ dx = [f_{t}(x) - g_{t}^{2}\\nabla_{x}\\log p_{t}(x)]dt + g_{t}dw $$\nTraining $$ \\mathcal{L} = \\mathbb{E}{t \\in \\mathcal{U}(0, T)}\\mathbb{E}{p_{t}(x)}[\\lambda(t)||\\nabla_{x}\\log p_{t}(x) - s_{\\theta}(x,t)||^{2}_{2}] $$ where:\n$\\lambda : \\mathbb{R} \\to \\mathbb{R}_{\u0026gt;0}$ is a positive weighting function Probability flow ODE Notation Meaning PF(Probability flow) ODE The ODE of an SDE Despite capable of generating high-quality samples, samplers based on Langevin MCMC and SDE solvers do not provide a way to compute the exact log-likelihood of score-based generative models.\nIt has been proved that, it is possible to convert any SDE into an ODE(ordinary differential equation) without changing its marginal distributions $p_{t}(x)$\nForward Process With a sequence of complex calculations(including F-P function \u0026amp; Dirac function), we have:\n$$ dx = [f(x,t) - \\frac{1}{2}(g^{2}(t)-\\sigma_{t}^{2})\\nabla_{x}\\log p_{t}(x)]dt $$\nReverse Process The reverse process of PF-ODE is given by:\n$$ dx = [f(x,t) - \\frac{1}{2}g^{2}(t)\\nabla_{x}\\log p_{t}(x)]dt $$\n[!TIP] When $\\nabla_{x}\\log p_{t}(x)$ replaces $s_{\\theta}(x,t)$, PF ODE becomes a special case of a neural ODE\nSamplers Euclidean $$ \\begin{equation}\\left.\\frac{d\\boldsymbol{x}t}{dt}\\right|{t=t_{n+1}}\\approx \\frac{\\boldsymbol{x}{t{n+1}} - \\boldsymbol{x}{t_n}}{t{n+1} - t_n}\\end{equation} $$ 一阶近似\nHeun solver DPM solver AMED solver ","permalink":"https://mickjagger19.github.io/posts/ai/models/denoising-diffusion-models/","summary":"Personal takeaways of DDIM/DDPM","title":"Denoising Diffusion Models"},{"content":"Terminology Notations Mean $X \\sim p_{r}$ the input data $z$ the encoded latent $\\theta$ the parameterized model $\\phi$ the encoder $p_{\\theta}(x)$ the likelihood of the data-reconstruction $p(z)$ the distribution of latent variable $z$ as a prior, often $\\mathcal{N}(0,1)$ $q_{\\phi}(z|x)$ variational distribution $q_{\\phi}(z|x)$ variational distribution MDL(Minimum Description Length) Self-Information $I$ the amount of information, interpreted as the level of \u0026ldquo;surprise\u0026rdquo;\n$$I(\\mathcal{w}{n}) = f(P(\\mathcal{w}{n})) = -\\log(P(\\mathcal{w}_{n})) \\ge 0$$ Entropy $H(X)$ the average amount of information in a message. A measure of uncertainty. $$H(X) = E[I(X)] = E[-\\ln(P(X))]$$\nBackground AutoEncoder is proposed to compress data and reduct dimensionality as a generalization of PCA, and largely used in signal processing, until someone found new samples can be generated by adding noise to latents and decoded by decoder.\nHowever, the ability of AutoEncoder to generate new samples by the distribution of the latents $z$, this is why \u0026amp; when Variational AutoEncoder is developed.\n[!TIP] AE is an approach of MDL\nRequirements In order to be able to generate new samples using decoder, we will be happy if $z \\sim \\mathcal{N}(0, 1)$ Modeling We apply Maximum Likelihood Estimation here.\nLog Likelihood is defined as: $$ Likelihood = \\log P_{\\theta}(X) $$\nwhich represents the ability of the model to reconstruct the input data.\nHence, from the definition of the loss function:\n$$ \\mathcal{L}(\\theta) = - \\mathbb E_{x \\sim data}[\\log p_{\\theta}(x)] $$\nNormally, the $x\\sim data$ is neglected.\nOur goal is to minimize the loss function, in the mean time force encoder to encode $X$ as $z \\sim \\mathcal{N}(\\mu, \\sigma^{2}I)$\nImplicit Model We define $z$ as an implicit variable, making our model an implicit model.\nRewrite the log-likelihood: $$ p_{\\theta}(x) = \\int{p_{\\theta}}(x|z)p_{\\theta }(z)dz $$ where $\\theta$ is the parameter of the implicit model (encoder and decoder).\nHowever there\u0026rsquo;s a common problem for implicit models: the integration relies on the exhaustion on implicit variable $z$.\nIn our case, as $z \\sim \\mathcal{N}(\\mu, \\sigma^{2}I)$, it is deem impossible.\nMC Monte-Carlo is a method to approximate an intractable equation(integration) by sampling a lot of data ($p_{\\theta}(x | z)$): $$ \\begin{align*} p_{\\theta}(x) \u0026amp;= \\int{p_{\\theta}}(x|z)p_{\\theta }(z)dz\\\\ \u0026amp;\\approx \\frac{1}{m} \\sum\\limits_{j =1}^{m} p_{\\theta}(x | z_{j}) \\end{align*} $$ But that does not enforce $z \\sim \\mathcal{N}(\\mu, \\sigma^{2}I)$.\nVariational Bayes Deriving ELBO Considering the log-likelihood can be rewritten in the following process:\n$$ \\begin{align*} \\log p_{\\theta}(x) \u0026amp;= \\log p_{\\theta}(x) \\int_{z}p_{\\phi}(z|x)dz \u0026amp;\\text{Normalization} \\\\ \u0026amp;= \\int_{z}p_{\\theta}(z|x)\\log p_{\\theta}(x)dz \\\\ \u0026amp;= \\int_{z}p_{\\theta}(z|x) \\log \\frac{p_{\\theta}(x,z)}{p(z|x)} dz \u0026amp;\\text{Bayes\u0026rsquo; Theorem} \\\\ \u0026amp;= \\int_{z}(p_{\\theta}(z|x)\\log p_{\\theta}(x,z) - p_{\\theta}(z|x)\\log p(z|x))dz \\\\ \u0026amp;= \\log p_{\\theta}(x,z) - \\log p_{\\theta}(z|x) \\end{align*} $$\nSince the posterior $\\log p_{\\theta}(z|x)$ is intractable (only involves integration on latent variable $z$, see Bayes\u0026rsquo; Theorem), a new distribution(which is easy to learn) $q_{\\phi}(z|x)$ is used to approximate it, where $\\phi$ is the encoder.\nLet\u0026rsquo;s continue by replacing:\n$$ \\begin{align*} \\underbrace{\\log p(x)}_{\\text{evidence}} \u0026= \\log p_\\theta(x,z) - \\log q_{\\phi}(z|x) \\newline \u0026= \\int_{z} q_{\\phi}(z|x)\\log\\frac{p_{\\theta}(x,z)}{q_{\\phi}(z|x)}dz \\newline \u0026= \\int_{z}q_{\\phi}(z|x)\\log(\\frac{p_{\\theta}(x,z)}{q_{\\phi}(z|x)} \\cdot \\frac{q_{\\phi}(z|x)}{p(z|x)})dz \\newline \u0026= \\int_{z}q_{\\phi}(z|x)\\log(\\frac{p_{\\theta}(x,z)}{q_{\\phi}(z|x)})dz + \\int_{z}q_{\\phi}(z|x)\\log(\\frac{q_{\\phi}(z|x)}{p(z|x)})dz \\newline \u0026= \\mathcal L(\\theta,\\phi; x) + D_{KL}(q_{\\phi}, p_{\\theta}) \\newline \u0026\\ge \\underbrace{\\mathcal L(\\theta,\\phi; x)}_{\\text{ ELBO }} \u0026 \\text{$D_{KL}\\ge 0$} \\end{align*} $$ $\\mathcal L(\\theta, \\phi; x) = \\mathbb{E}_{z \\sim q(.|x)}{\\log \\frac{p_{\\theta}(x,z)}{q_{\\phi}(z|x)}}$ is ELBO(Evidence Lower Bound), as it is the lower bound of evidence $\\mathcal{L}(\\theta)$, omitting the KL term. Maximizing ELBO is directly:\nmaximizing log-likelihood minimizing KL-Divergence of posterior $p_{\\theta}$ and variational distribution $q_{\\phi}$ Maximizing ELBO And we can break it down further: $$ \\begin{align*} \\underbrace{\\mathcal L(\\theta, \\phi; x)}_{\\text{ELBO}} \u0026= \\int_{z}q_{\\phi}(z|x)\\log(\\frac{p_{\\theta}(x,z)}{q_{\\phi}(z|x)})dz = \\mathcal{H}[q_{\\phi}(z|x)] + \\mathbb{E}_{z}[p_{\\theta}(x,z)] \\\\\\\\ \u0026= \\int_{z}q_{\\phi}(z|x)\\log(\\frac{p(z) * p_{\\theta}(x|z) }{q_{\\phi}(z|x)})dz \u0026 \\text{Bayes' Theorem}\\\\\\\\ \u0026= \\int_{z}q_{\\phi}(z|x)\\log\\frac{p(z) }{q_{\\phi}(z|x)}dz + \\int_{z}q_{\\phi}(z|x)\\log p_{\\theta}(x|z)dz\\\\\\\\ \u0026= \\underbrace{-D_{KL}(q_{\\phi}(z|x), p(z))}_{\\text{$\\mathcal L_{reg}$}} + \\underbrace{\\mathbb E_{q_{\\phi}(z|x)}[\\log p_{\\theta}(x|z)]}_{\\text{$\\mathcal L_{reconstruct}$}}\\\\\\\\ \\end{align*} $$ [!Note] $\\int_{z}p(z)*f(z)dz = \\mathbb E_{z \\sim p(.)}[f(z)]$, which is the expectation of p with z sampled from $p(z)$\nThis is ELBO:\n$\\mathcal L_{reg}$: the KL-divergence of variational distribution and prior distribution $\\mathcal L_{reconstruct}$: the Expectation of log reconstruct-likelihood under variational distribution Since $\\mathcal{L}(\\theta) = -\\log p(x) \\le - \\text{ELBO}$, by maximizing ELBO, we can indirectly minimize $L(\\theta)$.\nHence, we define $\\mathcal{L} = -\\text{ELBO}$.\nTraining $$ \\begin{align*} \\text{ELBO} \u0026amp;= \\underbrace{-D_{KL}(q_{\\phi}(z|x), p(z))}{\\text{$\\mathcal L{reg}$}} + \\underbrace{\\mathbb E_{q_{\\phi}(z|x)}[\\log p_{\\theta}(x|z)]}{\\text{$\\mathcal L{reconstruct}$}}\\\\ \u0026amp;= \\underbrace{-D_{KL}(q_{\\phi}(z|x), p(z))}{\\text{$\\mathcal L{reg}$}} + MSE(x, \\hat x) \\end{align*} $$\nAs $z$ is sampled from $\\sim q_{\\phi}(z|x)$, which is a variational distribution, the gradient of ELBO will not be able to propagate back to encoder $\\phi$ (in-differentiable, chain rule).\nThus, re-parameterization is applied: $z = \\mu + \\epsilon \\times \\sigma, \\hat z \\sim \\mathcal{N}(0, I)$, where $\\phi(X) = (\\mu, \\epsilon)$. This way, the gradient is passed back to $\\phi$, by representing $z$ with the output of $\\phi$, where $z$ participates in the loss-calculation\nProblems Blurry output the prior: $p(z) \\sim \\mathcal{N}(0, I)$ MSE is used to measure $L_{reconstruct}$ DAE: corrupt X，降低图片的冗余度（图片的冗余性一般都很高）\nDall E 两阶段：\nclip 构造对比学习的正负样本对 文本 -\u0026gt; clip encoder -\u0026gt; text embedding -\u0026gt; (diffusion) prior -\u0026gt; image embedding -\u0026gt; diffusion model decoder -\u0026gt; image transformer encoder 本质上是自回归模型，可以基于自注意力和输入，自回归地生成同类型的内容\n![[Pasted image 20230618153050.png]]\n![[Pasted image 20230618154911.png]]\n","permalink":"https://mickjagger19.github.io/posts/ai/models/vae/","summary":"Takeaways from the maths of VAE","title":"VAE"},{"content":"Regularization For most NNs today, they are trained to minimize a designed loss function, which quantizes the ability of the model.\nThough being intuitive and reasonable, after a model is trained for a long time, a phenomenon called overfitting occurs. The model performed so well in the training set, that it behaves badly with more generalized data - whose distribution may differ from the training set.\nThere are several tricks we can adopt in training, to mitigate overfitting.\nThey are often known as regularization\nWeight Penalty The measurement of complexity:\nNumber of parameter Absolute value of parameters Dropout Dropout works in the training phase:\nIn each batch, randomly disable some neurons with ratio k. The output of these deleted neurons became 0. Multiply the output with k: $o = o * k$ to rectify The reason behind dropout:\nAverage It can be interpreted as a special case of ensemble , taking the average of output of expertises(the active neurons)\nReduce Co-relation between neurons Evolution theory Consider the disable action as the environment mutation, the model adapts to this mutation(new environment) by breeding new breeds(the different combination of active neurons)\nVariant: vanilla dropout Normalization Notation Meaning $B$ Batch size $S$ Sequence length $$ Batch Normalization Normalization across the $B$ dimension:\nLayer Normalization Group Normalization tan h: 当 |x| 比较小 时，接近线性网络\n手段：\n向损失函数中引入正则项，将模型参数的范数作为惩罚 Dropout: 训练时，随机屏蔽（置0）并对结果进行 scale 原理：Don\u0026rsquo;t rely on any one feature(neuron), spread out weights 随机淘汰网络中的一些单元，因此训练时，每层不会对任意一个神经元施加 太多权重，这种分散权重的方式防止了过拟合 迫使同层节点对输出承担或多或少的责任，增强模型的泛化性，因为它不会太依赖某些局部的特征 Data augmentation 增加数据集的泛化性 Early stopping 在权重 overfit 之前结束，但 error 较高 Normalize 对于随机输入数据，会导致成本函数对每个维度的scale 不一致(elongated)，导致参数调整出现很多 oscillate\nz-score min-max ![[Attachments/AI/Models/Techniques of Training NNs/IMG-20241229130940785.png]] softmax: normalized exponential function Batch Norm 对每一批训练数据进行归一化，\neffect:\nreduce shift on train data 增加模型的鲁棒性，提升训练速度 在 z/a 上作用\nwhy work?\nlearning on shifting input distribution: 偏移在神经网络中会产生累积，导致后面的层的输入不稳定 Layer Norm 不是全量数据集，因为容易过拟合\nBias Inductive bias\n","permalink":"https://mickjagger19.github.io/posts/ai/models/techniques-of-training-nns/","summary":"Describe and compare some common tricks of training NNs","title":"Techniques of Training NNs"},{"content":" Desafinado One Note Samba Só Danço Samba Doralice O Pato Chega De Saudade (No More Blues) Aguas De Março Menina Flor Corcovado ","permalink":"https://mickjagger19.github.io/posts/music/bossa-nova-songs-progression/","summary":"Chord progression of some well-known bossa-nova songs","title":"Bossa Nova Songs Progression"},{"content":" Single 1. Something 2. Here Comes the Sun 3. While My Guitar Gently Weeps 4. All Those Years Ago 5. Wah-Wah Album Beatles records are excluded\n1. All Things Must Pass 2. Brainwashed 3. George Harrison 4. Living in the Material World Guitar Solo 1. Dark Sweet Lady 2. Something 3. The Light That Has Lighted the World 4. Give me Love 5. Any Road 6. Cheer Down 7. Stuck Inside a Cloud 8. Crippled Inside 9. How Do You Sleep? 10. Isn\u0026rsquo;t it a Pity 11. Rising Sun ","permalink":"https://mickjagger19.github.io/posts/music/music-of-george-harrison/","summary":"personal rankings of George Harrison\u0026rsquo;s Singles/Albums/Guitar Solos","title":"Music of George Harrison"},{"content":"RAM SRAM: Static RAM 低延迟 容量小 昂贵的 RAM HBM: High BandWidth 高访存速度 容量大 ","permalink":"https://mickjagger19.github.io/posts/ai/hardware/hardware/","summary":"\u003ch2 id=\"ram\"\u003eRAM\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSRAM: Static RAM\n\u003cul\u003e\n\u003cli\u003e低延迟 容量小 昂贵的 RAM\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eHBM: High BandWidth\n\u003cul\u003e\n\u003cli\u003e高访存速度 容量大\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":""},{"content":"\r\u003c!DOCTYPE HTML\u003e\rShader - Shadertoy BETA\rShadertoy\rWelcome Mick\r|\rBrowse\rNew\rLogout\rNo WebGL available :(\r0.00\r00.0 fps\r0 x 0\rViews: 0, Tags:\rCreated by in public + api\rpublic\runlisted\rprivate\rShader Inputs\runiform vec3 iResolution; // viewport resolution (in pixels)\nuniform float iTime; // shader playback time (in seconds)\nuniform float iTimeDelta; // render time (in seconds)\nuniform float iFrameRate; // shader frame rate\nuniform int iFrame; // shader playback frame\nuniform float iChannelTime[4]; // channel playback time (in seconds)\nuniform vec3 iChannelResolution[4]; // channel resolution (in pixels)\nuniform vec4 iMouse; // mouse pixel coords. xy: current (if MLB down), zw: click\nuniform samplerXX iChannel0..3; // input channel. XX = 2D/Cube\nuniform vec4 iDate; // (year, month, day, time in seconds)\nuniform float iSampleRate; // sound sample rate (i.e., 44100)\rCompiled in 0.0/0.0 secs\r0 chars\rXS\rS\rM\rL\rXL\rXXL\rFilternearestlinearmipmapWrapclamprepeatVFlipiChannel0 FilternearestlinearmipmapWrapclamprepeatVFlipiChannel1 FilternearestlinearmipmapWrapclamprepeatVFlipiChannel2 FilternearestlinearmipmapWrapclamprepeatVFlipiChannel3 Comments (0)\nCommunity Forums\rOfficial Events\rIn Facebook (english)\rIn Facebook (korean)\rIn Discord (direct link)\rFeedback and Support\rFacebook\rTwitter\rPatreon\rRoadmap\rEmail\rShadertoy\rStore\rDocumentation\rTerms \u0026 Privacy\rAbout\rApps and Plugins\rOfficial iPhone App by Reinder\rScreensaver by Kosro\rShadertoy plugin by Patu\rTutorials\rShader coding intro by iq\rShadertoy Unofficial by FabriceNeyret2\rWe use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. For more information, please review our Terms \u0026 Privacy.\rAccept\rSelect input for iChannel\rMisc\rTextures\rCubemaps\rVolumes\rVideos\rMusic\rby by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by by GLSL Help\rThis help only covers the parts of GLSL ES that are relevant for Shadertoy. For the complete specification please have a look at GLSL ES specification\nLanguage:\rVersion: WebGL 2.0\rArithmetic: ( ) + - ! * / %\rLogical/Relatonal: ~ \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= == != \u0026amp;\u0026amp; ||\rBit Operators: \u0026amp; ^ | \u0026lt;\u0026lt; \u0026gt;\u0026gt;\rComments: // /* */\rTypes: void bool int uint float vec2 vec3 vec4 bvec2 bvec3 bvec4 ivec2 ivec3 ivec4 uvec2 uvec3 uvec4 mat2 mat3 mat4 mat?x? sampler2D, sampler3D, samplerCube\rFormat: float a = 1.0; int b = 1; uint i = 1U; int i = 0x1;\rFunction Parameter Qualifiers: [none], in, out, inout\rGlobal Variable Qualifiers: const\rVector Components: .xyzw .rgba .stpq\rFlow Control: if else for return break continue switch/case\rOutput: vec4 fragColor\rInput: vec2 fragCoord\rPreprocessor: #define #undef #if #ifdef #ifndef #else #elif #endif #error #pragma #line\rBuilt-in Functions:\rftype radians (ftype degrees)\rftype degrees (ftype radians)\rftype sin (ftype angle)\rftype cos (ftype angle)\rftype tan (ftype angle)\rftype asin (ftype x)\rftype acos (ftype x)\rftype atan (ftype y, ftype x)\rftype atan (ftype y_over_x)\rftype sinh (ftype x)\rftype cosh (ftype x)\rftype tanh (ftype x)\rftype asinh (ftype x)\rftype acosh (ftype x)\rftype atanh f(type x)\rftype pow (ftype x, ftype y)\rftype exp (ftype x)\rftype log (ftype x)\rftype exp2 (ftype x)\rftype log2 (ftype x)\rftype sqrt (ftype x)\rftype inversesqrt (ftype x)\rtype abs (type x)\rtype sign (type x)\rftype floor (ftype x)\rftype ceil (ftype x)\rftype trunc (type x)\rftype fract (ftype x)\rftype mod (ftype x, ftype y)\rftype modf (ftype x, out ftype i)\rtype min (type x, type y)\rtype max (type x, type y)\rtype clamp (type x, type minV, type maxV)\rftype mix (ftype x, ftype y, ftype a)\rtype step (type edge, type x)\rftype smoothstep (ftype a, ftype b, ftype x)\rfloat length (vec x)\rfloat distance (vec p0, vec p1)\rfloat dot (vec x, vec y)\rvec3 cross (vec3 x, vec3 y)\rvec normalize (vec x)\rvec faceforward (vec N, vec I, vec Nref)\rvec reflect (vec I, vec N)\rvec refract (vec I, vec N, float eta)\rfloat determinant(mat? m)\rmat?x? outerProduct(vec c, vec r)\rmat?x? matrixCompMult (mat?x? x, mat?x? y)\rmat? inverse (mat? inverse)\rmat?x? transpose (mat?x? inverse)\rvec4 texture( sampler , vec coord [, float bias])\rvec4 textureLod( sampler, vec coord, float lod)\rvec4 textureLodOffset( sampler sampler, vec coord, float lod, ivec offset)\rvec4 textureGrad( sampler , vec coord, vec2 dPdx, vec2 dPdy)\rvec4 textureGradOffset sampler , vec coord, vec dPdx, vec dPdy, vec offset)\rvec4 textureProj( sampler , vec coord [, float bias])\rvec4 textureProjLod( sampler , vec coord, float lod)\rvec4 textureProjLodOffset( sampler , vec coord, float lod, vec? offset)\rvec4 textureProjGrad( sampler , vec coord, vec2 dPdx, vec2 dPdy)\rvec4 texelFetch( sampler , ivec coord, int lod)\rvec4 texelFetchOffset( sampler, ivec coord, int lod, ivec offset )\rivec textureSize( sampler , int lod)\rftype dFdx (ftype x)\rftype dFdy (ftype x)\rftype fwidth (ftype p)\rbtype isnan (ftype x)\rbtype isinf (ftype x)\rftype intBitsToFloat (itype v)\rftype uintBitsToFloat (utype v)\ritype floatBitsToInt (ftype v)\rutype floatBitsToUint (ftype v)\ruint packSnorm2x16 (vec2 v)\ruint packUnorm2x16 (vec2 v)\rvec2 unpackSnorm2x16 (uint p)\rvec2 unpackUnorm2x16 (uint p)\rbvec lessThan (vec x, vec y)\rbvec lessThanEqual (vec x, vec y)\rbvec greaterThan (vec x, vec y)\rbvec greaterThanEqual (vec x, vec y)\rbvec equal (type x, type y)\rbvec notEqual (type x, type y)\rbool any (bvec x)\rbool all (bvec x)\rbvec not (bvec x)\rHow-to\rUse structs: struct myDataType { float occlusion; vec3 color; }; myDataType myData = myDataType(0.7, vec3(1.0, 2.0, 3.0));\rInitialize arrays: float[] x = float[] (0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6);\rDo conversions: int a = 3; float b = float(a);\rDo component swizzling: vec4 a = vec4(1.0,2.0,3.0,4.0); vec4 b = a.zyyw;\rAccess matrix components: mat4 m; m[1] = vec4(2.0); m[0][0] = 1.0; m[2][3] = 2.0;\rBe careful!\rthe f suffix for floating pont numbers: 1.0f is illegal in GLSL. You must use 1.0\rsaturate(): saturate(x) doesn't exist in GLSL. Use clamp(x,0.0,1.0) instead\rpow/sqrt: please don't feed sqrt() and pow() with negative numbers. Add an abs() or max(0.0,) to the argument\rmod: please don't do mod(x,0.0). This is undefined in some platforms\rvariables: initialize your variables! Don't assume they'll be set to zero by default\rfunctions: don't call your functions the same name as any of your variables\rShadertoy Inputs\rvec3iResolutionimage/bufferThe viewport resolution (z is pixel aspect ratio, usually 1.0)\rfloatiTimeimage/sound/bufferCurrent time in seconds\rfloatiTimeDeltaimage/bufferTime it takes to render a frame, in seconds\rintiFrameimage/bufferCurrent frame\rfloatiFrameRateimage/bufferNumber of frames rendered per second\rfloatiChannelTime[4]image/bufferTime for channel (if video or sound), in seconds\rvec3iChannelResolution[4]image/buffer/soundInput texture resolution for each channel\rvec4iMouseimage/bufferxy = current pixel coords (if LMB is down). zw = click pixel\rsampler2DiChannel{i}image/buffer/soundSampler for input textures i\rvec4iDateimage/buffer/soundYear, month, day, time in seconds in .xyzw\rfloatiSampleRateimage/buffer/soundThe sound sample rate (typically 44100)\rShadertoy Outputs\rImage shaders: fragColor is used as output channel. It is not, for now, mandatory but recommended to leave the alpha channel to 1.0.\nSound shaders: the mainSound() function returns a vec2 containing the left and right (stereo) sound channel wave data.\rShare your shader\rYes\rNo\rBBCode Help Codes: You can format your comments by using standard BBCode. The following tags are implemented in Shadertoy: Bold[b]this text goes in bold[/b] Italic[i]this text goes in italic[/i] Images[img]url_to_image[/img] Url[url]http://www.shadertoy.com[/url] Url[url=http://www.shadertoy.com]Shadertoy[/url] Code[code]fixed-width text[/code] Video[video]http://www.youtube.com/watch?v=0ifChJ0nJfM[/video] Emoticons: :) :( :D :love: :octopus: :octopusballoon: Symbols: :alpha:\u0026#945; :beta:\u0026#946; :delta:\u0026#916; :epsilon:\u0026#949; :nabla:\u0026#8711; :square:\u0026#178; :cube:\u0026#179; :limit:\u0026#8784; Share your shader\rDirect link:\nJust copy and paste this URL below: Embed:\n\u003ciframe width=\"640\" height=\"360\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/4cfcDX?gui=true\u0026t=10\u0026paused=true\u0026muted=false\" allowfullscreen\u003e Add to playlist\r","permalink":"https://mickjagger19.github.io/posts/attachments/music/my-gears/nights-backbone-copy/","summary":"\u003c!DOCTYPE HTML\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \r\n\u003cscript async src=\"https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2\"\u003e\u003c/script\u003e\r\n\u003cscript\u003e\r\n  window.dataLayer = window.dataLayer || [];\r\n  function gtag(){dataLayer.push(arguments);}\r\n  gtag('js', new Date());\r\n\r\n  gtag('config', 'G-7SYLWGZYJ2');\r\n\u003c/script\u003e\r\n\r\n\u003ctitle\u003eShader - Shadertoy BETA\u003c/title\u003e\r\n\u003cmeta charset=\"utf-8\" /\u003e\r\n\u003cmeta name=\"Keywords\" content=\"shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl\" /\u003e\r\n\u003cmeta name=\"Description\" content=\"Build shaders, share them, and learn from the best community.\" /\u003e\r\n\u003cmeta name=\"Author\" content=\"Beautypi\" /\u003e\r\n\u003cmeta name=\"apple-mobile-web-app-capable\" content=\"yes\" /\u003e\r\n\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\r\n\r\n\u003clink rel=\"image_src\" href=\"https://www.shadertoy.com/img/logo.png\" /\u003e\r\n\u003clink rel=\"apple-touch-icon\" href=\"/img/launch_icon_57.png\"/\u003e\r\n\u003clink rel=\"apple-touch-icon\" sizes=\"72x72\" href=\"/img/launch_icon_72.png\"/\u003e\r\n\u003clink rel=\"apple-touch-icon\" sizes=\"114x114\" href=\"/img/launch_icon_114.png\"/\u003e\r\n\u003clink rel=\"shortcut icon\" href=\"/img/favicon.ico\"/\u003e\r\n\r\n\u003cstyle\u003e*\r\n{\r\n    box-sizing: border-box;\r\n}\r\n\r\n::-webkit-scrollbar {\r\n    height: 8px;\r\n    width: 8px;\r\n    background: #404040;\r\n}\r\n\r\n::-webkit-scrollbar-thumb\r\n{\r\n    background: #909090;\r\n    border-radius: 0ex;\r\n}\r\n\r\n::-webkit-scrollbar-corner\r\n{\r\n    background: #000;\r\n}\r\n\r\n::-webkit-input-placeholder\r\n{\r\n\tfont-style:italic;\r\n}\r\ninput:-moz-placeholder, textarea:-moz-placeholder\r\n{\r\n\tfont-style:italic;\r\n}\r\ninput.placeholder-text, textarea.placeholder-text\r\n{\r\n\tfont-style:italic;\r\n}\r\n\r\npre \r\n{\r\n    white-space: pre-wrap;\r\n    white-space: -moz-pre-wrap;\r\n    white-space: -pre-wrap;\r\n    white-space: -o-pre-wrap;\r\n    word-wrap: break-word;\r\n}\r\n\r\n@font-face\r\n{\r\n    font-family: Lobster;\r\n    src: url(\"/img/lobster.otf\") format(\"opentype\");\r\n}\r\n\r\ndiv#centerScreen\r\n{\r\n    left: 50%;\r\n    top: 50%;\r\n    position: absolute;\r\n}\r\n\r\na.headerLinks:hover\r\n{\r\n    background-color:#505050;\r\n    color : #ff8020;\r\n}\r\n\r\nbody\r\n{\r\n    color: #000000;\r\n    font-size:12px;\r\n    font-style:normal;\r\n    font-family:Tahoma,Arial;\r\n    background-repeat: no-repeat;\r\n    //background-attachment: fixed;\r\n    padding:0px;\r\n    margin:0px;\r\n    text-align: left;\r\n    background-color: #d0d0d0;\r\n    background-repeat: repeat;\r\n    user-select: text;\r\n}\r\n\r\na,\r\na:hover,\r\na:visited\r\n{\r\n  color : inherit;\r\n}\r\n\r\ndiv#content {\r\n    width: 95%;\r\n    overflow: hidden;\r\n    margin: auto;\r\n    padding: 0px;\r\n    min-height: calc(100vh - 80px);\r\n}\r\n\r\n\r\n.notificationCount\r\n{\r\n background-color:#ff0000;\r\n padding-left:3px;\r\n padding-right:1px;\r\n padding-top:1px;\r\n padding-bottom:1px;\r\n}\r\n\r\ndiv#header\r\n{\r\n    background-color: #404040;\r\n    top: 0px;\r\n    left: 0px;\r\n    width: 100%;\r\n    padding: 0;\r\n    margin: 0;\r\n    color: #ffffff;\r\n    display: flex;\r\n    flex-direction:row;\r\n}\r\n\r\n#headerBlock1\r\n{\r\n    width: 50%;\r\n    display:flex;\r\n    align-items:center;\r\n}\r\n\r\na#headerTitle\r\n{\r\n    font-size: 2.25em;\r\n    font-family: Lobster,Tahoma,Arial;\r\n    text-decoration: none;\r\n    padding-left:32px;\r\n    padding-right:32px;\r\n}\r\n\r\n#headerSearch\r\n{\r\n    display: inline-block;\r\n    color: #000000;\r\n    width: 300px;\r\n}\r\n\r\ninput[type=search]#mySearch\r\n{\r\n    width: 100%;\r\n    border-radius: 6px;\r\n    border: 1px solid black;\r\n    padding:12px;\r\n}\r\n\r\n#headerBlock2\r\n{\r\n    width: 50%;\r\n    margin-left: auto;\r\n    display: flex;\r\n    justify-content: flex-end;\r\n}\r\n\r\n\r\na#headerTitle:hover\r\n{\r\n    color : #ff8020;\r\n}\r\n\r\na.headerLinks\r\n{\r\n    font-weight: bold;\r\n    padding-top: 14px;\r\n    padding-bottom: 14px;\r\n    padding-left: 14px;\r\n    padding-right: 14px;\r\n    margin:0px;\r\n    text-decoration: none;\r\n    transition: background-color 0.15s linear, color 0.15s linear;\r\n}\r\n\r\n#footer\r\n{\r\n    background-color: rgba(64,64,64,0.25);\r\n    color: #000000;\r\n    padding: 0px;\r\n    margin: 0px;\r\n    width: 100%;\r\n    display: flex;\r\n    justify-content: space-between;\r\n    flex-wrap: wrap;\r\n}\r\n\r\n#footer div\r\n{\r\n    padding-top:10px;\r\n    padding-bottom:0px;\r\n    padding-left:16px;\r\n    padding-right:16px;\r\n}\r\n\r\n#footer div ul\r\n{\r\n    margin-left:0px;\r\n    padding-left:16px;\r\n}\r\n\r\n#footer div ul li\r\n{\r\n    padding-top:6px;\r\n}\r\n\r\na.regular\r\n{\r\n    font-weight:bold;\r\n    text-decoration:none\r\n}\r\n\r\na.regular:hover\r\n{\r\n  color : #ff8020;\r\n}\r\n\r\na.user\r\n{\r\n    font-weight:bold;\r\n    text-decoration:none;\r\n}\r\n\r\na.user:hover\r\n{\r\n  color : #ff8020;\r\n  text-decoration: underline;\r\n}\r\n\r\n.uiButton\r\n{\r\n    border: none;\r\n    outline: none;\r\n    margin: 0px;\r\n    padding: 0px;\r\n    width: 22px;\r\n    height: 22px;\r\n    cursor: pointer;\r\n    border-radius: 4px;\r\n}\r\n\r\n.uiButton:hover\r\n{\r\n    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;\r\n}\r\n\r\n.uiDivBUtton\r\n{\r\n    cursor:pointer;\r\n}\r\n\r\n.uiDivBUtton:hover\r\n{\r\n    color: #ffffff;\r\n}\r\n\r\n\r\n.dialog\r\n{\r\n    display: block;\r\n    background-color: #e0e0e0;\r\n    color: #000000;\r\n    border:1px solid #000;\r\n    padding:0px;\r\n    margin:0px;\r\n    text-align:left;\r\n    border-radius: 4px;\r\n    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);\r\n    overflow: hidden;\r\n    z-index:1000;\r\n    visibility: hidden;\r\n    opacity:0;\r\n    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;\r\n    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;\r\n    transition: opacity 0.25s linear,visibility 0.25s linear;\r\n}\r\n\r\n.dialogHeader\r\n{\r\n    left:0px;\r\n    top: 0px;\r\n    width:100%;\r\n    height:32px;\r\n    position: absolute;\r\n    background-color: #808080;\r\n    cursor:move;\r\n}\r\n\r\n.dialogTitle\r\n{\r\n    left: 12px;\r\n    top: 4px;\r\n    position: absolute;\r\n    padding: 0px;\r\n    margin: 0px;\r\n    color:#000000;\r\n    font-size:1.5em;\r\n    text-align: left;\r\n    user-select: none;\r\n    -moz-user-select: -moz-none;\r\n    -webkit-user-select: none;\r\n}\r\n\r\n.dialogOverlay\r\n{\r\n    z-index:1000;\r\n\r\n    visibility: hidden;\r\n    opacity:0;\r\n    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;\r\n    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;\r\n    transition: opacity 0.25s linear,visibility 0.25s linear;\r\n\r\n    left:0px;\r\n    top:0px;\r\n    padding:0px;\r\n    margin:0px;\r\n    width:100%;\r\n    height:100%;\r\n    position:absolute;\r\n\r\n    background-color:rgba(0,0,0,.4);\r\n}\r\n\r\n.viewsIcon, .likesIcon\r\n{\r\n    border: none;\r\n    outline: none;\r\n    display:inline-block;\r\n    background-repeat:no-repeat;\r\n    top:0px;\r\n    left:0px;\r\n    padding:0px;\r\n    padding-right: 2px;\r\n    margin:0px;\r\n    position:relative;\r\n}\r\n\r\n.userPictureSmall\r\n{\r\n    background-color:#808080;\r\n    border: 1px solid #000000;\r\n    width:32px;\r\n    height:32px;\r\n}\r\n\r\n.dialogCloseButton\r\n{\r\n    right:8px;\r\n    top: 4px;\r\n    width:22px;\r\n    height:22px;\r\n    position: absolute;\r\n    background-image: url(\"/img/close.png\");\r\n    cursor: pointer;\r\n    border-radius: 4px;\r\n}\r\n\r\n.dialogCloseButton:hover\r\n{\r\n    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;\r\n}\r\n\r\n.dialogContentButtons\r\n{\r\n     padding:0;\r\n     border:0;\r\n     text-align: justify;\r\n     left: 24px;\r\n     bottom:40px;\r\n     position:absolute;\r\n}\r\n\r\n.dialogButton\r\n{\r\n    text-align: center;\r\n    vertical-align: middle;\r\n    display: inline-block;\r\n    border-radius: 4px;\r\n    font-weight: bold;\r\n    cursor: pointer;\r\n    padding-bottom:5px;\r\n    padding-top:4px;\r\n    padding-left: 8px;\r\n    padding-right: 8px;\r\n    margin-left:4px;\r\n    margin-right:4px;\r\n    text-decoration: none;\r\n    color:#000000;\r\n    width: 80px;\r\n    -moz-transition:    background-color 0.15s linear, color 0.15s linear;\r\n    -webkit-transition: background-color 0.15s linear, color 0.15s linear;\r\n    transition:         background-color 0.15s linear, color 0.15s linear;\r\n}\r\n\r\n.dialogButton:hover\r\n{\r\n  background-color:#808080;\r\n  color : #ff8020;\r\n}\r\n\r\n.dialogCloseButton:hover\r\n{\r\n    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;\r\n}\r\n\r\n.dialogContent\r\n{\r\n    color: inherit;\r\n    overflow: auto;\r\n    width:100%;\r\n    height:100%;\r\n    left: 0px;\r\n    top: 32px;\r\n    position:absolute\r\n}\r\n\r\n.dialogContentBody\r\n{\r\n    color: inherit;\r\n    width:100%;\r\n    height:auto;\r\n    padding-top:24px;\r\n    padding-bottom:24px;\r\n    padding-left:24px;\r\n    padding-right:24px;\r\n    text-align: left;\r\n}\r\n\r\n.formButton\r\n{\r\n    font-weight:bold;\r\n\tcolor:#ffffff;\r\n\tborder:none;\r\n    text-align:center;\r\n\tbackground-color:#808080;\r\n    border-radius: 4px;\r\n\tpadding-left:8px;\r\n\tpadding-right:8px;\r\n\tpadding-top:4px;\r\n\tpadding-bottom:4px;\r\n    cursor:pointer;\r\n    min-width:80px;\r\n}\r\n.formInput {\r\n    border-radius: 6px;\r\n    border: 1px solid black;\r\n    padding: 4px;\r\n    border: none;\r\n}\r\n.formButton:hover {\r\n    background-color: #e0e0e0;\r\n}\r\n.formButton:disabled\r\n{\r\n\tcolor:#b0b0b0;\r\n\tbackground-color:#808080;\r\n}\r\n\r\n.formButtonSmall\r\n{\r\n    color:#ffffff;\r\n    border:none;\r\n    text-align:center;\r\n    background-color:#808080;\r\n    border-radius: 4px;\r\n    padding-left:2px;\r\n    padding-right:2px;\r\n    padding-top:2px;\r\n    padding-bottom:2px;\r\n    cursor:pointer;\r\n    min-width:40px;\r\n}\r\n\r\n.formButtonSmall:hover\r\n{\r\n    background-color: #e0e0e0;\r\n}\r\n\r\n.formButtonSmall:disabled\r\n{\r\n    color:#b0b0b0;\r\n    background-color:#808080;\r\n}\r\n\r\n.formButtonSmall.disabled2,\r\n.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }\r\n\r\n.inputForm\r\n{\r\n    padding-left:2%;\r\n    padding-right:2%;\r\n    resize: none;\r\n    text-align: left;\r\n    background-color:#e0e0e0;\r\n    outline: none;\r\n    border-radius: 4px;\r\n    border: 1px solid #808080;\r\n    color:inherit;\r\n}\r\n\r\n.inputForm:focus\r\n{\r\n    border: 1px solid #AFCDD8;\r\n    background-color: #EBF2F4;\r\n}\r\n\r\n.transparentPannel\r\n{\r\n    background-color:rgba(64,64,64,0.1);\r\n    padding:16px;\r\n}\r\n\r\n.comment, .commentSelf, .commentNew\r\n{\r\n    border-radius: 4px;\r\n    width: 100%;\r\n    margin-left: 0px;\r\n    margin-right: 0px;\r\n    margin-top: 0px;\r\n    margin-bottom: 6px;\r\n\r\n    padding: 14px;\r\n    display: grid;\r\n    grid-template-columns: 32px auto 8px;\r\n    grid-template-rows: 1fr;\r\n    grid-gap:8px;\r\n}\r\n\r\n.comment:nth-child(even)\r\n{\r\n    background-color: rgba(64,64,64,0.1);\r\n}\r\n\r\n.comment:nth-child(odd)\r\n{\r\n    background-color: rgba(128,128,128,0.1);\r\n}\r\n\r\n.commentSelf\r\n{\r\n    background-color: rgba(240,160,64,0.1);\r\n}\r\n\r\n.commentNew\r\n{\r\n    padding-right: 0px;\r\n    grid-template-columns: 40px auto;\r\n}\r\n\r\n.commentContent\r\n{\r\n    vertical-align: top;\r\n    text-align: left;\r\n    word-break: break-all;\r\n    word-break: break-word;\r\n    white-space: pre-wrap;\r\n    white-space: -moz-pre-wrap;\r\n}\r\n\r\n\r\n/* ----------------------- media resolutions ------------------------ */\r\n\r\n@media screen and (max-width:799px)\r\n{\r\n    div#header {flex-direction:column; }\r\n    #headerBlock1 { width:100%; }\r\n    #headerBlock2 { width:100%; justify-content: space-around;}\r\n    div#headerSearch {width:200px;}\r\n    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }\r\n    .previewText { width:130px; }\r\n    .transparentPannel { padding:10px; }\r\n}\r\n\r\n@media screen and (min-width:800px) and (max-width:1279px)\r\n{\r\n    body { font-size: 9px; }\r\n    div#headerSearch {width: 250px;}\r\n    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }\r\n    .previewText { width:130px; }\r\n    .transparentPannel { padding:11px; }\r\n}\r\n\r\n@media screen and (min-width:1280px) and (max-width:1439px)\r\n{\r\n    body { font-size: 10px; }\r\n    div#headerSearch {width: 300px;}\r\n    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }\r\n    .dialogHeader { height:28px; }\r\n    .previewText { width:180px; }\r\n    .transparentPannel { padding:12px; }\r\n}\r\n\r\n@media screen and (min-width:1440px) and (max-width:1919px)\r\n{\r\n    div#headerSearch {width: 300px;}\r\n    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }\r\n    .dialogHeader { height:28px; }\r\n    .previewText { width:180px; }\r\n    .transparentPannel { padding:12px; }\r\n}\r\n\r\n@media screen and (min-width:1920px) and (max-width:2559px)\r\n{\r\n    div#headerSearch {width: 300px;}\r\n    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }\r\n    .dialogHeader { height:32px; }\r\n    .previewText { width:220px; }\r\n    .transparentPannel { padding:16px; }\r\n}\r\n\r\n@media screen and (min-width:2560px) \r\n{\r\n    div#headerSearch {width: 300px;}\r\n    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }\r\n    .dialogHeader { height:32px; }\r\n    .previewText { width:220px; }\r\n    .transparentPannel { padding:16px; }\r\n}\r\nbody\r\n{\r\n    background-image: url(\"/img/themes/classic/background.jpg\");\r\n}\r\n\u003c/style\u003e\r\n\r\n    \u003cstyle\u003e/* BASICS */\n\n.errorMessage\n{\n    color: #ffffff;\n    background-color: #ff3020;\n    box-shadow:0px 4px 4px 0px #a0a0a0;\n    margin-top: 0px;\n    margin-bottom: 0px;\n    padding:2px;\n}\n\n.CodeMirror {\n    /* Set height, width, borders, and global font properties here */\n    font-family: consolas,monospace;\n    font-weight: bold;\n    height: 100%;\n    color: black;\n    background-color: white;\n    direction: ltr;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n  padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  padding: 0 4px; /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  background-color: white; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n  border-right: 1px solid #ddd;\n  background-color: #f7f7f7;\n  white-space: nowrap;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n  padding: 0 3px 0 5px;\n  min-width: 20px;\n  text-align: right;\n  color: #999;\n  white-space: nowrap;\n}\n\n.CodeMirror-guttermarker { color: black; }\n.CodeMirror-guttermarker-subtle { color: #999; }\n\n/* CURSOR */\n\n.CodeMirror-cursor {\n  border-left: 1px solid black;\n  border-right: none;\n  width: 0;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n  border-left: 1px solid silver;\n}\n.cm-fat-cursor .CodeMirror-cursor {\n  width: auto;\n  border: 0 !important;\n  background: #7e7;\n}\n.cm-fat-cursor div.CodeMirror-cursors {\n  z-index: 1;\n}\n.cm-fat-cursor-mark {\n  background-color: rgba(20, 255, 20, 0.5);\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n}\n.cm-animate-fat-cursor {\n  width: auto;\n  border: 0;\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n  background-color: #7e7;\n}\n@-moz-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@-webkit-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n\n/* Can style cursor different in overwrite (non-insert) mode */\n.CodeMirror-overwrite .CodeMirror-cursor {}\n\n.cm-tab { display: inline-block; text-decoration: inherit; }\n\n.CodeMirror-rulers {\n  position: absolute;\n  left: 0; right: 0; top: -50px; bottom: 0;\n  overflow: hidden;\n}\n.CodeMirror-ruler {\n  border-left: 1px solid #ccc;\n  top: 0; bottom: 0;\n  position: absolute;\n}\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n.cm-strikethrough {text-decoration: line-through;}\n\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable,\n.cm-s-default .cm-punctuation,\n.cm-s-default .cm-property,\n.cm-s-default .cm-operator {}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n\n.cm-s-default .cm-error {color: #f00;}\n.cm-invalidchar {color: #f00;}\n\n.CodeMirror-composing { border-bottom: 2px solid; }\n\n/* Default styles for common addons */\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\n.CodeMirror-activeline-background {background: #e8f2ff;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\n   the editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n    line-height: 1;\n    position: relative;\n    overflow: hidden;\n    background: white;\n}\n\n.CodeMirror-scroll {\n  overflow: scroll !important; /* Things will break if this is overridden */\n  /* 30px is the magic margin used to hide the element's real scrollbars */\n  /* See overflow: hidden in .CodeMirror */\n  margin-bottom: -30px; margin-right: -30px;\n  padding-bottom: 30px;\n  height: 100%;\n  outline: none; /* Prevent dragging from highlighting the element */\n  position: relative;\n}\n.CodeMirror-sizer {\n  position: relative;\n  border-right: 30px solid transparent;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\n   before actual scrolling happens, thus preventing shaking and\n   flickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  position: absolute;\n  z-index: 6;\n  display: none;\n}\n.CodeMirror-vscrollbar {\n  right: 0; top: 0;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n  bottom: 0; left: 0;\n  overflow-y: hidden;\n  overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n  right: 0; bottom: 0;\n}\n.CodeMirror-gutter-filler {\n  left: 0; bottom: 0;\n}\n\n.CodeMirror-gutters {\n  position: absolute; left: 0; top: 0;\n  min-height: 100%;\n  z-index: 3;\n}\n.CodeMirror-gutter {\n  white-space: normal;\n  height: 100%;\n  display: inline-block;\n  vertical-align: top;\n  margin-bottom: -30px;\n}\n.CodeMirror-gutter-wrapper {\n  position: absolute;\n  z-index: 4;\n  background: none !important;\n  border: none !important;\n}\n.CodeMirror-gutter-background {\n  position: absolute;\n  top: 0; bottom: 0;\n  z-index: 4;\n}\n.CodeMirror-gutter-elt {\n  position: absolute;\n  cursor: default;\n  z-index: 4;\n}\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\n\n.CodeMirror-lines {\n  cursor: text;\n  min-height: 1px; /* prevents collapsing before first draw */\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  /* Reset some styles that the rest of the page might have set */\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n  border-width: 0;\n  background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n  line-height: inherit;\n  color: inherit;\n  z-index: 2;\n  position: relative;\n  overflow: visible;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-font-variant-ligatures: contextual;\n  font-variant-ligatures: contextual;\n}\n.CodeMirror-wrap pre.CodeMirror-line,\n.CodeMirror-wrap pre.CodeMirror-line-like {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: normal;\n}\n\n.CodeMirror-linebackground {\n  position: absolute;\n  left: 0; right: 0; top: 0; bottom: 0;\n  z-index: 0;\n}\n\n.CodeMirror-linewidget {\n  position: relative;\n  z-index: 2;\n  padding: 0.1px; /* Force widget margins to stay inside of the container */\n}\n\n.CodeMirror-widget {}\n\n.CodeMirror-rtl pre { direction: rtl; }\n\n.CodeMirror-code {\n  outline: none;\n}\n\n/* Force content-box sizing for the elements where we expect it */\n.CodeMirror-scroll,\n.CodeMirror-sizer,\n.CodeMirror-gutter,\n.CodeMirror-gutters,\n.CodeMirror-linenumber {\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n.CodeMirror-measure {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n\n.CodeMirror-cursor {\n  position: absolute;\n  pointer-events: none;\n}\n.CodeMirror-measure pre { position: static; }\n\ndiv.CodeMirror-cursors {\n  visibility: hidden;\n  position: relative;\n  z-index: 3;\n}\ndiv.CodeMirror-dragcursors {\n  visibility: visible;\n}\n\n.CodeMirror-focused div.CodeMirror-cursors {\n  visibility: visible;\n}\n\n.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\n.CodeMirror-crosshair { cursor: crosshair; }\n.CodeMirror-line::selection, .CodeMirror-line \u003e span::selection, .CodeMirror-line \u003e span \u003e span::selection { background: #d7d4f0; }\n.CodeMirror-line::-moz-selection, .CodeMirror-line \u003e span::-moz-selection, .CodeMirror-line \u003e span \u003e span::-moz-selection { background: #d7d4f0; }\n\n.cm-searching {\n  background-color: #ffa;\n  background-color: rgba(255, 255, 0, .4);\n}\n\n/* Used to force a border model for a node */\n.cm-force-border { padding-right: .1px; }\n\n@media print {\n  /* Hide the cursor when printing */\n  .CodeMirror div.CodeMirror-cursors {\n    visibility: hidden;\n  }\n}\n\n/* See issue #2901 */\n.cm-tab-wrap-hack:after { content: ''; }\n\n/* Help users use markselection to safely style text background */\nspan.CodeMirror-selectedtext { background: none; }\n\n/*iq*/\n.cm-highlight { background-color: #e0e0e0; }.CodeMirror-dialog {\n  position: absolute;\n  left: 0; right: 0;\n  background: #f8b030;\n  z-index: 15;\n  padding: .1em .8em;\n  overflow: hidden;\n  color: #ffffff;\n  border: none;\n}\n\n.CodeMirror-dialog-top {\n  border-bottom: 0px solid #000000;\n  top: 0;\n}\n\n.CodeMirror-dialog-bottom {\n  border-top: 0px solid #000000;\n  bottom: 0;\n}\n\n.CodeMirror-dialog input {\n  border: none;\n  outline: none;\n  background: transparent;\n  width: 20em;\n  color: #000000;\n  font-family: consolas, monospace;\n}\n\n.CodeMirror-dialog button {\n  font-size: 70%;\n}\n.CodeMirror-foldmarker {\n  color: blue;\n  text-shadow: #b9f 1px 1px 2px, #b9f -1px -1px 2px, #b9f 1px -1px 2px, #b9f -1px 1px 2px;\n  font-family: arial;\n  line-height: .3;\n  cursor: pointer;\n}\n.CodeMirror-foldgutter {\n  width: .7em;\n}\n.CodeMirror-foldgutter-open,\n.CodeMirror-foldgutter-folded {\n  cursor: pointer;\n}\n.CodeMirror-foldgutter-open:after {\n  content: \"\\25BE\";\n}\n.CodeMirror-foldgutter-folded:after {\n  content: \"\\25B8\";\n}\n\u003c/style\u003e\r\n\r\n    \u003cstyle\u003e.container {\r\n    padding: 0;\r\n    margin: 0;\r\n    width: 100%;\r\n    box-sizing: border-box;\r\n    padding-top: 24px;\r\n    padding-bottom: 24px;\r\n    display: grid;\r\n    grid-template-rows: auto auto;\r\n    grid-gap: 32px;\r\n    align-items: start;\r\n    height: 100%;\r\n}\r\n\r\n.block0 { }\r\n.block1 {\r\n    grid-row: span 2;\r\n    display: block;\r\n    grid-template-columns: auto;\r\n    grid-template-rows: auto auto auto auto auto auto;\r\n}\r\n.block2 { }\r\ndiv#player\r\n{\r\n    width: 100%;\r\n    padding: 0;\r\n    margin: 0;\r\n    border-radius: 4px;\r\n    display:flex;\r\n    flex-direction:column;\r\n}\r\n.playerCanvas\r\n{\r\n    width: 100%;\r\n    aspect-ratio: 16 / 9;\r\n    border: none;\r\n    outline: none;\r\n    padding: 0;\r\n    margin: 0;\r\n    cursor: pointer;\r\n    border-radius: 4px 4px 0px 0px;\r\n}\r\n.playerCanvas:focus\r\n{\r\n    outline:none;\r\n}\r\n.playerBar\r\n{\r\n    font-weight: bold;\r\n    width: 100%;\r\n    background-color: #f0f0f0;\r\n    border: none;\r\n    outline: none;\r\n    padding: 0.25rem;\r\n    margin: 0;\r\n    border-radius: 0px 0px 4px 4px;\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    gap: 1rem;\r\n}\r\n.playerBar \u003e div:nth-child(1)\r\n{\r\n    display:flex;\r\n    gap:16px;\r\n}\r\n.playerBar \u003e div:nth-child(2)\r\n{\r\n    display:flex;justify-content:space-between;gap:1rem;;\r\n}\r\n.playerBar \u003e div:nth-child(3)\r\n{\r\n    display:flex;gap:16px;flex: 1 0 auto;justify-content:right\r\n}\r\n\r\ndiv#noWebGL\r\n{\r\n    width: 100%;\r\n    aspect-ratio: 16 / 9;\r\n    left: 0px;\r\n    top: 0px;\r\n    cursor: pointer;\r\n    border: 0px;\r\n    border-radius: 4px 4px 0px 0px;\r\n    background-color:#000000;\r\n    display: none;\r\n    position: relative;\r\n}\r\n\r\nimg#noWebGL_ShaderImage\r\n{\r\n    left: 0px;\r\n    top: 0px;\r\n    width: 100%;\r\n    height: 100%;\r\n    position: absolute;\r\n    border: 0px;\r\n    border-radius: 4px 4px 0px 0px;\r\n}\r\n\r\nspan#noWebGL_Text\r\n{\r\n    left:8px;\r\n    font-size: 1.5em;\r\n    border: 0px;\r\n    color:#ff0000;\r\n    position: absolute;\r\n}\r\n\r\n/* do NOT put these in one single block */\r\n.playerCanvas_full-screen { width: 100%; height: 100%; }\r\n.playerCanvas:full-screen { width: 100%; height: 100%; }\r\n.playerCanvas:fullscreen { width: 100%; height: 100%; }\r\n.playerCanvas:-webkit-full-screen { width: 100%; height: 100%; }\r\n.playerCanvas:-moz-full-screen { width: 100%; height: 100%; }\r\n.playerCanvas:-ms-fullscreen { width: 100%; height: 100%; }\r\n\r\ndiv#shaderInfo\r\n{\r\n    width: 100%;\r\n    padding-top:0;\r\n    padding-left:0;\r\n    padding-right:0;\r\n    margin-left:0;\r\n    margin-right:0;\r\n    margin-top:8px;\r\n    user-select: text;\r\n    -moz-user-select: -moz-text;\r\n    -webkit-user-select: text;\r\n}\r\n\r\n.shaderInfoA\r\n{\r\n    display: grid;\r\n    grid-template-columns: 5fr 3fr;\r\n    grid-template-rows: 1fr 1fr;\r\n    grid-column-gap: 4px;\r\n    grid-row-gap: 4px;\r\n}\r\n\r\n.shaderInfoA\u003e:nth-child(2),\r\n.shaderInfoA\u003e:nth-child(4) \r\n{\r\n    text-align: right;\r\n}\r\n\r\n.shaderInfoHeaderRightBigText {\r\n    position: relative;\r\n    bottom: 4px;\r\n    font-size: 18px;\r\n}\r\n\r\ndiv#shaderAuthor\r\n{\r\n    padding-top:8px;\r\n    text-align: right;\r\n}\r\n\r\n#shaderTitle\r\n{\r\n    width:100%;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n    font-size:2.0em;\r\n    font-weight:bold;\r\n    text-align: left;\r\n    top: 0px;\r\n    left: 0px;\r\n    padding: 0px;\r\n    margin-left:0;\r\n    margin-right:0;\r\n    margin-top:0px;\r\n    margin-bottom:6px;\r\n}\r\n\r\n#shaderDescription\r\n{\r\n    width: 100%;\r\n    text-align: left;\r\n    position: relative;\r\n    padding: 0px;\r\n    margin-top: 6px;\r\n    margin-bottom: 6px;\r\n    font-family: inherit;\r\n    font-size: inherit;\r\n    word-wrap:break-word;\r\n    white-space: pre-wrap;\r\n    white-space: -moz-pre-wrap;\r\n}\r\n\r\n#shaderPublished\r\n{\r\n    text-align: justify;\r\n    top: 0px;\r\n    left: 0px;\r\n    position: relative;\r\n    padding: 0px;\r\n    margin: 0px;\r\n}\r\n\r\n#published, #publishedAmin\r\n{\r\n    font-family: inherit;\r\n    font-size: inherit;\r\n    width:120px;\r\n}\r\n\r\ndiv#shaderStats\r\n{\r\n    text-align: right;\r\n}\r\n\r\ndiv#shaderLike\r\n{\r\n    left: 0px;\r\n    position: absolute;\r\n}\r\n\r\ndiv#comments\r\n{\r\n    padding-left:0px;\r\n    padding-right:0px;\r\n    margin-left:0px;\r\n    margin-right:0px;\r\n    user-select: text;\r\n    -moz-user-select: -moz-text;\r\n    -webkit-user-select: text;\r\n}\r\n\r\ndiv#commentsForm\r\n{\r\n    top: 16px;\r\n    left: 0px;\r\n    width: 100%;\r\n    position: relative;\r\n    padding-left:0px;\r\n    padding-right:0px;\r\n    padding-bottom:12px;\r\n    margin-left:0px;\r\n    margin-right:0px;\r\n}\r\n\r\n#commentTextArea\r\n{\r\n    width: 96%;\r\n    padding-left:2%;\r\n    padding-right:2%;\r\n    font-style:normal;\r\n    font-weight:normal;\r\n    font-family: inherit;\r\n    font-size: inherit;\r\n    text-align: left;\r\n    background-color:#ffffff;\r\n    outline: none;\r\n    border-radius: 4px;\r\n    border: 1px solid #808080;\r\n    resize: none;\r\n}\r\n\r\n.inputSelectorBar\r\n{\r\n    background-color: #f0f0f0;\r\n}\r\n\r\n.inputSelector\r\n{\r\n    display:grid;\r\n    border-radius: 4px;\r\n    background-color:#000000;\r\n}\r\n\r\n.inputSelector:hover\r\n{\r\n  cursor: pointer;\r\n  box-shadow:0px 0px 9px 4px #ffffff;\r\n}\r\n\r\n.inputSelectorBar {\r\n    grid-gap: 0px;\r\n    display: grid;\r\n    grid-template-columns: auto auto;\r\n    grid-template-rows: 1fr;\r\n    justify-content: space-between;\r\n}\r\n\r\n.inputSelectorCanvas {\r\n    width: 100%;\r\n    height: 100%;\r\n    margin: 0px;\r\n    padding: 0px;\r\n    border: 0px;\r\n    border-radius: 4px 4px 0px 0px;\r\n}\r\n\r\n.deleteInput{\r\n    cursor: pointer;\r\n    right: 4px;\r\n    top: 4px;\r\n    position: absolute;\r\n    border-radius: 16px;\r\n    visibility: hidden;\r\n}\r\n\r\n.deleteInput:hover {\r\n    box-shadow: 0px 0px 6px 4px #ffffff;\r\n}\r\n\r\n.inputSampler {\r\n    background-color: #f0f0f0;\r\n    width: 100%;\r\n    height: 0px;\r\n    margin: 0px;\r\n    padding: 0px;\r\n    padding-left: 8px;\r\n    border-radius: 4px 4px 0px 0px;\r\n    bottom: 0px;\r\n    box-sizing: border-box;\r\n    position: absolute;\r\n    overflow: hidden;\r\n    transition: height 0.25s ease-in-out;\r\n}\r\n.inputSampler.hidden\r\n{\r\n    height:0px;\r\n}\r\n.inputSampler.visible {\r\n    height: 100%;\r\n}\r\n\r\n.inputSelectorControls\r\n{\r\n    border-radius: 0px 0px 4px 4px;\r\n    justify-self:right;\r\n}\r\n\r\n.inputSelectorText\r\n{\r\n    display: inline-block;\r\n    padding: 4px;\r\n    box-sizing:border-box;\r\n}\r\n\r\n@keyframes errorNoAnimation\r\n{\r\n    from { box-shadow:0px 0px 0px 3px #00c000; }\r\n    to {   box-shadow:0px 0px 0px 3px transparent; }\r\n}\r\n@-webkit-keyframes errorNoAnimation\r\n{\r\n    from { box-shadow:0px 0px 0px 3px #00c000; }\r\n    to {   box-shadow:0px 0px 0px 3px transparent; }\r\n}\r\n@-moz-keyframes errorNoAnimation\r\n{\r\n    from { box-shadow:0px 0px 0px 3px #00c000; }\r\n    to {   box-shadow:0px 0px 0px 3px transparent; }\r\n}\r\n\r\n@keyframes savedAnimation\r\n{\r\n    from { box-shadow:0px 0px 0px 3px #0000c0; }\r\n    to {   box-shadow:0px 0px 0px 3px transparent; }\r\n}\r\n@-webkit-keyframes savedAnimation\r\n{\r\n    from { box-shadow:0px 0px 0px 3px #0000c0; }\r\n    to {   box-shadow:0px 0px 0px 3px transparent; }\r\n}\r\n@-moz-keyframes savedAnimation\r\n{\r\n    from { box-shadow:0px 0px 0px 3px #0000c0; }\r\n    to {   box-shadow:0px 0px 0px 3px transparent; }\r\n}\r\n\r\n\r\ndiv#editor.errorYes {\r\n    box-shadow: 0px 0px 0px 3px #ff3020;\r\n}\r\n\r\ndiv#editor.errorNo\r\n{\r\n    box-shadow:0px 0px 0px 3px #00c000;\r\n    animation: errorNoAnimation 1s linear 0 1 forwards;\r\n    -webkit-animation: errorNoAnimation 1s linear 0 1 forwards;\r\n    -moz-animation: errorNoAnimation 1s linear 0 1 forwards;\r\n}\r\n\r\ndiv#editor.saved\r\n{\r\n    box-shadow:0px 0px 0px 3px #0000c0;\r\n    animation: errorNoSaved 1s linear 0 1 forwards;\r\n    -webkit-animation: errorNoSaved 1s linear 0 1 forwards;\r\n    -moz-animation: errorNoSaved 1s linear 0 1 forwards;\r\n}\r\n\r\ndiv#editor {\r\n    border-radius: 4px 4px 0px 0px;\r\n    display: grid;\r\n    width: 100%;\r\n    height: calc(max(400px, 100vh - 330px));\r\n    transition: height 0.25s ease-in-out;\r\n}\r\n\r\ndiv#toolBar\r\n{\r\n    text-align: left;\r\n    left: 0px;\r\n    width: 100%;\r\n    padding-left: 0px;\r\n    padding-right: 0px;\r\n    padding-top: 0px;\r\n    margin-left: 0px;\r\n    margin-right: 0px;\r\n    background-color: #f0f0f0;\r\n    border-radius: 0px 0px 4px 4px;\r\n    display: grid;\r\n    grid-template-columns: 2fr 1fr 1fr;\r\n    grid-template-rows: 1fr;\r\n    align-items: center;\r\n}\r\n\r\ndiv#textures \r\n{\r\n    font-weight: bold;\r\n    text-align: left;\r\n    width: 100%;\r\n    margin: 0;\r\n    padding: 0;\r\n    padding-top: 18px;\r\n    padding-bottom: 18px;\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr 1fr 1fr;\r\n    grid-template-rows: 1fr;\r\n    grid-gap: 16px;\r\n}\r\n\r\ndiv#dlgAlertShader\r\n{\r\n    visibility: hidden;\r\n    z-index: 1000;\r\n    width: 320px;\r\n    height: 160px;\r\n    position: absolute;\r\n}\r\n\r\ndiv#dlgHelp\r\n{\r\n     width: 800px;\r\n     height: 450px;\r\n     position:absolute;\r\n}\r\n\r\ndiv#dlgBBCodeHelp\r\n{\r\n     position:absolute;\r\n}\r\n\r\ndiv#dlgShareShader\r\n{\r\n     position:absolute;\r\n}\r\n\r\ndiv#dlgReportShader\r\n{\r\n     width:400px;\r\n     height:120px;\r\n     position:absolute;\r\n}\r\n\r\ndiv#editorHeader\r\n{\r\n    background-color:#ffffff;\r\n    text-align: left;\r\n    top: 0px;\r\n    left: 0px;\r\n    width: 100%;\r\n    height: 16px;\r\n    position: relative;\r\n    padding-left: 0px;\r\n    padding-right: 0px;\r\n    padding-top: 2px;\r\n    padding-bottom: 2px;\r\n    margin-left: 0px;\r\n    margin-right: 0px;\r\n    margin-top: 0px;\r\n    margin-bottom: 4px;\r\n    border-radius: 4px;\r\n    overflow:hidden;\r\n    cursor: pointer;\r\n    transition: height 0.25s ease-in-out;\r\n    user-select: text;\r\n}\r\n\r\ndiv#editorHeader.expanded\r\n{\r\n    height: 162px;\r\n}\r\n\r\ndiv#editorHeaderBar\r\n{\r\n    background-color:#f0f0f0;\r\n    left: 0px;\r\n    top: 0px;\r\n    padding: 0px;\r\n    margin: 0px;\r\n    width: 100%;\r\n    height: 20px;\r\n    position: absolute;\r\n}\r\n\r\ndiv#editorHeaderArrow\r\n{\r\n    left: 8px;\r\n    top: 3px;\r\n    width: 16px;\r\n    height: 16px;\r\n    position: absolute;\r\n    background-image: url('/img/themes/classic/triOpen.png');\r\n    background-repeat:no-repeat;\r\n}\r\ndiv#editorHeaderArrow.expanded\r\n{\r\n    background-image: url('/img/themes/classic/triClose.png');\r\n}\r\n\r\ndiv#editorHeaderText\r\n{\r\n    font-family:consolas,monospace;\r\n    top: 12px;\r\n    left: 24px;\r\n    position: absolute;\r\n}\r\n\r\n\r\na.tooltip\r\n{\r\n    outline:none;\r\n    text-decoration:none;\r\n}\r\na.tooltip span\r\n{\r\n    z-index:10;\r\n    display:none;\r\n    padding:12px 12px;\r\n    margin-top:-32px;\r\n    margin-left:-32px;\r\n    border-radius:4px;\r\n    box-shadow: 5px 5px 8px #404040;\r\n}\r\na.tooltip:hover span\r\n{\r\n    display:inline; position:absolute;\r\n    border:1px solid #000000;\r\n    background:#e0e0e0;\r\n}\r\n\r\ndiv#shaderStatus\r\n{\r\n    color: #000000;\r\n    background: #ffc040;\r\n    padding-top: 2px;\r\n    padding-bottom: 2px;\r\n    padding-left: 16px;\r\n\r\n    display: inline-grid;\r\n    grid-template-rows: 1fr;\r\n    grid-template-columns: auto auto auto;\r\n    column-gap: 80px;\r\n    justify-items: start;\r\n    justify-content: start;\r\n\r\n    position: absolute;\r\n    width: inherit;\r\n    box-sizing: border-box;\r\n    border-radius: 8px;\r\n}\r\n\r\ndiv#shaderStatus \u003e div \u003e input\r\n{\r\n    font-size: 11px;\r\n    //cursor:pointer;\r\n}\r\n\r\ndiv#shaderStatus \u003e div \u003e select\r\n{\r\n    background-color: #f0f0f0;\r\n    border: 1px solid black;\r\n}\r\n\r\ndiv#passManagerSeparator\r\n{\r\n    height: 4px;\r\n    width: 100%;\r\n    top: 0px;\r\n    background-color: #f8b030;\r\n    padding: 0px;\r\n    margin-top: 0px;\r\n    margin-bottom: 6px;\r\n}\r\n\r\ndiv#passManager\r\n{\r\n    width: 100%;\r\n    height: 28px;\r\n    top: 0px;\r\n    padding:0px;\r\n    margin-left: 0px;\r\n    margin-right: 0px;\r\n    margin-top: 0px;\r\n    margin-bottom: 0px;\r\n    position: relative;\r\n    clear: both;\r\n    cursor:pointer;\r\n}\r\n\r\n.tab\r\n{\r\n  background-color: #808080;\r\n  float: left;\r\n  margin: 0px;\r\n  margin-right: 4px;\r\n  width:128px;\r\n  height:28px;\r\n  position:relative;\r\n  border-radius: 4px 4px 0px 0px;\r\n  bottom:0px;\r\n  color:#ffffff;\r\n  transition: background-color 0.15s linear, color 0.15s linear;\r\n  transition: box-shadow 0.15s linear, color 0.15s linear;\r\n}\r\n\r\n.tabAddContainer\r\n{\r\n  background-color:#b0b0b0;\r\n  float: left;\r\n  margin: 0px;\r\n  margin-right: 4px;\r\n  padding:4px;\r\n  padding-top:6px;\r\n  height:28px;\r\n  border-radius: 14px 14px 0px 0px;\r\n  position: relative;\r\n}\r\n\r\n.tabAddSelect {\r\n    color: inherit;\r\n    font-weight: bold;\r\n    position: relative;\r\n    -webkit-appearance: none;\r\n    -moz-appearance: none;\r\n    appearance: none;\r\n    background-image: url(\"/img/themes/classic/add.png\");\r\n    background-repeat: no-repeat;\r\n    background-position: center;\r\n    height:16px;\r\n    outline: 0;\r\n    padding: 0px;\r\n    margin: 0px;\r\n}\r\n\r\n.tabAddSelect option\r\n{\r\n    padding: 20px;\r\n}\r\n.tab label\r\n{\r\n  font-weight:bold;\r\n  position: absolute;\r\n  left:28px;\r\n  top:7px;\r\n}\r\n.tab img.tabImage\r\n{\r\n  position: absolute;\r\n  left:4px;\r\n  top:7px;\r\n  width:16px;\r\n  height:16px;\r\n}\r\n\r\n.tab img.tabClose\r\n{\r\n  position: absolute;\r\n  right:8px;\r\n  top:9px;\r\n}\r\n\r\n.tab:hover\r\n{\r\n  background-color: #b08060;\r\n}\r\n.tab.selected\r\n{\r\n  color:#ffffff;\r\n  background-color: #f8b030;\r\n}\r\n\r\n.tab.errorYes\r\n{\r\n    box-shadow:0px 0px 0px 3px #ff3020 inset;\r\n}\r\n\r\nselect\r\n{\r\n  border:0 none;\r\n  background-color:transparent;\r\n  width:36px;\r\n  font-size: 12px;\r\n}\r\n\r\n.info\r\n{\r\n  font-size: 9px;\r\n}\r\n\r\ndiv#pickTexture_image {\r\n    display: block;\r\n    visibility: hidden;\r\n    opacity: 1.0;\r\n    z-index: 1000;\r\n    width: 960px;\r\n    height: 620px;\r\n    position: absolute;\r\n    user-select: none;\r\n    -moz-user-select: -moz-none;\r\n    -webkit-user-select: none;\r\n}\r\n\r\n.mySoundCloudURLBox\r\n{\r\n    background-color:#000000;\r\n    position:absolute;\r\n    padding-left: 4px;\r\n    padding-right: 4px;\r\n    padding-top: 4px;\r\n    width:100px;\r\n    height:66px;\r\n    left:0px;\r\n    top:0px;\r\n    opacity:0;\r\n    transition: opacity .5s ease-in-out;\r\n}\r\n\r\n.mySoundCloudURLBoxVisible\r\n{\r\n    opacity: 1;\r\n}\r\n\r\n.mySoundCloudURL\r\n{\r\n    border:0px;\r\n    border-radius: 4px;\r\n    margin:0px;\r\n    padding-left:4px;\r\n    padding-right:4px;\r\n    width:90px;\r\n}\r\n\r\n.divAsset\r\n{\r\n    background-color:#c8c8c8;\r\n    width: 256px;\r\n    height: 96px; \r\n    overflow: hidden;\r\n    padding: 16px;\r\n    margin-top: 8px;\r\n    margin-left: 8px;\r\n}\r\n.inputThumbnail\r\n{\r\n    cursor: pointer;\r\n    border: 0px;\r\n    margin: 0px;    \r\n    padding: 0px;\r\n    border-radius: 4px;\r\n    width: 96px;\r\n    height: 96px;\r\n}\r\n.inputInfoColumn\r\n{\r\n    vertical-align: top;\r\n    padding-left:8px;\r\n}\r\n\r\n.spanDescription\r\n{\r\n    //font-size: 1.5em;\r\n    white-space: pre;\r\n}\r\n\r\n.spanUser\r\n{\r\n}\r\n\r\n.uiButtonNew\r\n{\r\n    margin: 0px;\r\n    padding: 0px;\r\n    cursor: pointer;\r\n    border-radius: 4px;\r\n}\r\n.uiButtonNew:disabled\r\n{\r\n    color: #b0b0b0;\r\n    background-color: #808080;\r\n}\r\n\r\n.vcenter {\r\n    vertical-align: middle;\r\n    height: 100%;\r\n}\r\n\r\n.uiButtonNew:hover {\r\n    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;\r\n}\r\n\r\n/* ----------------------- media resolutions ------------------------ */\r\n\r\n@media screen and (max-width:799px) \r\n{\r\n    .container \r\n    {\r\n        grid-template-columns: 1fr;\r\n    }\r\n    .block1\r\n    {\r\n        grid-row: span 1;\r\n    }\r\n    div#editor { height: 480px }\r\n\r\n    div#textures {\r\n        grid-template-columns: 1fr 1fr;\r\n        grid-template-rows: 1fr 1fr;\r\n    }\r\n\r\n    .shaderInfoA {\r\n        display: grid;\r\n        grid-template-columns: 1fr;\r\n        grid-template-rows: 1fr 1fr 1fr 1fr;\r\n    }\r\n\r\n    .shaderInfoA \u003e :nth-child(2),\r\n    .shaderInfoA \u003e :nth-child(4) {\r\n        text-align: left;\r\n    }\r\n\r\n    div#noWebGL { height: 281px; }\r\n    div#editorHeader.expanded { height: 120px; }\r\n    div#dlgAddToPlaylist { left:0%;top:30%; }\r\n    div#dlgShareShader { width:360px; height:240px; left:0%;top:30%; }\r\n    div#dlgBBCodeHelp { width:360px; height:420px; left:0%;top:30%; }\r\n    div#dlgAlertShader { left:0%;top:30%; }\r\n    div#dlgHelp { width:360px; height:360px; left:0%;top:30%; }\r\n    div#pickTexture_image { width:360px; height:460px; left:0%;top:20%; }\r\n    .divAsset { width: 170px; height: 64px;  padding: 6px; margin-top: 6px; margin-left: 6px; }\r\n    .inputThumbnail { border-radius: 3px; width: 64px; height: 64px; }\r\n    .inputInfoColumn { padding-left:4px; }\r\n    .mySoundCloudURLBox { width:84px; height:60px; }\r\n    .mySoundCloudURL {width:74px; }\r\n    div#passManager { height: 22px; }\r\n    .tabAddContainer { padding:3px; height:16px; }\r\n    .tab { margin: 0px; margin-right: 4px; width:70px; height:22px; bottom:0px; }\r\n    .tab label { left:22px; top:6px; }\r\n    .tab img.tabImage { left:3px; top:4px; }\r\n    .tab img.tabClose { right:5px; top:7px; }\r\n}\r\n@media screen and (min-width:800px) and (max-width:1279px) \r\n{\r\n    div#editor { height: calc(max(300px,100vh - 300px)); }\r\n    div#editor.expanded { height: calc(max(300px, 100vh - 300px - 150px + 16px)); }\r\n    .container { grid-template-columns: 420px auto; }\r\n    div#noWebGL { height: 236px; }\r\n    div#editorHeader.expanded { height: 150px; }\r\n    div#dlgAddToPlaylist { left:30%;top:30%; }\r\n    div#dlgShareShader { width:480px; height:240px; left:30%;top:30%; }\r\n    div#dlgBBCodeHelp { width:640px; height:420px; left:25%;top:30%; }\r\n    div#dlgAlertShader {  left:30%;top:30%; }\r\n    div#dlgHelp { width:720px; height:450px; left:30%;top:30%; }\r\n    div#pickTexture_image { width:700px; height:500px; left:30%;top:20%; }\r\n    .divAsset { width: 180px; height: 70px;  padding: 8px; margin-top: 6px; margin-left: 6px; }\r\n    .inputThumbnail { border-radius: 3px; width: 70px; height: 70px; }\r\n    .inputInfoColumn { padding-left:4px; }\r\n    .mySoundCloudURLBox { width:90px; height:66px; }\r\n    .mySoundCloudURL {width:80px; }\r\n    .tab { margin: 0px; margin-right: 4px; width:90px; height:28px; bottom:0px; }\r\n    .tab label { left:22px; top:6px; }\r\n    .tab img.tabImage { left:3px; top:6px; }\r\n    .tab img.tabClose { right:7px; top:9px; }\r\n}\r\n\r\n@media screen and (min-width:1280px) and (max-width:1439px) \r\n{\r\n    div#editor { height: calc(max(300px,100vh - 310px)); }\r\n    div#editor.expanded { height: calc(max(300px, 100vh - 310px - 150px + 16px)); background-color: #ff0000; }\r\n    .container { grid-template-columns: 512px auto; }\r\n    div#noWebGL { height: 288px; }\r\n    div#editorHeader.expanded { height: 150px; }\r\n    div#dlgAddToPlaylist { left:30%;top:30%; }\r\n    div#dlgShareShader { width:480px; height:240px; left:30%;top:30%; }\r\n    div#dlgBBCodeHelp { width:640px; height:420px; left:25%;top:30%; }\r\n    div#dlgAlertShader {  left:30%;top:30%; }\r\n    div#dlgHelp { width:720px; height:450px; left:30%;top:30%; }\r\n    div#pickTexture_image { width:700px; height:500px; left:30%;top:20%; }\r\n    .divAsset { width: 180px; height: 70px;  padding: 8px; margin-top: 6px; margin-left: 6px; }\r\n    .inputThumbnail { border-radius: 3px; width: 70px; height: 70px; }\r\n    .inputInfoColumn { padding-left:4px; }\r\n    .mySoundCloudURLBox { width:90px; height:66px; }\r\n    .mySoundCloudURL {width:80px; }\r\n    .tab { margin: 0px; margin-right: 4px; width:90px; height:28px; bottom:0px; }\r\n    .tab label { left:22px; top:6px; }\r\n    .tab img.tabImage { left:3px; top:6px; }\r\n    .tab img.tabClose { right:7px; top:9px; }\r\n}\r\n\r\n@media screen and (min-width:1440px) and (max-width:1919px) \r\n{\r\n    div#editor { height: calc(max(300px, 100vh - 350px)); }\r\n    div#editor.expanded { height: calc(max(300px, 100vh - 350px - 162px + 16px)); background-color: #ff0000; }\r\n    .container { grid-template-columns: 640px auto; }\r\n    div#noWebGL { height: 360px; }\r\n    div#editorHeader.expanded { height: 162px; }\r\n    div#dlgAddToPlaylist { left:30%;top:30%; }\r\n    div#dlgShareShader { width:540px; height:280px; left:30%;top:30%; }\r\n    div#dlgBBCodeHelp { width:640px; height:420px; left:25%;top:30%; }\r\n    div#dlgAlertShader {  left:30%;top:30%; }\r\n    div#dlgHelp { width:800px; height:450px; left:30%;top:30%; }\r\n    div#pickTexture_image { width:720px; height:500px; left:30%;top:20%; }\r\n    .divAsset { width: 192px; height: 70px;  padding: 8px; margin-top: 6px; margin-left: 6px; }\r\n    .inputThumbnail { border-radius: 3px; width: 70px; height: 70px; }\r\n    .inputInfoColumn { padding-left:4px; }\r\n    .mySoundCloudURLBox { width:100px; height:66px; }\r\n    .mySoundCloudURL {width:90px; }\r\n    div#passManager { height: 28px; }\r\n    .tab { margin: 0px; margin-right: 4px; width:100px; height:28px; bottom:0px; }\r\n    .tab label { left:24px; top:6px; }\r\n    .tab img.tabImage { left:3px; top:6px; }\r\n    .tab img.tabClose { right:8px; top:9px; }\r\n}\r\n\r\n@media screen and (min-width:1920px) and (max-width:2559px) \r\n{\r\n    div#editor { height: calc(max(400px, 100vh - 360px)); }\r\n    div#editor.expanded { height: calc(max(400px, 100vh - 360px - 162px + 16px)); background-color: #ff0000; }\r\n    .container { grid-template-columns: 800px auto; }\r\n    div#noWebGL { height: 450px; }\r\n    div#editorHeader.expanded { height: 162px; }\r\n    div#dlgAddToPlaylist { left:30%;top:30%; }\r\n    div#dlgAlertShader {  left:30%;top:30%; }\r\n    div#dlgShareShader { width:540px; height:280px; left:30%;top:30%; }\r\n    div#dlgBBCodeHelp { width:720px; height:490px; left:30%;top:30%; }\r\n    div#dlgHelp { width:800px; height:450px; left:30%;top:30%; }\r\n    div#pickTexture_image { width:960px; height:620px; left:30%;top:20%; }\r\n    .divAsset { width: 256px; height: 96px;  padding: 16px; margin-top: 8px; margin-left: 8px; }\r\n    .inputThumbnail { border-radius: 4px; width: 96px; height: 96px; }\r\n    .inputInfoColumn { padding-left:8px; }\r\n    .mySoundCloudURLBox { width:136px; height:92px; }\r\n    .mySoundCloudURL {width:126px; }\r\n}\r\n\r\n@media screen and (min-width:2560px) \r\n{\r\n    div#editor { height: calc(max(480px,100vh - 380px)); }\r\n    div#editor.expanded { height: calc(max(480px, 100vh - 380px - 236px + 16px)); background-color: #ff0000; }\r\n    .container { grid-template-columns: 1200px auto; }\r\n    div#noWebGL { height: 675px; }\r\n    div#editorHeader.expanded { height: 236px; }\r\n    div#dlgAddToPlaylist { left:30%;top:30%; }\r\n    div#dlgAlertShader {  left:30%;top:30%; }\r\n    div#dlgShareShader { width:540px; height:280px; left:30%;top:30%; }\r\n    div#dlgBBCodeHelp { width:720px; height:490px; left:30%;top:30%; }\r\n    div#dlgHelp { width:800px; height:450px; left:30%;top:30%; }\r\n    div#pickTexture_image { width:960px; height:620px; left:30%;top:20%; }\r\n    .divAsset { width: 256px; height: 96px;  padding: 16px; margin-top: 8px; margin-left: 8px; }\r\n    .inputThumbnail { border-radius: 4px; width: 96px; height: 96px; }\r\n    .inputInfoColumn { padding-left:8px; }\r\n    .mySoundCloudURLBox { width:136px; height:92px; }\r\n    .mySoundCloudURL {width:126px; }\r\n    .tabAddContainer { padding:4px; }\r\n    .tab { margin: 0px; margin-left: 4px; margin-right: 4px; width:128px; bottom:0px; }\r\n    .tab label { left:24px; top:6px; }\r\n    .tab img.tabImage { left:3px; top:6px; }\r\n    .tab img.tabClose { right:8px; top:9px; }\r\n    div#toolBar { height: 32px; }\r\n}\r\n\u003c/style\u003e\r\n\r\n        \u003cmeta property=\"og:image\" content=\"https://www.shadertoy.com/media/shaders/4cfcDX.jpg\" /\u003e\n    \u003cmeta property=\"og:title\" content=\"Shadertoy\" /\u003e\n    \r\n    \u003cscript\u003e\r\n    var gThemeName = \"classic\";\nvar gFontSize = \"0\";\nvar gStrWantDeletePass = \"Do you want to delete the pass?\";\nvar gStrFork = \"Forked from\";\nvar gStrForkDeleted = \"Forked from a shader that was deleted.\";\n    function doSaveShader() { openSubmitShaderForm(true); }\n    var gUserName = 'Mick';\n    var gShaderID = \"4cfcDX\";\n    var gIsMyShader = true;\n    \u003c/script\u003e\r\n\r\n    \u003cscript\u003e\"use strict\"\r\n\r\n//==============================================================================\r\n//\r\n// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm\r\n//\r\n// piCamera\r\n//\r\n//==============================================================================\r\n\r\nfunction piCamera()\r\n{\r\n    var mMatrix = setIdentity();\r\n    var mMatrixInv = setIdentity();\r\n\r\n    var mPosition = [0.0,0.0,0.0];\r\n    var mXRotation = 0.0;\r\n    var mYRotation = 0.0;\r\n\r\n    var mPositionTarget = [0.0,0.0,0.0];\r\n    var mXRotationTarget = 0.0;\r\n    var mYRotationTarget = 0.0;\r\n\r\n    var me = {};\r\n/*\r\n    me.Set = function( pos, dir, roll) \r\n             {\r\n                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );\r\n                 mMatrixInv = invertFast( mMatrix );\r\n             };\r\n*/\r\n    me.SetPos = function(pos)\r\n                {\r\n                    mPosition = pos;\r\n                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);\r\n                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);\r\n                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);\r\n                };\r\n/*\r\n    me.GlobalMove = function(pos)\r\n                    {\r\n                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);\r\n                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);\r\n                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);\r\n                        mMatrixInv = invertFast(mMatrix);\r\n                    };\r\n*/\r\n    me.LocalMove = function( dis )\r\n                    {\r\n                        dis = matMulvec( setRotationY(-mYRotation), dis);\r\n                        mPositionTarget = sub(mPositionTarget,dis)\r\n                    };\r\n\r\n    me.RotateXY = function( x, y)\r\n                  {\r\n                    mXRotationTarget -= x;\r\n                    mYRotationTarget -= y;\r\n                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );\r\n                  };\r\n\r\n\r\n    me.CameraExectue = function( dt )\r\n    {\r\n        // smooth position\r\n        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;\r\n        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;\r\n        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));\r\n\r\n        // Make Camera matrix\r\n        mMatrix = matMul( matMul(setRotationX(mXRotation), \r\n                                 setRotationY(mYRotation)),  \r\n                                 setTranslation(mPosition));\r\n        mMatrixInv = invertFast(mMatrix);\r\n\r\n    }\r\n\r\n    me.GetMatrix = function() { return mMatrix; };\r\n    me.GetMatrixInverse = function() { return mMatrixInv; };\r\n    me.SetMatrix = function( mat ) \r\n                    {\r\n                        mMatrix = mat;\r\n                        mMatrixInv = invertFast(mMatrix);\r\n\r\n                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));\r\n                        mPositionTarget = mPosition;\r\n                    };\r\n\r\n    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }\r\n    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }\r\n\r\n    return me;\r\n}\r\n//==============================================================================\r\n//\r\n// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm\r\n//\r\n// piFile\r\n//\r\n//==============================================================================\r\n\r\nfunction piFile( binaryDataArrayBuffer )\r\n{\r\n    // private\r\n    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );\r\n    var mDataView = binaryDataArrayBuffer;\r\n    var mOffset = 0;\r\n\r\n    // public members\r\n    var me = {};\r\n    me.mDummy = 0;\r\n/*\r\n    // public functions\r\n    me.Seek = function( off ) { mOffset = off - 3; };\r\n    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };\r\n    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };\r\n    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()\u003c\u003c32); };\r\n    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };\r\n*/\r\n\r\n    me.Seek = function( off ) { mOffset = off; };\r\n    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };\r\n    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };\r\n    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };\r\n    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()\u003c\u003c32); };\r\n    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };\r\n    me.ReadFloat32Array = function(n) \r\n                          { \r\n                              var src = new Float32Array(mDataView, mOffset);\r\n                              var res = [];  for( var i=0; i\u003cn; i++ ) { res[i] = src[i]; }\r\n                              mOffset += 4*n;\r\n                              return res;\r\n                          };\r\n    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };\r\n    return me;\r\n}\r\n//==============================================================================\r\n//\r\n// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm\r\n//\r\n// piMesh\r\n//\r\n//==============================================================================\r\n\r\nfunction piMesh()\r\n{\r\n    this.mChunks = [];\r\n    this.mPrimitiveType = 0;\r\n    this.mVertexFormat = null;\r\n}\r\n\r\n/*\r\npiMesh.prototype.normalize = function( ppos, npos )\r\n{\r\n    var numv = this.mVertexData.length;\r\n    var numt = this.mIndices.length;\r\n\r\n    for( var i=0; i\u003cnumv; i++ )\r\n    {\r\n        //float *v = (float*)piMesh_GetVertexData( me, i, npos );\r\n        //v[0] = 0.0f;\r\n        //v[1] = 0.0f;\r\n        //v[2] = 0.0f;\r\n        this.mVerts[8 * i + 3] = 0.0;\r\n        this.mVerts[8 * i + 4] = 0.0;\r\n        this.mVerts[8 * i + 5] = 0.0;\r\n    }\r\n\r\n    for( var i=0; i\u003cnumt; i++ )\r\n    {\r\n        piMeshFace *face = me-\u003emFaceData.mIndexArray[0].mBuffer + i;\r\n\r\n        const int ft = face-\u003emNum;\r\n        \r\n        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );\r\n        for( int j=0; j\u003cft; j++ )\r\n        {\r\n            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face-\u003emIndex[ j      ], ppos ));\r\n            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face-\u003emIndex[(j+1)%ft], ppos ));\r\n\r\n            nor += cross( va, vb );\r\n        }\r\n\r\n        for( int j=0; j\u003cft; j++ )\r\n        {\r\n            vec3 *n = (vec3*)piMesh_GetVertexData( me, face-\u003emIndex[j], npos );\r\n            n-\u003ex += nor.x;\r\n            n-\u003ey += nor.y;\r\n            n-\u003ez += nor.z;\r\n        }\r\n    }\r\n\r\n    for( var i=0; i\u003cnumv; i++ )\r\n    {\r\n        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );\r\n        *v = normalize( *v );\r\n    }\r\n}\r\n*/\r\n\r\npiMesh.prototype.createCube = function(renderer)\r\n{\r\n    this.mPrimitiveType = 0;\r\n\r\n    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,\r\n                                       1.0, -1.0, -1.0,\r\n                                      -1.0,  1.0, -1.0,\r\n                                       1.0,  1.0, -1.0,\r\n                                      -1.0, -1.0,  1.0,\r\n                                       1.0, -1.0,  1.0,\r\n                                      -1.0,  1.0,  1.0,\r\n                                       1.0,  1.0,  1.0 ]),\r\n\r\n                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),\r\n                        mNumVertices : 8,\r\n                        mNumFaces : 12, \r\n                        mTransform : setIdentity(),\r\n                        mVBO : null, \r\n                        mIBO : null };\r\n\r\n    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };\r\n\r\n    return true;\r\n}\r\n\r\npiMesh.prototype.createCubeSharp = function (renderer)\r\n{\r\n    this.mPrimitiveType = 0;\r\n\r\n    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,\r\n                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,\r\n                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,\r\n                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,\r\n\r\n                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,\r\n                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,\r\n                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,\r\n                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,\r\n\r\n                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,\r\n                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,\r\n                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,\r\n                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,\r\n\r\n                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,\r\n                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,\r\n                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,\r\n                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,\r\n\r\n                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,\r\n                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,\r\n                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,\r\n                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,\r\n\r\n                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,\r\n                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,\r\n                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,\r\n                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),\r\n\r\n                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),\r\n                        mNumVertices : 24,\r\n                        mNumFaces : 12, \r\n                        mTransform : setIdentity(),\r\n                        mVBO : null, \r\n                        mIBO : null };\r\n\r\n\r\n    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },\r\n                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },\r\n                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };\r\n\r\n    return true;\r\n}\r\n\r\n\r\npiMesh.prototype.createUnitQuad = function (renderer)\r\n{\r\n    this.mPrimitiveType = 0;\r\n    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };\r\n\r\n    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),\r\n                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),\r\n                        mNumVertices : 4,\r\n                        mNumFaces : 2, \r\n                        mTransform : setIdentity(),\r\n                        mVBO : null, \r\n                        mIBO : null };\r\n \r\n    return true;\r\n}\r\n\r\n\r\n\r\n\r\npiMesh.prototype.destroy = function()\r\n{\r\n    //delete this.mVerts;   this.mVerts = null;\r\n    //delete this.mIndices; this.mIndices = null;\r\n}\r\n\r\npiMesh.prototype.scale = function (x, y, z)\r\n{\r\n    var stride = this.mVertexFormat.mStride/4;\r\n    for( var j=0; j\u003cthis.mChunks.length; j++ )\r\n    {\r\n        var nv = this.mChunks[j].mNumVertices;\r\n        for (var i = 0; i \u003c nv; i++) \r\n        {\r\n            this.mChunks[j].mVerts[stride * i + 0] *= x;\r\n            this.mChunks[j].mVerts[stride * i + 1] *= y;\r\n            this.mChunks[j].mVerts[stride * i + 2] *= z;\r\n        }\r\n    }\r\n}\r\n\r\npiMesh.prototype.translate = function (x, y, z) \r\n{\r\n    var stride = this.mVertexFormat.mStride/4;\r\n    for( var j=0; j\u003cthis.mChunks.length; j++ )\r\n    {\r\n        var nv = this.mChunks[j].mNumVertices;\r\n        for (var i = 0; i \u003c nv; i++) \r\n        {\r\n            this.mChunks[j].mVerts[stride * i + 0] += x;\r\n            this.mChunks[j].mVerts[stride * i + 1] += y;\r\n            this.mChunks[j].mVerts[stride * i + 2] += z;\r\n        }\r\n    }\r\n}\r\n\r\npiMesh.prototype.GPULoad = function (renderer)\r\n{\r\n    for( var i=0; i\u003cthis.mChunks.length; i++ )\r\n    {\r\n        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );\r\n        if (vbo == null)\r\n            return false;\r\n\r\n        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);\r\n        if (ibo == null)\r\n            return false;\r\n\r\n        this.mChunks[i].mVBO = vbo;\r\n        this.mChunks[i].mIBO = ibo;\r\n    }\r\n    return true;\r\n}\r\n\r\npiMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )\r\n{\r\n    //renderer.SetShaderConstantMat4F(\"unMPrj\", matPrj, false );\r\n\r\n    var num = this.mChunks.length;\r\n    for( var i=0; i\u003cnum; i++ )\r\n    {\r\n        //var mat =  matMul( matCam, this.mChunks[i].mTransform );\r\n        //renderer.SetShaderConstantMat4F(\"unMMod\", mat, false);\r\n\r\n        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );\r\n        renderer.AttachIndexArray(this.mChunks[i].mIBO );\r\n        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);\r\n        renderer.DetachIndexArray(this.mChunks[i].mIBO);\r\n        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );\r\n    }\r\n}\r\n//==============================================================================\r\n//\r\n// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm\r\n//\r\n// piRenderer\r\n//\r\n//==============================================================================\r\n\r\nfunction piRenderer()\r\n{\r\n    // private members\r\n\r\n    var mGL = null;\r\n    var mBindedShader = null;\r\n    var mIs20 = false;\r\n    var mFloat32Textures;\r\n    var mFloat32Filter;\r\n    var mFloat16Textures;\r\n    var mDrawBuffers;\r\n    var mDepthTextures;\r\n    var mDerivatives;\r\n    var mFloat16Filter;\r\n    var mShaderTextureLOD;\r\n    var mAnisotropic;\r\n    var mRenderToFloat32F;\r\n    var mDebugShader;\r\n    var mAsynchCompile;\r\n\r\n    var mVBO_Quad = null;\r\n    var mVBO_Tri = null;\r\n    var mVBO_CubePosNor = null;\r\n    var mVBO_CubePos = null;\r\n    var mShaderHeader = [\"\",\"\"];\r\n    var mShaderHeaderLines = [0,0];\r\n\r\n    // public members\r\n    var me = {};\r\n\r\n    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };\r\n    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };\r\n    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };\r\n    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };\r\n    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };\r\n    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };\r\n    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };\r\n    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };\r\n    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };\r\n\r\n    // private functions\r\n\r\n    var iFormatPI2GL = function( format )\r\n    {\r\n        if( mIs20 )\r\n        {\r\n             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }\r\n        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }\r\n        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }\r\n        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }\r\n        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }\r\n        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }\r\n        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }\r\n        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }\r\n        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }\r\n        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }\r\n        }\r\n        else\r\n        {\r\n             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }\r\n        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }\r\n        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }\r\n        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }\r\n        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }\r\n        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }\r\n        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }\r\n        }\r\n\r\n        return null;\r\n     }\r\n\r\n    // public functions\r\n\r\n    me.Initialize = function( gl )\r\n                    {\r\n                        mGL = gl;\r\n\r\n                        mIs20 = !(gl instanceof WebGLRenderingContext);\r\n\r\n                        if( mIs20 )\r\n                        {\r\n                            mFloat32Textures  = true;\r\n                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');\r\n                            mFloat16Textures  = true;\r\n                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );\r\n                            mDerivatives      = true;\r\n                            mDrawBuffers      = true;\r\n                            mDepthTextures    = true;\r\n                            mShaderTextureLOD = true;\r\n                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );\r\n                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');\r\n                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');\r\n                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');\r\n\r\n\t\t\t\t\t\t\tmGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);\r\n                        }\r\n                        else\r\n                        {\r\n                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );\r\n                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');\r\n                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );\r\n                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );\r\n                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );\r\n                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );\r\n                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );\r\n                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );\r\n                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );\r\n                            mRenderToFloat32F = mFloat32Textures;\r\n                            mDebugShader      = null;\r\n                            mAsynchCompile    = null;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);\r\n                        }\r\n                        \r\n                        \r\n                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );\r\n                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );\r\n                        var extensions = mGL.getSupportedExtensions();\r\n                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );\r\n                        console.log(\"WebGL (2.0=\" + mIs20 + \"):\" +\r\n                                    \" Asynch Compile: \"  + ((mAsynchCompile !==null) ? \"yes\" : \"no\") +\r\n                                    \", Textures: F32 [\"   + ((mFloat32Textures !==null) ? \"yes\" : \"no\") +\r\n                                    \"], F16 [\"   + ((mFloat16Textures !==null) ? \"yes\" : \"no\") +\r\n                                    \"], Depth [\" + ((mDepthTextures   !==null) ? \"yes\" : \"no\") +\r\n                                    \"], LOD [\"    + ((mShaderTextureLOD!==null) ? \"yes\" : \"no\") +\r\n                                    \"], Aniso [\"   + ((mAnisotropic     !==null) ? \"yes\" : \"no\") +\r\n                                    \"], Units [\" + textureUnits +\r\n                                    \"], Max Size [\" + maxTexSize +\r\n                                    \"], Cube Max Size [\" + maxCubeSize +\r\n                                    \"], Targets: MRT [\"            + ((mDrawBuffers     !==null) ? \"yes\" : \"no\") +\r\n                                    \"], F32 [\"     + ((mRenderToFloat32F!==null) ? \"yes\" : \"no\") +\r\n                                    \"], Max Size [\" + maxRenderbufferSize + \"]\");\r\n\r\n                        // create a 2D quad Vertex Buffer\r\n                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );\r\n                        mVBO_Quad = mGL.createBuffer();\r\n                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );\r\n                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );\r\n                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );\r\n\r\n                        // create a 2D triangle Vertex Buffer\r\n                        mVBO_Tri = mGL.createBuffer();\r\n                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );\r\n                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );\r\n                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );\r\n\r\n                        // create a 3D cube Vertex Buffer\r\n                        mVBO_CubePosNor = mGL.createBuffer();\r\n                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );\r\n                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,\r\n                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,\r\n                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,\r\n                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,\r\n                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,\r\n                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,\r\n                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,\r\n                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,\r\n                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,\r\n                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,\r\n                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,\r\n                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,\r\n                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,\r\n                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,\r\n                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,\r\n                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,\r\n                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,\r\n                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,\r\n                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,\r\n                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,\r\n                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,\r\n                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,\r\n                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,\r\n                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );\r\n                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );\r\n\r\n                        // create a 3D cube Vertex Buffer\r\n                        mVBO_CubePos = mGL.createBuffer();\r\n                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );\r\n                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,\r\n                                                                              -1.0, -1.0,  1.0,\r\n                                                                              -1.0,  1.0, -1.0,\r\n                                                                              -1.0,  1.0,  1.0,\r\n                                                                               1.0,  1.0, -1.0,\r\n                                                                               1.0,  1.0,  1.0,\r\n                                                                               1.0, -1.0, -1.0,\r\n                                                                               1.0, -1.0,  1.0,\r\n                                                                               1.0,  1.0,  1.0,\r\n                                                                               1.0,  1.0, -1.0,\r\n                                                                              -1.0,  1.0,  1.0,\r\n                                                                              -1.0,  1.0, -1.0,\r\n                                                                               1.0, -1.0, -1.0,\r\n                                                                               1.0, -1.0,  1.0,\r\n                                                                              -1.0, -1.0, -1.0,\r\n                                                                              -1.0, -1.0,  1.0,\r\n                                                                              -1.0,  1.0,  1.0,\r\n                                                                              -1.0, -1.0,  1.0,\r\n                                                                               1.0,  1.0,  1.0,\r\n                                                                               1.0, -1.0,  1.0,\r\n                                                                              -1.0, -1.0, -1.0,\r\n                                                                              -1.0,  1.0, -1.0,\r\n                                                                               1.0, -1.0, -1.0,\r\n                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );\r\n                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );\r\n\r\n                        //-------------------------------------------------------------------\r\n\r\n                        mShaderHeader[0] = \"\";\r\n                        mShaderHeaderLines[0] = 0;\r\n                        if( mIs20 ) \r\n                        { \r\n                            mShaderHeader[0] += \"#version 300 es\\n\" +\r\n                                                \"#ifdef GL_ES\\n\"+\r\n                                                \"precision highp float;\\n\" +\r\n                                                \"precision highp int;\\n\"+\r\n                                                \"precision mediump sampler3D;\\n\"+\r\n                                                \"#endif\\n\"; \r\n                            mShaderHeaderLines[0] += 6;\r\n                        }\r\n                        else\r\n                        {\r\n                            mShaderHeader[0] += \"#ifdef GL_ES\\n\"+\r\n                                                \"precision highp float;\\n\" +\r\n                                                \"precision highp int;\\n\"+\r\n                                                \"#endif\\n\"+\r\n                                                \"float round( float x ) { return floor(x+0.5); }\\n\"+\r\n                                                \"vec2 round(vec2 x) { return floor(x + 0.5); }\\n\"+\r\n                                                \"vec3 round(vec3 x) { return floor(x + 0.5); }\\n\"+\r\n                                                \"vec4 round(vec4 x) { return floor(x + 0.5); }\\n\"+\r\n                                                \"float trunc( float x, float n ) { return floor(x*n)/n; }\\n\"+\r\n                                                \"mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\\n\"+\r\n                                                \"float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\\n\"+\r\n                                                \"float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\\n\"+\r\n                                                \"mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\\n\"+\r\n                                                \"mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\\n\"+                                                \r\n                                                \"float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\\n\"+\r\n                                                \"float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\\n\"+\r\n                                                \"float tanh(float x)  { return sinh(x)/cosh(x); }\\n\"+\r\n                                                \"float coth(float x)  { return cosh(x)/sinh(x); }\\n\"+\r\n                                                \"float sech(float x)  { return 1./cosh(x); }\\n\"+\r\n                                                \"float csch(float x)  { return 1./sinh(x); }\\n\"+\r\n                                                \"float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\\n\"+\r\n                                                \"float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\\n\"+\r\n                                                \"float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\\n\"+\r\n                                                \"float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\\n\"+\r\n                                                \"float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\\n\"+\r\n                                                \"float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\\n\";\r\n                            mShaderHeaderLines[0] += 26;\r\n                        }\r\n\r\n                        //-------------------------------------------------------\r\n\r\n                        mShaderHeader[1] = \"\";\r\n                        mShaderHeaderLines[1] = 0;\r\n                        if( mIs20 ) \r\n                        { \r\n                            mShaderHeader[1] += \"#version 300 es\\n\"+\r\n                                                \"#ifdef GL_ES\\n\"+\r\n                                                \"precision highp float;\\n\"+\r\n                                                \"precision highp int;\\n\"+\r\n                                                \"precision mediump sampler3D;\\n\"+\r\n                                                \"#endif\\n\"; \r\n                            mShaderHeaderLines[1] += 6;\r\n                        }\r\n                        else\r\n                        {\r\n                            if( mDerivatives ) { mShaderHeader[1] += \"#ifdef GL_OES_standard_derivatives\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\n\"; mShaderHeaderLines[1]+=3; }\r\n                            if( mShaderTextureLOD  ) { mShaderHeader[1] += \"#extension GL_EXT_shader_texture_lod : enable\\n\"; mShaderHeaderLines[1]++; }\r\n                            mShaderHeader[1] += \"#ifdef GL_ES\\n\"+\r\n                                                \"precision highp float;\\n\"+\r\n                                                \"precision highp int;\\n\"+\r\n                                                \"#endif\\n\"+ \r\n                                                \"vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\\n\"+\r\n                                                \"vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\\n\"+\r\n                                                \"vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\\n\"+\r\n                                                \"vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\\n\"+\r\n                                                \"float round( float x ) { return floor(x+0.5); }\\n\"+\r\n                                                \"vec2 round(vec2 x) { return floor(x + 0.5); }\\n\"+\r\n                                                \"vec3 round(vec3 x) { return floor(x + 0.5); }\\n\"+\r\n                                                \"vec4 round(vec4 x) { return floor(x + 0.5); }\\n\"+\r\n                                                \"float trunc( float x, float n ) { return floor(x*n)/n; }\\n\"+\r\n                                                \"mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\\n\"+\r\n                                                \"float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\\n\"+\r\n                                                \"float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\\n\"+\r\n                                                \"mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\\n\"+\r\n                                                \"mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\\n\"+\r\n                                                \"float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\\n\"+\r\n                                                \"float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\\n\"+\r\n                                                \"float tanh(float x)  { return sinh(x)/cosh(x); }\\n\"+\r\n                                                \"float coth(float x)  { return cosh(x)/sinh(x); }\\n\"+\r\n                                                \"float sech(float x)  { return 1./cosh(x); }\\n\"+\r\n                                                \"float csch(float x)  { return 1./sinh(x); }\\n\"+\r\n                                                \"float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\\n\"+\r\n                                                \"float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\\n\"+\r\n                                                \"float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\\n\"+\r\n                                                \"float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\\n\"+\r\n                                                \"float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\\n\"+\r\n                                                \"float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\\n\";\r\n                            mShaderHeaderLines[1] += 30;\r\n                            if( mShaderTextureLOD )\r\n                            {\r\n                            mShaderHeader[1] += \"vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\\n\";\r\n                            mShaderHeader[1] += \"vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\\n\";\r\n                            mShaderHeaderLines[1] += 2;\r\n\r\n                            //mShaderHeader[1] += \"vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\\n\";\r\n                            //mShaderHeaderLines[1] += 1;\r\n                            }\r\n                        }\r\n\r\n                        return true;\r\n                    };\r\n\r\n        me.GetCaps =    function ()\r\n                        {   \r\n                            return { mIsGL20 : mIs20,\r\n                                     mFloat32Textures: mFloat32Textures != null,\r\n                                     mFloat16Textures: mFloat16Textures != null,\r\n                                     mDrawBuffers: mDrawBuffers != null,\r\n                                     mDepthTextures: mDepthTextures != null,\r\n                                     mDerivatives: mDerivatives != null,\r\n                                     mShaderTextureLOD: mShaderTextureLOD != null };\r\n                        };\r\n\r\n        me.GetShaderHeaderLines = function (shaderType)\r\n                        {   \r\n                            return mShaderHeaderLines[shaderType];\r\n                        };\r\n\r\n        me.CheckErrors = function()\r\n                         {\r\n                                var error = mGL.getError();\r\n                                if( error != mGL.NO_ERROR ) \r\n                                { \r\n                                    for( var prop in mGL ) \r\n                                    {\r\n                                        if( typeof mGL[prop] == 'number' ) \r\n                                        {\r\n                                            if( mGL[prop] == error )\r\n                                            {\r\n                                                console.log( \"GL Error \" + error + \": \" + prop );\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                         };\r\n\r\n        me.Clear =  function( flags, ccolor, cdepth, cstencil )\r\n                    {\r\n                        var mode = 0;\r\n                        if( flags \u0026 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }\r\n                        if( flags \u0026 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }\r\n                        if( flags \u0026 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }\r\n                        mGL.clear( mode );\r\n                    };\r\n\r\n\r\n        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)\r\n                           {\r\n                                if( mGL===null ) return null;\r\n\r\n                                var id = mGL.createTexture();\r\n\r\n                                var glFoTy = iFormatPI2GL( format );\r\n                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;\r\n\r\n                                if( type===me.TEXTYPE.T2D )\r\n                                {\r\n                                    mGL.bindTexture( mGL.TEXTURE_2D, id );\r\n//if( buffer==null )\r\n    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);\r\n//else\r\n                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );\r\n                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );\r\n                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );\r\n\r\n                                    if (filter === me.FILTER.NONE)\r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);\r\n                                    }\r\n                                    else if (filter === me.FILTER.LINEAR)\r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);\r\n                                    }\r\n                                    else if (filter === me.FILTER.MIPMAP)\r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);\r\n                                        mGL.generateMipmap(mGL.TEXTURE_2D);\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);\r\n                                        mGL.generateMipmap(mGL.TEXTURE_2D);\r\n                                    }\r\n\r\n                                    mGL.bindTexture( mGL.TEXTURE_2D, null );\r\n                                }\r\n                                else if( type===me.TEXTYPE.T3D )\r\n                                {\r\n                                    if( mIs20 )\r\n                                    {\r\n                                        mGL.bindTexture( mGL.TEXTURE_3D, id );\r\n                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);\r\n                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));\r\n                                        if (filter === me.FILTER.NONE)\r\n                                        {\r\n                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);\r\n                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);\r\n                                        }\r\n                                        else if (filter === me.FILTER.LINEAR)\r\n                                        {\r\n                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);\r\n                                        }\r\n                                        else if (filter === me.FILTER.MIPMAP)\r\n                                        {\r\n                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);\r\n                                        }\r\n                                        else\r\n                                        {\r\n                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);\r\n                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);\r\n                                            mGL.generateMipmap(mGL.TEXTURE_3D);\r\n                                        }\r\n                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );\r\n\r\n                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );\r\n                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );\r\n                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );\r\n\r\n                                        if (filter === me.FILTER.MIPMAP)\r\n                                            mGL.generateMipmap( mGL.TEXTURE_3D );\r\n                                        mGL.bindTexture( mGL.TEXTURE_3D, null );\r\n                                    }\r\n                                    else \r\n                                    {\r\n                                        return null;\r\n                                    }\r\n                                }\r\n                                else \r\n                                {\r\n                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );\r\n\r\n                                    // this works great if we know the number of required mipmaps in advance (1, or other)\r\n                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );\r\n\r\n                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );\r\n                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );\r\n                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );\r\n                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );\r\n                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );\r\n                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );\r\n\r\n                                    if( filter === me.FILTER.NONE)\r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);\r\n                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);\r\n                                    }\r\n                                    else if (filter === me.FILTER.LINEAR)\r\n                                    {\r\n                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );\r\n                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );\r\n                                    }\r\n                                    else if (filter === me.FILTER.MIPMAP)\r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);\r\n                                    }\r\n\r\n                                    if (filter === me.FILTER.MIPMAP)\r\n                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );\r\n\r\n                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );\r\n                                }\r\n                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };\r\n                        };\r\n\r\n        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) \r\n                                {\r\n                                    if( mGL===null ) return null;\r\n\r\n                                    var id = mGL.createTexture();\r\n\r\n                                    var glFoTy = iFormatPI2GL( format );\r\n\r\n                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;\r\n\r\n                                    if( type===me.TEXTYPE.T2D )\r\n                                    {\r\n                                        mGL.bindTexture(mGL.TEXTURE_2D, id);\r\n\r\n                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);\r\n                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\r\n                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );\r\n\r\n                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);\r\n\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);\r\n\r\n                                        if (filter === me.FILTER.NONE)\r\n                                        {\r\n                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);\r\n                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);\r\n                                        }\r\n                                        else if (filter === me.FILTER.LINEAR)\r\n                                        {\r\n                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);\r\n                                        }\r\n                                        else if( filter === me.FILTER.MIPMAP)\r\n                                        {\r\n                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);\r\n                                            mGL.generateMipmap(mGL.TEXTURE_2D);\r\n                                        }\r\n                                        else\r\n                                        {\r\n                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);\r\n                                            mGL.generateMipmap(mGL.TEXTURE_2D);\r\n                                        }\r\n                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);\r\n                                        mGL.bindTexture(mGL.TEXTURE_2D, null);\r\n                                    }\r\n                                    else if( type===me.TEXTYPE.T3D )\r\n                                    {\r\n                                        return null;\r\n                                    }\r\n                                    else \r\n                                    {\r\n                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );\r\n                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);\r\n                                        mGL.activeTexture( mGL.TEXTURE0 );\r\n                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );\r\n                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );\r\n                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );\r\n                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );\r\n                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );\r\n                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );\r\n\r\n                                        if( filter === me.FILTER.NONE)\r\n                                        {\r\n                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);\r\n                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);\r\n                                        }\r\n                                        else if (filter === me.FILTER.LINEAR)\r\n                                        {\r\n                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );\r\n                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );\r\n                                        }\r\n                                        else if (filter === me.FILTER.MIPMAP)\r\n                                        {\r\n                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);\r\n                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );\r\n                                        }\r\n                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);\r\n                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );\r\n                                    }\r\n                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };\r\n                                };\r\n\r\n        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) \r\n                            {\r\n                                if (te.mFilter === filter) return;\r\n\r\n                                if (te.mType === me.TEXTYPE.T2D) \r\n                                {\r\n                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);\r\n\r\n                                    if (filter === me.FILTER.NONE) \r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);\r\n                                    }\r\n                                    else if (filter === me.FILTER.LINEAR) \r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);\r\n                                    }\r\n                                    else if (filter === me.FILTER.MIPMAP) \r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);\r\n                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);\r\n                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);\r\n                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);\r\n                                    }\r\n\r\n                                    mGL.bindTexture(mGL.TEXTURE_2D, null);\r\n\r\n                                }\r\n                                else if (te.mType === me.TEXTYPE.T3D) \r\n                                {\r\n                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);\r\n\r\n                                    if (filter === me.FILTER.NONE) \r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);\r\n                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);\r\n                                    }\r\n                                    else if (filter === me.FILTER.LINEAR) \r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);\r\n                                    }\r\n                                    else if (filter === me.FILTER.MIPMAP) \r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);\r\n                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);\r\n                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);\r\n                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);\r\n                                    }\r\n\r\n                                    mGL.bindTexture(mGL.TEXTURE_3D, null);\r\n\r\n                                }\r\n                                else\r\n                                {\r\n                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);\r\n\r\n                                    if (filter === me.FILTER.NONE) \r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);\r\n                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);\r\n                                    }\r\n                                    else if (filter === me.FILTER.LINEAR) \r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);\r\n                                    }\r\n                                    else if (filter === me.FILTER.MIPMAP) \r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);\r\n                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);\r\n                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);\r\n                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);\r\n                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);\r\n                                    }\r\n\r\n                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);\r\n                                }\r\n\r\n\r\n                                te.mFilter = filter;\r\n                            };\r\n\r\n        me.SetSamplerWrap = function (te, wrap)\r\n                            {\r\n                                if (te.mWrap === wrap) return;\r\n\r\n                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;\r\n\r\n                                var id = te.mObjectID;\r\n\r\n                                if (te.mType === me.TEXTYPE.T2D)\r\n                                {\r\n                                    mGL.bindTexture(mGL.TEXTURE_2D, id);\r\n                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);\r\n                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);\r\n                                    mGL.bindTexture(mGL.TEXTURE_2D, null);\r\n\r\n                                }\r\n                                else if (te.mType === me.TEXTYPE.T3D)\r\n                                {\r\n                                    mGL.bindTexture(mGL.TEXTURE_3D, id);\r\n                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);\r\n                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);\r\n                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);\r\n                                    mGL.bindTexture(mGL.TEXTURE_3D, null);\r\n                                }\r\n\r\n                                te.mWrap = wrap;\r\n                            };\r\n\r\n        me.SetSamplerVFlip = function (te, vflip, image)\r\n                            {\r\n                                if (te.mVFlip === vflip) return;\r\n\r\n                                var id = te.mObjectID;\r\n\r\n                                if (te.mType === me.TEXTYPE.T2D)\r\n                                {\r\n                                    if( image != null)\r\n                                    {\r\n                                        mGL.activeTexture( mGL.TEXTURE0 );\r\n                                        mGL.bindTexture(mGL.TEXTURE_2D, id);\r\n                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);\r\n                                        var glFoTy = iFormatPI2GL( te.mFormat );\r\n                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);\r\n                                        mGL.bindTexture(mGL.TEXTURE_2D, null);\r\n                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);\r\n                                    }\r\n                                }\r\n                                else if (te.mType === me.TEXTYPE.CUBEMAP)\r\n                                {\r\n                                    if( image != null)\r\n                                    {\r\n                                        var glFoTy = iFormatPI2GL( te.mFormat );\r\n                                        mGL.activeTexture( mGL.TEXTURE0 );\r\n                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );\r\n                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);\r\n                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );\r\n                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );\r\n                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );\r\n                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );\r\n                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );\r\n                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );\r\n                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );\r\n                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);\r\n                                    }\r\n        \r\n                                }\r\n\r\n                                te.mVFlip = vflip;\r\n                            };\r\n\r\n        me.CreateMipmaps =  function (te)\r\n                            {\r\n                                if( te.mType===me.TEXTYPE.T2D )\r\n                                {\r\n                                    mGL.activeTexture(mGL.TEXTURE0);\r\n                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);\r\n                                    mGL.generateMipmap(mGL.TEXTURE_2D);\r\n                                    mGL.bindTexture(mGL.TEXTURE_2D, null);\r\n                                }\r\n                                else if( te.mType===me.TEXTYPE.CUBEMAP )\r\n                                {\r\n                                    mGL.activeTexture(mGL.TEXTURE0);\r\n                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);\r\n                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );\r\n                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);\r\n                                }\r\n                            };\r\n\r\n        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )\r\n                            {\r\n                                var glFoTy = iFormatPI2GL( tex.mFormat );\r\n                                if( tex.mType===me.TEXTYPE.T2D )\r\n                                {\r\n                                    mGL.activeTexture( mGL.TEXTURE0);\r\n                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );\r\n                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );\r\n                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );\r\n                                    mGL.bindTexture( mGL.TEXTURE_2D, null );\r\n                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);\r\n                                }\r\n                            };\r\n\r\n        me.UpdateTextureFromImage = function( tex, image )\r\n                                {\r\n                                    var glFoTy = iFormatPI2GL( tex.mFormat );\r\n                                    if( tex.mType===me.TEXTYPE.T2D )\r\n                                    {\r\n                                        mGL.activeTexture( mGL.TEXTURE0 );\r\n                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );\r\n                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );\r\n                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );\r\n                                        mGL.bindTexture( mGL.TEXTURE_2D, null );\r\n                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);\r\n                                    }\r\n                                };\r\n\r\n        me.DestroyTexture = function( te )\r\n                            {\r\n                                 mGL.deleteTexture( te.mObjectID );\r\n                            };\r\n\r\n        me.AttachTextures = function (num, t0, t1, t2, t3) \r\n                            {\r\n                                if (num \u003e 0 \u0026\u0026 t0 != null) \r\n                                {\r\n                                    mGL.activeTexture(mGL.TEXTURE0);\r\n                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);\r\n                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);\r\n                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);\r\n                                }\r\n\r\n                                if (num \u003e 1 \u0026\u0026 t1 != null) \r\n                                {\r\n                                    mGL.activeTexture(mGL.TEXTURE1);\r\n                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);\r\n                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);\r\n                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);\r\n                                }\r\n\r\n                                if (num \u003e 2 \u0026\u0026 t2 != null) \r\n                                {\r\n                                    mGL.activeTexture(mGL.TEXTURE2);\r\n                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);\r\n                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);\r\n                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);\r\n                                }\r\n\r\n                                if (num \u003e 3 \u0026\u0026 t3 != null) \r\n                                {\r\n                                    mGL.activeTexture(mGL.TEXTURE3);\r\n                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);\r\n                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);\r\n                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);\r\n                                }\r\n                            };\r\n\r\n        me.DettachTextures = function()\r\n                             {\r\n                                mGL.activeTexture(mGL.TEXTURE0);\r\n                                mGL.bindTexture(mGL.TEXTURE_2D, null);\r\n                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);\r\n\r\n                                mGL.activeTexture(mGL.TEXTURE1);\r\n                                mGL.bindTexture(mGL.TEXTURE_2D, null);\r\n                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);\r\n\r\n                                mGL.activeTexture(mGL.TEXTURE2);\r\n                                mGL.bindTexture(mGL.TEXTURE_2D, null);\r\n                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);\r\n\r\n                                mGL.activeTexture(mGL.TEXTURE3);\r\n                                mGL.bindTexture(mGL.TEXTURE_2D, null);\r\n                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);\r\n                             };\r\n\r\n        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )\r\n                                {\r\n                                    var id =  mGL.createFramebuffer();\r\n                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);\r\n\r\n                                    if (depth === null)\r\n                                    {\r\n                                        if( wantZbuffer===true )\r\n                                        {\r\n                                            var zb = mGL.createRenderbuffer();\r\n                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);\r\n                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);\r\n\r\n                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);\r\n                                        }\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);\r\n                                    }\r\n\r\n                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);\r\n\r\n                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)\r\n                                        return null;\r\n\r\n                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);\r\n                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);\r\n                                    return { mObjectID: id, mTex0: color0 };\r\n                                };\r\n\r\n        me.DestroyRenderTarget = function ( tex )\r\n                                 {\r\n                                     mGL.deleteFramebuffer(tex.mObjectID);\r\n                                 };\r\n\r\n        me.SetRenderTarget = function (tex)\r\n                             {\r\n                                if( tex===null )\r\n                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);\r\n                                else\r\n                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);\r\n\r\n                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);\r\n                             };\r\n\r\n        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )\r\n                                {\r\n                                    var id =  mGL.createFramebuffer();\r\n                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);\r\n\r\n                                    if( wantZbuffer===true )\r\n                                    {\r\n                                        var zb = mGL.createRenderbuffer();\r\n                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);\r\n\r\n                                        if( samples==1 )\r\n                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);\r\n                                        else\r\n                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);\r\n                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);\r\n                                    }\r\n\r\n                                    if( wantColor0 )\r\n                                    {\r\n                                        var cb = mGL.createRenderbuffer();\r\n                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);\r\n                                        if( samples==1 )\r\n                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);\r\n                                        else\r\n                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);\r\n                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);\r\n                                    }\r\n\r\n                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)\r\n                                    {\r\n                                        return null;\r\n                                    }\r\n                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);\r\n                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);\r\n                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };\r\n                                };\r\n\r\n        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )\r\n                                {\r\n                                    var id =  mGL.createFramebuffer();\r\n                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);\r\n\r\n                                    if (depth === null)\r\n                                    {\r\n                                        if( wantZbuffer===true )\r\n                                        {\r\n                                            var zb = mGL.createRenderbuffer();\r\n                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);\r\n                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);\r\n                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);\r\n                                        }\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);\r\n                                    }\r\n\r\n                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);\r\n\r\n                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)\r\n                                        return null;\r\n\r\n                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);\r\n                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);\r\n                                    return { mObjectID: id, mTex0: color0 };\r\n                                };\r\n\r\n        me.SetRenderTargetCubeMap = function (fbo, face)\r\n                             {\r\n                                if( fbo===null )\r\n                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);\r\n                                else\r\n                                {\r\n                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);\r\n                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);\r\n                                }\r\n                             };\r\n\r\n\r\n        me.BlitRenderTarget = function( dst, src )\r\n                                {\r\n                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);\r\n                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);\r\n                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);\r\n                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,\r\n                                                         0, 0, src.mXres, src.mYres,\r\n                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR\r\n                                    );\r\n                                };\r\n\r\n        me.SetViewport = function( vp )\r\n                         {\r\n                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );\r\n                         };\r\n\r\n        me.SetWriteMask = function( c0, c1, c2, c3, z )\r\n                          {\r\n                              mGL.depthMask(z);\r\n                              mGL.colorMask(c0,c0,c0,c0);\r\n                          };\r\n\r\n        me.SetState = function( stateName, stateValue )\r\n                      {\r\n                            if (stateName === me.RENDSTGATE.WIREFRAME)\r\n                            {\r\n                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );\r\n                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );\r\n                            }\r\n                            else if (stateName === me.RENDSTGATE.FRONT_FACE)\r\n                            {\r\n                                if( stateValue ) mGL.cullFace( mGL.BACK );\r\n                                else             mGL.cullFace( mGL.FRONT );\r\n                            }\r\n                            else if (stateName === me.RENDSTGATE.CULL_FACE)\r\n                            {\r\n                                if( stateValue ) mGL.enable( mGL.CULL_FACE );\r\n                                else             mGL.disable( mGL.CULL_FACE );\r\n                            }\r\n                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)\r\n                            {\r\n                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );\r\n                                else             mGL.disable( mGL.DEPTH_TEST );\r\n                            }\r\n                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)\r\n                            {\r\n                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }\r\n                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }\r\n                            }\r\n                      };\r\n\r\n        me.SetMultisample = function( v)\r\n                    {\r\n                        if( v===true )\r\n                        {\r\n                            mGL.enable(mGL.SAMPLE_COVERAGE);\r\n                            mGL.sampleCoverage(1.0, false);\r\n                        }\r\n                        else\r\n                        {\r\n                            mGL.disable(mGL.SAMPLE_COVERAGE);\r\n                        }\r\n                    };\r\n\r\n        me.GetTranslatedShaderSource = function (shader) \r\n                          {\r\n                            if( mGL===null ) return null;\r\n                            if( mDebugShader===null ) return null;\r\n                            let vfs = mGL.getAttachedShaders(shader.mProgram);\r\n                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);\r\n                            let parts = str.split(\"GLSL END\"); str = (parts.length\u003c2) ? str : parts[1];\r\n                            return str;\r\n                          };\r\n\r\n        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) \r\n                          {\r\n                            if( mGL===null ) return;\r\n\r\n                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );\r\n                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );\r\n\r\n                            vsSource = mShaderHeader[0] + vsSource;\r\n                            fsSource = mShaderHeader[1] + fsSource;\r\n\r\n                            if( preventCache )\r\n                            {\r\n                                let vran = Math.random().toString(36).substring(7);\r\n                                let fran = Math.random().toString(36).substring(7);\r\n                                vsSource += \"\\n#define K\" + vran + \"\\n\";\r\n                                fsSource += \"\\n#define K\" + fran + \"\\n\";\r\n                            }\r\n\r\n                            var timeStart = getRealTime();\r\n\r\n                            mGL.shaderSource(vs, vsSource);\r\n                            mGL.shaderSource(fs, fsSource);\r\n                            mGL.compileShader(vs);\r\n                            mGL.compileShader(fs);\r\n\r\n                            var pr = mGL.createProgram();\r\n                            mGL.attachShader(pr, vs);\r\n                            mGL.attachShader(pr, fs);\r\n                            mGL.linkProgram(pr);\r\n\r\n                            //-------------\r\n                            let checkErrors = function()\r\n                            {\r\n                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))\r\n                                {\r\n                                    // vs error\r\n                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))\r\n                                    {\r\n                                        let vsLog = mGL.getShaderInfoLog(vs);\r\n                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });\r\n                                        mGL.deleteProgram(pr);\r\n                                    }\r\n                                    // fs error\r\n                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))\r\n                                    {\r\n                                        let fsLog = mGL.getShaderInfoLog(fs);\r\n                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });\r\n                                        mGL.deleteProgram(pr);\r\n                                    }\r\n                                    // link error\r\n                                    else\r\n                                    {\r\n                                        let infoLog = mGL.getProgramInfoLog(pr);\r\n                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });\r\n                                        mGL.deleteProgram(pr);\r\n                                    }\r\n                                }\r\n                                // no errors\r\n                                else\r\n                                {\r\n                                    let compilationTime = getRealTime() - timeStart;\r\n                                    onResolve(true, { mProgram: pr, mTime: compilationTime });\r\n                                }\r\n                            };\r\n\r\n                            // check compilation\r\n                            if (mAsynchCompile === null || forceSynch===true )\r\n                            {\r\n                                checkErrors();\r\n                            }\r\n                            else\r\n                            {\r\n                                let loopCheckCompletion = function ()\r\n                                {\r\n                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )\r\n                                        checkErrors();\r\n                                    else\r\n                                        setTimeout(loopCheckCompletion, 10);\r\n                                };\r\n                                setTimeout(loopCheckCompletion, 10);\r\n                            }\r\n                        };\r\n\r\n        me.AttachShader = function( shader )\r\n                          {\r\n                                if( shader===null )\r\n                                {\r\n                                    mBindedShader = null;\r\n                                    mGL.useProgram( null );\r\n                                }\r\n                                else\r\n                                {\r\n                                    mBindedShader = shader;\r\n                                    mGL.useProgram(shader.mProgram);\r\n                                }\r\n                          };\r\n\r\n        me.DetachShader = function ()\r\n                        {\r\n                            mGL.useProgram(null);\r\n                        };\r\n\r\n        me.DestroyShader = function( tex )\r\n                        {\r\n                            mGL.deleteProgram(tex.mProgram);\r\n                        };\r\n\r\n        me.GetAttribLocation = function (shader, name)\r\n                        {\r\n                            return mGL.getAttribLocation(shader.mProgram, name);\r\n                        };\r\n\r\n        me.SetShaderConstantLocation = function (shader, name)\r\n                        {\r\n                            return mGL.getUniformLocation(shader.mProgram, name);\r\n                        };\r\n\r\n        me.SetShaderConstantMat4F = function( uname, params, istranspose )\r\n                        {\r\n                            var program = mBindedShader;\r\n\r\n                            let pos = mGL.getUniformLocation( program.mProgram, uname );\r\n                            if( pos===null )\r\n                                return false;\r\n\r\n                            if( istranspose===false )\r\n                            {\r\n                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],\r\n                                                              params[1], params[5], params[ 9], params[13],\r\n                                                              params[2], params[6], params[10], params[14],\r\n                                                              params[3], params[7], params[11], params[15] ] );\r\n\t                            mGL.uniformMatrix4fv(pos,false,tmp);\r\n                            }\r\n                            else\r\n                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );\r\n                            return true;\r\n                        };\r\n\r\n        me.SetShaderConstant1F_Pos = function(pos, x)\r\n                        {\r\n                            mGL.uniform1f(pos, x);\r\n                            return true;\r\n                        };\r\n\r\n        me.SetShaderConstant1FV_Pos = function(pos, x)\r\n                        {\r\n                            mGL.uniform1fv(pos, x);\r\n                            return true;\r\n                        };\r\n\r\n        me.SetShaderConstant1F = function( uname, x )\r\n                        {\r\n                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);\r\n                            if (pos === null)\r\n                                return false;\r\n                            mGL.uniform1f(pos, x);\r\n                            return true;\r\n                        };\r\n\r\n        me.SetShaderConstant1I = function(uname, x)\r\n                        {\r\n                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);\r\n                            if (pos === null)\r\n                                return false;\r\n                            mGL.uniform1i(pos, x);\r\n                            return true;\r\n                        };\r\n        me.SetShaderConstant1I_Pos = function(pos, x)\r\n                        {\r\n                            mGL.uniform1i(pos, x);\r\n                            return true;\r\n                        };\r\n\r\n\r\n        me.SetShaderConstant2F = function(uname, x)\r\n                        {\r\n                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);\r\n                            if (pos === null)\r\n                                return false;\r\n                            mGL.uniform2fv(pos, x);\r\n                            return true;\r\n                        };\r\n\r\n        me.SetShaderConstant3F = function(uname, x, y, z)\r\n                        {\r\n                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);\r\n                            if (pos === null)\r\n                                return false;\r\n                            mGL.uniform3f(pos, x, y, z);\r\n                            return true;\r\n                        };\r\n\r\n        me.SetShaderConstant1FV = function(uname, x)\r\n                        {\r\n                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);\r\n                            if (pos === null)\r\n                                return false;\r\n                            mGL.uniform1fv(pos, new Float32Array(x));\r\n                            return true;\r\n                        };\r\n\r\n        me.SetShaderConstant3FV = function(uname, x) \r\n                        {\r\n                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);\r\n                            if (pos === null) return false;\r\n                            mGL.uniform3fv(pos, new Float32Array(x) );\r\n                            return true;\r\n                        };\r\n\r\n        me.SetShaderConstant4FV = function(uname, x) \r\n                        {\r\n                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);\r\n                            if (pos === null) return false;\r\n                            mGL.uniform4fv(pos, new Float32Array(x) );\r\n                            return true;\r\n                        };\r\n\r\n        me.SetShaderTextureUnit = function( uname, unit )\r\n                        {\r\n                            var program = mBindedShader;\r\n                            let pos = mGL.getUniformLocation(program.mProgram, uname);\r\n                            if (pos === null) return false;\r\n                            mGL.uniform1i(pos, unit);\r\n                            return true;\r\n                        };\r\n\r\n        me.CreateVertexArray = function( data, mode )\r\n                        {\r\n                            let id = mGL.createBuffer();\r\n                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);\r\n                            if (mode === me.BUFTYPE.STATIC)\r\n                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);\r\n                            else\r\n                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);\r\n                            return { mObject: id };\r\n                        };\r\n\r\n        me.CreateIndexArray = function( data, mode )\r\n                        {\r\n                            let id = mGL.createBuffer();\r\n                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );\r\n                            if (mode === me.BUFTYPE.STATIC)\r\n                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);\r\n                            else\r\n                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);\r\n                            return { mObject: id };\r\n                        };\r\n\r\n        me.DestroyArray = function( tex )\r\n                        {\r\n                            mGL.destroyBuffer(tex.mObject);\r\n                        };\r\n\r\n        me.AttachVertexArray = function( tex, attribs, pos )\r\n                        {\r\n                            let shader = mBindedShader;\r\n\r\n                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);\r\n\r\n                            var num = attribs.mChannels.length;\r\n                            var stride = attribs.mStride;\r\n\r\n                            var offset = 0;\r\n                            for (var i = 0; i \u003c num; i++)\r\n                            {\r\n                                var id = pos[i];\r\n                                mGL.enableVertexAttribArray(id);\r\n                                var dtype = mGL.FLOAT;\r\n                                var dsize = 4;\r\n                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }\r\n                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }\r\n                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }\r\n                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);\r\n                                offset += attribs.mChannels[i].mNumComponents * dsize;\r\n                            }\r\n                        };\r\n\r\n        me.AttachIndexArray = function( tex )\r\n                        {\r\n                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);\r\n                        };\r\n\r\n        me.DetachVertexArray = function (tex, attribs)\r\n                        {\r\n                            let num = attribs.mChannels.length;\r\n                            for (let i = 0; i \u003c num; i++)\r\n                                mGL.disableVertexAttribArray(i);\r\n                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);\r\n                        };\r\n\r\n        me.DetachIndexArray = function( tex )\r\n                        {\r\n                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);\r\n                        };\r\n\r\n        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )\r\n                        {\r\n                            let glType = mGL.POINTS;\r\n                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;\r\n                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;\r\n                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;\r\n                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;\r\n                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;\r\n                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;\r\n\r\n                            if( numInstances\u003c=1 )\r\n                            {\r\n  \t                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );\r\n\t                            else                mGL.drawArrays( glType, 0, num );\r\n                            }\r\n                            else\r\n                            {\r\n                                mGL.drawArraysInstanced(glType, 0, num, numInstances);\r\n                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);\r\n                            }\r\n                        };\r\n\r\n\r\n        me.DrawFullScreenTriangle_XY = function( vpos )\r\n                        {\r\n                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );\r\n                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );\r\n                            mGL.enableVertexAttribArray( vpos );\r\n                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );\r\n                            mGL.disableVertexAttribArray( vpos );\r\n                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );\r\n                        };\r\n\r\n\r\n        me.DrawUnitQuad_XY = function( vpos )\r\n                        {\r\n                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );\r\n                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );\r\n                            mGL.enableVertexAttribArray( vpos );\r\n                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );\r\n                            mGL.disableVertexAttribArray( vpos );\r\n                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );\r\n                        };\r\n\r\n        me.DrawUnitCube_XYZ_NOR = function( vpos )\r\n                        {\r\n                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );\r\n                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );\r\n                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );\r\n                            mGL.enableVertexAttribArray( vpos[0] );\r\n                            mGL.enableVertexAttribArray( vpos[1] );\r\n                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);\r\n                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);\r\n                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);\r\n                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);\r\n                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);\r\n                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);\r\n                            mGL.disableVertexAttribArray( vpos[0] );\r\n                            mGL.disableVertexAttribArray( vpos[1] );\r\n                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );\r\n                        }\r\n\r\n        me.DrawUnitCube_XYZ = function( vpos )\r\n                        {\r\n                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );\r\n                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );\r\n                            mGL.enableVertexAttribArray( vpos );\r\n                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);\r\n                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);\r\n                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);\r\n                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);\r\n                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);\r\n                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);\r\n                            mGL.disableVertexAttribArray( vpos );\r\n                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );\r\n                        }\r\n\r\n        me.SetBlend = function( enabled )\r\n                    {\r\n                        if( enabled )\r\n                        {\r\n                            mGL.enable( mGL.BLEND );\r\n                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );\r\n                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );\r\n                        }\r\n                        else\r\n                        {\r\n                            mGL.disable( mGL.BLEND );\r\n                        }\r\n                    };\r\n\r\n        me.GetPixelData = function( data, offset, xres, yres )\r\n                        {\r\n                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);\r\n                        };\r\n\r\n        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )\r\n                        {\r\n                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);\r\n                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);\r\n                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);\r\n                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);\r\n                        };\r\n    return me;\r\n}\r\n//==============================================================================\r\n//\r\n// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm\r\n//\r\n// piShading\r\n//\r\n//==============================================================================\r\n\r\nfunction smoothstep(a, b, x)\r\n{\r\n    x = (x - a) / (b - a);\r\n    if (x \u003c 0) x = 0; else if (x \u003e 1) x = 1;\r\n    return x * x * (3.0 - 2.0 * x);\r\n}\r\n\r\nfunction clamp01(x)\r\n{\r\n    if( x \u003c 0.0 ) x = 0.0;\r\n    if( x \u003e 1.0 ) x = 1.0;\r\n    return x;\r\n}\r\n\r\nfunction clamp(x, a, b)\r\n{\r\n    if( x \u003c a ) x = a;\r\n    if( x \u003e b ) x = b;\r\n    return x;\r\n}\r\n\r\nfunction screen(a, b)\r\n{\r\n    return 1.0 - (1.0 - a) * (1.0 - b);\r\n}\r\n\r\nfunction parabola(x)\r\n{\r\n    return 4.0 * x * (1.0 - x);\r\n}\r\n\r\nfunction min(a, b)\r\n{\r\n    return (a \u003c b) ? a : b;\r\n}\r\n\r\nfunction max(a, b)\r\n{\r\n    return (a \u003e b) ? a : b;\r\n}\r\n\r\nfunction noise( x )\r\n{\r\n    function grad(i, j, x, y)\r\n    {\r\n        var h = 7 * i + 131 * j;\r\n        h = (h \u003c\u003c 13) ^ h;\r\n        h = (h * (h * h * 15731 + 789221) + 1376312589);\r\n\r\n        var rx = (h \u0026 0x20000000) ? x : -x;\r\n        var ry = (h \u0026 0x10000000) ? y : -y;\r\n\r\n        return rx + ry;\r\n    }\r\n\r\n    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];\r\n    var f = [ x[0] - i[0], x[1] - i[1] ];\r\n    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];\r\n\r\n    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );\r\n    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );\r\n    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );\r\n    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );\r\n\r\n    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];\r\n}//==============================================================================\r\n//\r\n// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm\r\n//\r\n// piVecTypes\r\n//\r\n//==============================================================================\r\n\r\n\r\nfunction vec3( a, b, c )\r\n{\r\n    return [ a, b, c ];\r\n}\r\n\r\nfunction add( a, b )\r\n{\r\n    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];\r\n}\r\n\r\nfunction sub( a, b )\r\n{\r\n    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];\r\n}\r\n\r\nfunction mul( a, s ) \r\n{\r\n    return [ a[0]*s, a[1]*s, a[2]*s ];\r\n}\r\n\r\nfunction cross( a, b )\r\n{\r\n    return [ a[1]*b[2] - a[2]*b[1],\r\n             a[2]*b[0] - a[0]*b[2],\r\n             a[0]*b[1] - a[1]*b[0] ];\r\n}\r\n\r\nfunction dot( a, b ) \r\n{\r\n    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];\r\n}\r\n\r\nfunction normalize( v ) \r\n{\r\n    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );\r\n    return [ v[0]*is, v[1]*is, v[2]*is ];\r\n}\r\n\r\nfunction createCirclePoint( cen, uuu, vvv, rad, s, t )\r\n{\r\n    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),\r\n             cen[1] + rad*(uuu[1]*s + vvv[1]*t),\r\n             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];\r\n}\r\n\r\nfunction createTangent( a, b, c )\r\n{\r\n    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );\r\n    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );\r\n    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );\r\n\r\n}\r\n\r\n//===================================\r\n\r\nfunction vec4( a, b, c, d )\r\n{\r\n    return [ a, b, c, d ];\r\n}\r\n\r\nfunction getXYZ( v )\r\n{\r\n    return [ v[0], v[1], v[2] ];\r\n}\r\n\r\n//===================================\r\n\r\nfunction setIdentity()\r\n{\r\n    return [ 1.0, 0.0, 0.0, 0.0,\r\n             0.0, 1.0, 0.0, 0.0,\r\n             0.0, 0.0, 1.0, 0.0,\r\n             0.0, 0.0, 0.0, 1.0 ];\r\n}\r\n\r\nfunction setRotationX( t )\r\n{\r\n    var sint = Math.sin(t);\r\n    var cost = Math.cos(t);\r\n\r\n    return [ 1.0,   0.0,   0.0, 0.0,\r\n             0.0,  cost, -sint, 0.0, \r\n             0.0,  sint,  cost, 0.0,\r\n             0.0,   0.0,   0.0, 1.0 ];\r\n}\r\n\r\nfunction setRotationY( t )\r\n{\r\n    var sint = Math.sin(t);\r\n    var cost = Math.cos(t);\r\n\r\n    return [ cost, 0.0, -sint, 0.0,\r\n              0.0, 1.0,   0.0, 0.0, \r\n             sint, 0.0,  cost, 0.0,\r\n              0.0, 0.0,   0.0, 1.0 ];\r\n}\r\n\r\nfunction extractRotationEuler( m)\r\n{\r\n    var res = [];\r\n    if (m[0] == 1.0)\r\n    {\r\n        res[0] = Math.atan2(m[2], m[11]);\r\n        res[1] = 0.0;\r\n        res[2] = 0.0;\r\n\r\n    }\r\n    else if (m[0] == -1.0)\r\n    {\r\n        res[0] = Math.atan2( m[2], m[11]);\r\n        res[1] = 0.0;\r\n        res[2] = 0.0;\r\n    }\r\n    else\r\n    {\r\n        res[0] = Math.atan2( -m[9], m[10]);\r\n        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));\r\n        res[2] = Math.atan2( m[4], m[0]);\r\n    }\r\n    return res;\r\n}\r\n\r\nfunction setFromQuaternion( q )\r\n{\r\n    var ww = q[3]*q[3];\r\n    var xx = q[0]*q[0];\r\n    var yy = q[1]*q[1];\r\n    var zz = q[2]*q[2];\r\n\r\n    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,\r\n               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,\r\n               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,\r\n               0.0,                           0.0,                         0.0,                         1.0 ];\r\n}\r\n\r\nfunction setPerspective( fovy, aspect, znear, zfar )\r\n{\r\n    var tan = Math.tan(fovy * Math.PI/180.0);\r\n    var x = 1.0 / (tan*aspect);\r\n    var y = 1.0 / (tan);\r\n    var c = -(zfar + znear) / ( zfar - znear);\r\n    var d = -(2.0 * zfar * znear) / (zfar - znear);\r\n\r\n    return [ x,    0.0,  0.0,  0.0,\r\n             0.0,  y,    0.0,  0.0,\r\n             0.0,  0.0,  c,     d,\r\n             0.0,  0.0, -1.0,  0.0 ];\r\n}\r\n\r\nfunction setLookAt( eye, tar, up )\r\n{\r\n    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];\r\n\r\n\tvar m00 = dir[2]*up[1] - dir[1]*up[2]; \r\n    var m01 = dir[0]*up[2] - dir[2]*up[0];\r\n    var m02 = dir[1]*up[0] - dir[0]*up[1];\r\n    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );\r\n    m00 *= im;\r\n    m01 *= im;\r\n    m02 *= im;\r\n\r\n\tvar m04 = m02*dir[1] - m01*dir[2]; \r\n    var m05 = m00*dir[2] - m02*dir[0];\r\n    var m06 = m01*dir[0] - m00*dir[1];\r\n    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );\r\n    m04 *= im;\r\n    m05 *= im;\r\n    m06 *= im;\r\n\r\n\tvar m08 = dir[0];\r\n\tvar m09 = dir[1];\r\n\tvar m10 = dir[2];\r\n    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );\r\n    m08 *= im;\r\n    m09 *= im;\r\n    m10 *= im;\r\n\r\n\tvar m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );\r\n\tvar m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );\r\n\tvar m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );\r\n\r\n    return [ m00, m01, m02, m03,\r\n             m04, m05, m06, m07,\r\n             m08, m09, m10, m11,\r\n             0.0, 0.0, 0.0, 1.0 ];\r\n}\r\n\r\n\r\nfunction setOrtho( left, right, bottom, top, znear, zfar )\r\n{\r\n   var x = 2.0 / (right - left);\r\n   var y = 2.0 / (top - bottom);\r\n   var a = (right + left) / (right - left);\r\n   var b = (top + bottom) / (top - bottom);\r\n   var c = -2.0 / (zfar - znear);\r\n   var d = -(zfar + znear) / ( zfar - znear);\r\n\r\n   return [  x, 0.0, 0.0,   a,\r\n           0.0,   y, 0.0,   b,\r\n           0.0, 0.0,   c,   d,\r\n           0.0, 0.0, 0.0, 1.0 ];\r\n}\r\n\r\nfunction setTranslation( p )\r\n{\r\n    return [ 1.0, 0.0, 0.0, p[0],\r\n             0.0, 1.0, 0.0, p[1],\r\n             0.0, 0.0, 1.0, p[2],\r\n             0.0, 0.0, 0.0, 1.0 ];\r\n}\r\n\r\nfunction setScale( s )\r\n{\r\n    return [ s[0], 0.0,  0.0,  0.0,\r\n             0.0,  s[1], 0.0,  0.0,\r\n             0.0,  0.0,  s[2], 0.0,\r\n             0.0,  0.0,  0.0,  1.0];\r\n}\r\n\r\nfunction setProjection( fov, znear, zfar )\r\n{\r\n    var x = 2.0 / (fov[3]+fov[2]);\r\n    var y = 2.0 / (fov[0]+fov[1]);\r\n    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);\r\n    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);\r\n    var c = -(zfar + znear) / ( zfar - znear);\r\n    var d = -(2.0*zfar*znear) / (zfar - znear);\r\n    return [   x, 0.0,    a, 0.0,\r\n             0.0,   y,    b, 0.0,\r\n             0.0, 0.0,    c,   d,\r\n             0.0, 0.0, -1.0, 0.0 ];\r\n   // inverse is:\r\n   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,\r\n   //               0.0f,  1.0/y, 0.0f,   b/x,\r\n   //               0.0f,  0.0f,  0.0f,   -1.0,\r\n   //               0.0f,  0.0f,  1.0f/d, c/d );\r\n}\r\n\r\n\r\nfunction invertFast( m )\r\n{\r\n    var inv = [\r\n   \r\n             m[5]  * m[10] * m[15] - \r\n             m[5]  * m[11] * m[14] - \r\n             m[9]  * m[6]  * m[15] + \r\n             m[9]  * m[7]  * m[14] +\r\n             m[13] * m[6]  * m[11] - \r\n             m[13] * m[7]  * m[10],\r\n\r\n             -m[1]  * m[10] * m[15] + \r\n              m[1]  * m[11] * m[14] + \r\n              m[9]  * m[2] * m[15] - \r\n              m[9]  * m[3] * m[14] - \r\n              m[13] * m[2] * m[11] + \r\n              m[13] * m[3] * m[10],\r\n\r\n             m[1]  * m[6] * m[15] - \r\n             m[1]  * m[7] * m[14] - \r\n             m[5]  * m[2] * m[15] + \r\n             m[5]  * m[3] * m[14] + \r\n             m[13] * m[2] * m[7] - \r\n             m[13] * m[3] * m[6],\r\n\r\n             -m[1] * m[6] * m[11] + \r\n              m[1] * m[7] * m[10] + \r\n              m[5] * m[2] * m[11] - \r\n              m[5] * m[3] * m[10] - \r\n              m[9] * m[2] * m[7] + \r\n              m[9] * m[3] * m[6],\r\n\r\n             -m[4]  * m[10] * m[15] + \r\n              m[4]  * m[11] * m[14] + \r\n              m[8]  * m[6]  * m[15] - \r\n              m[8]  * m[7]  * m[14] - \r\n              m[12] * m[6]  * m[11] + \r\n              m[12] * m[7]  * m[10],\r\n\r\n             m[0]  * m[10] * m[15] - \r\n             m[0]  * m[11] * m[14] - \r\n             m[8]  * m[2] * m[15] + \r\n             m[8]  * m[3] * m[14] + \r\n             m[12] * m[2] * m[11] - \r\n             m[12] * m[3] * m[10],\r\n\r\n             -m[0]  * m[6] * m[15] + \r\n              m[0]  * m[7] * m[14] + \r\n              m[4]  * m[2] * m[15] - \r\n              m[4]  * m[3] * m[14] - \r\n              m[12] * m[2] * m[7] + \r\n              m[12] * m[3] * m[6],\r\n\r\n\r\n             m[0] * m[6] * m[11] - \r\n             m[0] * m[7] * m[10] - \r\n             m[4] * m[2] * m[11] + \r\n             m[4] * m[3] * m[10] + \r\n             m[8] * m[2] * m[7] - \r\n             m[8] * m[3] * m[6],\r\n\r\n\r\n             m[4]  * m[9] * m[15] - \r\n             m[4]  * m[11] * m[13] - \r\n             m[8]  * m[5] * m[15] + \r\n             m[8]  * m[7] * m[13] + \r\n             m[12] * m[5] * m[11] - \r\n             m[12] * m[7] * m[9],\r\n\r\n\r\n\r\n             -m[0]  * m[9] * m[15] + \r\n              m[0]  * m[11] * m[13] + \r\n              m[8]  * m[1] * m[15] - \r\n              m[8]  * m[3] * m[13] - \r\n              m[12] * m[1] * m[11] + \r\n              m[12] * m[3] * m[9],\r\n\r\n              m[0]  * m[5] * m[15] - \r\n              m[0]  * m[7] * m[13] - \r\n              m[4]  * m[1] * m[15] + \r\n              m[4]  * m[3] * m[13] + \r\n              m[12] * m[1] * m[7] - \r\n              m[12] * m[3] * m[5],\r\n\r\n              -m[0] * m[5] * m[11] + \r\n               m[0] * m[7] * m[9] + \r\n               m[4] * m[1] * m[11] - \r\n               m[4] * m[3] * m[9] - \r\n               m[8] * m[1] * m[7] + \r\n               m[8] * m[3] * m[5],\r\n\r\n              -m[4]  * m[9] * m[14] + \r\n               m[4]  * m[10] * m[13] +\r\n               m[8]  * m[5] * m[14] - \r\n               m[8]  * m[6] * m[13] - \r\n               m[12] * m[5] * m[10] + \r\n               m[12] * m[6] * m[9],\r\n\r\n              m[0]  * m[9] * m[14] - \r\n              m[0]  * m[10] * m[13] - \r\n              m[8]  * m[1] * m[14] + \r\n              m[8]  * m[2] * m[13] + \r\n              m[12] * m[1] * m[10] - \r\n              m[12] * m[2] * m[9],\r\n\r\n              -m[0]  * m[5] * m[14] + \r\n               m[0]  * m[6] * m[13] + \r\n               m[4]  * m[1] * m[14] - \r\n               m[4]  * m[2] * m[13] - \r\n               m[12] * m[1] * m[6] + \r\n               m[12] * m[2] * m[5],\r\n\r\n              m[0] * m[5] * m[10] - \r\n              m[0] * m[6] * m[9] - \r\n              m[4] * m[1] * m[10] + \r\n              m[4] * m[2] * m[9] + \r\n              m[8] * m[1] * m[6] - \r\n              m[8] * m[2] * m[5] ];\r\n\r\n    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];\r\n\r\n    det = 1.0/det;\r\n\r\n    for( var i = 0; i\u003c16; i++ ) inv[i] = inv[i] * det;\r\n\r\n    return inv;\r\n}\r\n\r\nfunction matMul( a, b )\r\n{\r\n    var res = [];\r\n    for( var i=0; i\u003c4; i++ )\r\n    {\r\n        var x = a[4*i+0];\r\n        var y = a[4*i+1];\r\n        var z = a[4*i+2];\r\n        var w = a[4*i+3];\r\n\r\n        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];\r\n        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];\r\n        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];\r\n        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\nfunction matMulpoint( m, v )\r\n{\r\n    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],\r\n             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],\r\n             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];\r\n}\r\n\r\nfunction matMulvec( m, v )\r\n{\r\n    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],\r\n             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],\r\n             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];\r\n}\r\n\r\n\r\nfunction bound3( infi )\r\n{\r\n    return [ infi, -infi, infi, -infi, infi, -infi ];\r\n}\r\n\r\nfunction bound3_include( a, p )\r\n{\r\n    return [\r\n        (p[0]\u003ca[0]) ? p[0] : a[0],\r\n        (p[0]\u003ea[1]) ? p[0] : a[1],\r\n        (p[1]\u003ca[2]) ? p[1] : a[2],\r\n        (p[1]\u003ea[3]) ? p[1] : a[3],\r\n        (p[2]\u003ca[4]) ? p[2] : a[4],\r\n        (p[2]\u003ea[5]) ? p[2] : a[5] ];\r\n}\r\n\r\nfunction bound3_center( b )\r\n{\r\n    return [ 0.5*(b[0]+b[1]),\r\n             0.5*(b[2]+b[3]),\r\n             0.5*(b[4]+b[5]) ];\r\n}\r\n\r\nfunction bound3_radius( b )\r\n{\r\n    return [ 0.5*(b[1]-b[0]),\r\n             0.5*(b[3]-b[2]),\r\n             0.5*(b[5]-b[4]) ];\r\n}\r\n//==============================================================================\r\n//\r\n// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm\r\n//\r\n// piWebVR\r\n//\r\n//==============================================================================\r\n\r\nfunction WebVR( isVREnabledCallback, canvasElement )\r\n{\r\n    isVREnabledCallback(false);\r\n    /*\r\n\r\n\r\n    this.mSupportVR = false;\r\n    this.mHMD = null;\r\n\r\n    var me = this;\r\n    var listVRDisplays = function (vrdevs) {\r\n        for (var i = 0; i \u003c vrdevs.length; i++)\r\n        {\r\n            if (vrdevs[i] instanceof VRDisplay)\r\n            {\r\n                me.mHMD = vrdevs[i];\r\n                console.log(\"WebVR is available.\");\r\n                console.log(me.mHMD);\r\n                break;\r\n            }\r\n        }\r\n\r\n        isVREnabledCallback(true);\r\n        me.mSupportVR = true;\r\n    }\r\n\r\n    if (navigator.getVRDisplays)\r\n    {\r\n        navigator.getVRDisplays().then(listVRDisplays);\r\n    }\r\n\r\n    isVREnabledCallback(false);\r\n    this.mCanvas = canvasElement;\r\n    */\r\n}\r\n\r\nWebVR.prototype.IsSupported = function()\r\n{\r\n    return false;\r\n    //return this.mSupportVR;\r\n}\r\n\r\nWebVR.prototype.GetData = function( id )\r\n{\r\n    return {};\r\n    /*\r\n    var frameData = new VRFrameData();\r\n    var s = this.mHMD.getFrameData(frameData);\r\n    var ss = frameData.pose;\r\n    \r\n    var fovL = this.mHMD.getEyeParameters(\"left\");\r\n    var fovR = this.mHMD.getEyeParameters( \"right\" );\r\n\r\n    // camera info\r\n    var cPos = vec3(0.0, 0.0, 0.0);\r\n    if (ss.position)\r\n        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);\r\n    var rot = vec4(0.0, 0.0, 0.0, 0.0);\r\n    if (ss.orientation)\r\n        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);\r\n    var cRot = setFromQuaternion(rot);\r\n    var cTra = setTranslation(cPos);\r\n    var cMat = matMul(invertFast(cRot), cTra);\r\n    \r\n    // per eye info\r\n    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );\r\n    var lMat = matMul(lTra, cMat);\r\n    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),\r\n                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),\r\n                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),\r\n                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];\r\n\r\n    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));\r\n    var rMat = matMul(rTra, cMat);\r\n    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),\r\n                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),\r\n                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),\r\n                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];\r\n\r\n    return {\r\n        mCamera   : { mCamera: cMat },\r\n        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },\r\n        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }\r\n           };\r\n    */\r\n}\r\n\r\nWebVR.prototype.Enable = function( id )\r\n{\r\n    /*\r\n    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(\r\n        function ()\r\n        {\r\n        },\r\n        function (err)\r\n        {\r\n            console.log(\"webVR : requestPresent failed.\");\r\n        }\r\n    );\r\n    */\r\n}\r\n\r\nWebVR.prototype.Disable = function( id )\r\n{\r\n    /*\r\n    if (!this.mHMD.isPresenting)\r\n    {\r\n        return;\r\n    }\r\n\r\n    this.mHMD.exitPresent().then(\r\n        function ()\r\n        {\r\n        },\r\n        function (err)\r\n        {\r\n            console.log(\"webVR : exitPresent failed.\");\r\n        }\r\n    );\r\n    */\r\n}\r\n\r\nWebVR.prototype.RequestAnimationFrame = function (id)\r\n{\r\n    //this.mHMD.requestAnimationFrame(id);\r\n}\r\n\r\nWebVR.prototype.IsPresenting = function (id)\r\n{\r\n    /*\r\n    if (this.mHMD.isPresenting)\r\n    {\r\n        return true;\r\n    }\r\n    */\r\n    return false;\r\n}\r\n\r\nWebVR.prototype.Finish = function (id)\r\n{\r\n    /*\r\n    if (this.mHMD.isPresenting)\r\n    {\r\n        this.mHMD.submitFrame();\r\n    }\r\n    */\r\n}\r\n\r\n//==============================================================================\r\n//\r\n// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm\r\n//\r\n// piWebUtils\r\n//\r\n//==============================================================================\r\n\r\n\r\n// RequestAnimationFrame\r\nwindow.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||\r\n                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||\r\n                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };\r\n                                        } )();\r\n\r\n// performance.now\r\nwindow.getRealTime = ( function() { if (\"performance\" in window ) return function() { return window.performance.now(); }\r\n                                                                  return function() { return (new Date()).getTime(); }\r\n                                  } )();\r\n\r\nwindow.URL = window.URL || window.webkitURL;\r\n\r\nnavigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\r\n\r\nfunction htmlEntities(str) \r\n{\r\n    return String(str).replace(/\u0026/g, '\u0026amp;').replace(/\u003c/g, '\u0026lt;').replace(/\u003e/g, '\u0026gt;').replace(/\"/g, '\u0026quot;').replace(/'/g,'\u0026apos;');\r\n}\r\n\r\nfunction piDisableTouch()\r\n{\r\n    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });\r\n}\r\n\r\nvar piGetTime = function ( timestamp )\r\n{\r\n    if (timestamp == 0)\r\n        return \"\";\r\n    return new Date(timestamp * 1000).toISOString().substr(0, 10);\r\n}\r\n\r\nfunction piGetCoords( obj )\r\n{\r\n    var x = 0;\r\n    var y = 0; \r\n    do\r\n    {\r\n         x += obj.offsetLeft;\r\n         y += obj.offsetTop;\r\n    }while( obj = obj.offsetParent );\r\n\r\n    return { mX:x, mY:y };\r\n}\r\n\r\nfunction piGetMouseCoords( ev, canvasElement )\r\n{\r\n    var pos = piGetCoords(canvasElement );\r\n    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;\r\n    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;\r\n\r\n    return { mX: mcx, mY: mcy };\r\n\r\n}\r\n\r\nfunction piGetSourceElement( e )\r\n{\r\n    var ele = null;\r\n    if( e.target )     ele = e.target;\r\n    if( e.srcElement ) ele = e.srcElement;\r\n    return ele;\r\n}\r\n\r\nfunction piRequestFullScreen( ele )\r\n{\r\n    if( ele==null ) ele =   document.documentElement;\r\n         if( ele.requestFullscreen       ) ele.requestFullscreen();\r\n    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();\r\n    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();\r\n    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );\r\n}\r\n\r\nfunction piIsFullScreen()\r\n{\r\n    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;\r\n}\r\n\r\nfunction piExitFullScreen()\r\n{\r\n       if( document.exitFullscreen       ) document.exitFullscreen();\r\n  else if( document.msExitFullscreen     ) document.msExitFullscreen();\r\n  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();\r\n  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();\r\n}\r\n\r\nfunction piIsMobile()\r\n{\r\n    return (navigator.userAgent.match(/Android/i) ||\r\n            navigator.userAgent.match(/webOS/i) ||\r\n            navigator.userAgent.match(/iPhone/i) ||\r\n            navigator.userAgent.match(/iPad/i) ||\r\n            navigator.userAgent.match(/iPod/i) ||\r\n            navigator.userAgent.match(/BlackBerry/i) ||\r\n            navigator.userAgent.match(/Windows Phone/i)) ? true : false;\r\n}\r\n\r\nfunction piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )\r\n{\r\n    var opts = { alpha: useAlpha, \r\n                 depth: useDepth, \r\n                 stencil: false, \r\n                 premultipliedAlpha: false, \r\n                 antialias: useSupersampling, \r\n                 preserveDrawingBuffer: usePreserveBuffer, \r\n                 powerPreference: \"high-performance\" }; // \"low_power\", \"high_performance\", \"default\"\r\n\r\n    var gl = null;\r\n    if( gl === null) gl = cv.getContext( \"webgl2\", opts );\r\n    if( gl === null) gl = cv.getContext( \"experimental-webgl2\", opts );\r\n    if( gl === null) gl = cv.getContext( \"webgl\", opts );\r\n    if( gl === null) gl = cv.getContext( \"experimental-webgl\", opts );\r\n\r\n    return gl;\r\n}\r\n\r\nfunction piCreateAudioContext()\r\n{\r\n    var res = null;\r\n    try\r\n    {\r\n        if( window.AudioContext ) res = new AudioContext();\r\n        if( res==null \u0026\u0026 window.webkitAudioContext ) res = new webkitAudioContext();\r\n    }\r\n    catch( e )\r\n    {\r\n        res = null;\r\n    }\r\n    return res;\r\n}\r\n\r\nfunction piHexColorToRGB(str) // \"#ff3041\"\r\n{\r\n    var rgb = parseInt(str.slice(1), 16);\r\n    var r = (rgb \u003e\u003e 16) \u0026 255;\r\n    var g = (rgb \u003e\u003e 8) \u0026 255;\r\n    var b = (rgb \u003e\u003e 0) \u0026 255;\r\n    return [r, g, b];\r\n}\r\n\r\nfunction piCreateFPSCounter()\r\n{\r\n    var mFrame;\r\n    var mTo;\r\n    var mFPS;\r\n\r\n    var iReset = function( time )\r\n    {\r\n        mFrame = 0;\r\n        mTo = time;\r\n        mFPS = 60.0;\r\n    }\r\n\r\n    var iCount = function( time )\r\n    {\r\n        mFrame++;\r\n\r\n        if( (time-mTo)\u003e500.0 )\r\n        {\r\n            mFPS = 1000.0*mFrame/(time-mTo);\r\n            mFrame = 0;\r\n            mTo = time;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    var iGetFPS = function()\r\n    {\r\n        return mFPS;\r\n    }\r\n    \r\n    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };\r\n}\r\n\r\nfunction piCanMediaRecorded(canvas)\r\n{\r\n    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction piCreateMediaRecorder(isRecordingCallback, canvas) \r\n{\r\n    if (piCanMediaRecorded(canvas) == false)\r\n    {\r\n        return null;\r\n    }\r\n    \r\n    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; \r\n\t     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';\r\n    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';\r\n    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';\r\n    else                                                              options.mimeType = 'video/webm;';\r\n\r\n    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);\r\n    var chunks = [];\r\n    \r\n    mediaRecorder.ondataavailable = function(e) \r\n    {\r\n        if (e.data.size \u003e 0) \r\n        {\r\n            chunks.push(e.data);\r\n        }\r\n    };\r\n \r\n    mediaRecorder.onstart = function(){ \r\n        isRecordingCallback( true );\r\n    };\r\n    \r\n    mediaRecorder.onstop = function()\r\n    {\r\n         isRecordingCallback( false );\r\n         let blob     = new Blob(chunks, {type: \"video/webm\"});\r\n         chunks       = [];\r\n         let videoURL = window.URL.createObjectURL(blob);\r\n         let url      = window.URL.createObjectURL(blob);\r\n         let a        = document.createElement(\"a\");\r\n         document.body.appendChild(a);\r\n         a.style      = \"display: none\";\r\n         a.href       = url;\r\n         a.download   = \"capture.webm\";\r\n         a.click();\r\n         window.URL.revokeObjectURL(url);\r\n     };\r\n    \r\n    return mediaRecorder;\r\n}\r\n\r\nfunction piExportToEXR(width, height, numComponents, type, bytes)\r\n{\r\n    var bytesPerComponent = 0;\r\n    if      (type==\"Uint\")   bytesPerComponent = 4; \r\n    else if (type==\"Half\")   bytesPerComponent = 2;\r\n    else if (type==\"Float\")  bytesPerComponent = 4;\r\n\r\n    var tHeader = 258 + (18 * numComponents + 1);\r\n    var tTable = 8 * height;\r\n    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));\r\n    var tTotal = tHeader + tTable + tScanlines;\r\n\r\n    //console.log(\"    header size = \" + tHeader);\r\n    //console.log(\"    table size = \" + tTable);\r\n    //console.log(\"    scanlines size = \" + tScanlines);\r\n    //console.log(\"    total = \" + tTotal);\r\n\r\n    var buffer = new ArrayBuffer(tTotal); \r\n    var data = new DataView(buffer);\r\n\r\n    // Header\r\n    {\r\n        // Header : 4 bytes -\u003e 0x76, 0x2f, 0x31, 0x01\r\n        var c = 0;\r\n        data.setUint8 (c++, 0x76);\r\n        data.setUint8 (c++, 0x2f);\r\n        data.setUint8 (c++, 0x31);\r\n        data.setUint8 (c++, 0x01);\r\n\r\n        // Version : 4 bytes -\u003e 2, 0, 0, 0\r\n        data.setUint8 (c++, 0x02);\r\n        data.setUint8 (c++, 0x0);\r\n        data.setUint8 (c++, 0x0);\r\n        data.setUint8 (c++, 0x0);\r\n        \r\n        // Write channel info\r\n        // Write attribute name : \"channels\"\r\n            data.setUint8 (c++, 0x63); \r\n            data.setUint8 (c++, 0x68); \r\n            data.setUint8 (c++, 0x61); \r\n            data.setUint8 (c++, 0x6e); \r\n            data.setUint8 (c++, 0x6e); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x6c); \r\n            data.setUint8 (c++, 0x73);\r\n            data.setUint8 (c++, 0x0);\r\n\r\n            // Write attribute type : \"chlist\"\r\n            data.setUint8 (c++, 0x63); \r\n            data.setUint8 (c++, 0x68); \r\n            data.setUint8 (c++, 0x6c); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x73); \r\n            data.setUint8 (c++, 0x74); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n            // Write attribute size : 18 x 3 + 1 = 55\r\n            var attribSize = 18 * numComponents + 1;\r\n            data.setUint8 (c++, attribSize); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n            var i;\r\n            for (i = 0; i \u003c numComponents; i++)\r\n            {\r\n                // Attribute : \"B\" (42) \"G\" (47) \"R\" (52)\r\n                if (i==0)       data.setUint8 (c++, 0x42);\r\n                else if (i==1)  data.setUint8 (c++, 0x47);\r\n                else if (i==2)  data.setUint8 (c++, 0x52);\r\n                data.setUint8 (c++, 0x00);\r\n                \r\n                // Value : Float (2), Half (1), Uint (0)\r\n                if      (type==\"Uint\")   data.setUint8 (c++, 0x00); \r\n                else if (type==\"Half\")   data.setUint8 (c++, 0x01);\r\n                else if (type==\"Float\")  data.setUint8 (c++, 0x02);\r\n                data.setUint8 (c++, 0x00);\r\n                data.setUint8 (c++, 0x00);\r\n                data.setUint8 (c++, 0x00);\r\n\r\n                // Plinear\r\n                data.setUint8 (c++, 0x01);\r\n\r\n                // Reserved\r\n                data.setUint8 (c++, 0x00); \r\n                data.setUint8 (c++, 0x00); \r\n                data.setUint8 (c++, 0x00); \r\n\r\n                // X sampling\r\n                data.setUint8 (c++, 0x01); \r\n                data.setUint8 (c++, 0x00); \r\n                data.setUint8 (c++, 0x00); \r\n                data.setUint8 (c++, 0x00); \r\n                \r\n                // Y sampling\r\n                data.setUint8 (c++, 0x01);\r\n                data.setUint8 (c++, 0x00);\r\n                data.setUint8 (c++, 0x00);\r\n                data.setUint8 (c++, 0x00);\r\n            }\r\n            // End attribute\r\n            data.setUint8 (c++, 0x00);\r\n    \r\n        // Write attribute name : \"compression\"\r\n            data.setUint8 (c++, 0x63); \r\n            data.setUint8 (c++, 0x6f); \r\n            data.setUint8 (c++, 0x6d); \r\n            data.setUint8 (c++, 0x70); \r\n            data.setUint8 (c++, 0x72); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x73); \r\n            data.setUint8 (c++, 0x73); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x6f); \r\n            data.setUint8 (c++, 0x6e); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n            // Write attribute type : \"compression\"\r\n            data.setUint8 (c++, 0x63); \r\n            data.setUint8 (c++, 0x6f); \r\n            data.setUint8 (c++, 0x6d); \r\n            data.setUint8 (c++, 0x70); \r\n            data.setUint8 (c++, 0x72); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x73); \r\n            data.setUint8 (c++, 0x73); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x6f); \r\n            data.setUint8 (c++, 0x6e); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n            // Write attribute size : \"1\"\r\n            data.setUint8 (c++, 0x01); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n            // Write attribute value : \"0\" (None)\r\n            data.setUint8 (c++, 0x00);\r\n\r\n        // datawindow\r\n            data.setUint8 (c++, 0x64); \r\n            data.setUint8 (c++, 0x61); \r\n            data.setUint8 (c++, 0x74); \r\n            data.setUint8 (c++, 0x61); \r\n            data.setUint8 (c++, 0x57); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x6e); \r\n            data.setUint8 (c++, 0x64); \r\n            data.setUint8 (c++, 0x6f); \r\n            data.setUint8 (c++, 0x77); \r\n            data.setUint8 (c++, 0x00); \r\n\r\n            // box2i\r\n            data.setUint8 (c++, 0x62); \r\n            data.setUint8 (c++, 0x6f); \r\n            data.setUint8 (c++, 0x78); \r\n            data.setUint8 (c++, 0x32); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n            // size 16\r\n            data.setUint8 (c++, 0x10); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n            // value 0 0 3 2\r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n\r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            \r\n            data.setUint32 (c, width-1, true);\r\n            c += 4;\r\n            \r\n            data.setUint32 (c, height-1, true); \r\n            c += 4;\r\n\r\n        // displayWindow\r\n            data.setUint8 (c++, 0x64); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x73); \r\n            data.setUint8 (c++, 0x70); \r\n            data.setUint8 (c++, 0x6c); \r\n            data.setUint8 (c++, 0x61); \r\n            data.setUint8 (c++, 0x79); \r\n            data.setUint8 (c++, 0x57); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x6e); \r\n            data.setUint8 (c++, 0x64); \r\n            data.setUint8 (c++, 0x6f); \r\n            data.setUint8 (c++, 0x77); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n            // box2i\r\n            data.setUint8 (c++, 0x62); \r\n            data.setUint8 (c++, 0x6f); \r\n            data.setUint8 (c++, 0x78); \r\n            data.setUint8 (c++, 0x32); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x00); \r\n\r\n            // size 16\r\n            data.setUint8 (c++, 0x10); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n            // value 0 0 3 2\r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            \r\n            data.setUint32 (c, width-1, true);\r\n            c += 4;\r\n            \r\n            data.setUint32 (c, height-1, true); \r\n            c += 4;\r\n\r\n        // lineOrder\r\n            data.setUint8 (c++, 0x6c); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x6e); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x4f); \r\n            data.setUint8 (c++, 0x72); \r\n            data.setUint8 (c++, 0x64); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x72); \r\n            data.setUint8 (c++, 0x00); \r\n            \r\n            // lineOrder\r\n            data.setUint8 (c++, 0x6c); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x6e); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x4f); \r\n            data.setUint8 (c++, 0x72); \r\n            data.setUint8 (c++, 0x64); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x72); \r\n            data.setUint8 (c++, 0x00); \r\n            \r\n            // size\r\n            data.setUint8 (c++, 0x01);\r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00);\r\n            \r\n            // value \r\n            data.setUint8 (c++, 0x00);\r\n\r\n        // PixelAspectRatio\r\n            data.setUint8 (c++, 0x70); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x78); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x6c); \r\n            data.setUint8 (c++, 0x41); \r\n            data.setUint8 (c++, 0x73); \r\n            data.setUint8 (c++, 0x70); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x63); \r\n            data.setUint8 (c++, 0x74); \r\n            data.setUint8 (c++, 0x52); \r\n            data.setUint8 (c++, 0x61); \r\n            data.setUint8 (c++, 0x74); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x6f); \r\n            data.setUint8 (c++, 0x00); \r\n\r\n            // float\r\n            data.setUint8 (c++, 0x66); \r\n            data.setUint8 (c++, 0x6c); \r\n            data.setUint8 (c++, 0x6f); \r\n            data.setUint8 (c++, 0x61); \r\n            data.setUint8 (c++, 0x74); \r\n            data.setUint8 (c++, 0x00);\r\n        \r\n            // size 4\r\n            data.setUint8 (c++, 0x04); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n            // value 1.0\r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x80); \r\n            data.setUint8 (c++, 0x3f);\r\n        \r\n        // screenWindowCenter\r\n            data.setUint8 (c++, 0x73); \r\n            data.setUint8 (c++, 0x63);\r\n            data.setUint8 (c++, 0x72); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x6e); \r\n            data.setUint8 (c++, 0x57); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x6e); \r\n            data.setUint8 (c++, 0x64); \r\n            data.setUint8 (c++, 0x6f); \r\n            data.setUint8 (c++, 0x77); \r\n            data.setUint8 (c++, 0x43); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x6e);\r\n            data.setUint8 (c++, 0x74); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x72); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n            // v2f\r\n            data.setUint8 (c++, 0x76); \r\n            data.setUint8 (c++, 0x32); \r\n            data.setUint8 (c++, 0x66); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n            // size 8\r\n            data.setUint8 (c++, 0x08); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n            // value 0 0\r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00);\r\n\r\n        // screenWindowWidth\r\n            data.setUint8 (c++, 0x73); \r\n            data.setUint8 (c++, 0x63); \r\n            data.setUint8 (c++, 0x72); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x65); \r\n            data.setUint8 (c++, 0x6e); \r\n            data.setUint8 (c++, 0x57); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x6e); \r\n            data.setUint8 (c++, 0x64); \r\n            data.setUint8 (c++, 0x6f); \r\n            data.setUint8 (c++, 0x77); \r\n            data.setUint8 (c++, 0x57); \r\n            data.setUint8 (c++, 0x69); \r\n            data.setUint8 (c++, 0x64); \r\n            data.setUint8 (c++, 0x74); \r\n            data.setUint8 (c++, 0x68); \r\n            data.setUint8 (c++, 0x00); \r\n            \r\n            // float\r\n            data.setUint8 (c++, 0x66); \r\n            data.setUint8 (c++, 0x6c); \r\n            data.setUint8 (c++, 0x6f); \r\n            data.setUint8 (c++, 0x61); \r\n            data.setUint8 (c++, 0x74); \r\n            data.setUint8 (c++, 0x00); \r\n\r\n            // size\r\n            data.setUint8 (c++, 0x04); \r\n            data.setUint8 (c++, 0x00);\r\n            data.setUint8 (c++, 0x00);\r\n            data.setUint8 (c++, 0x00);\r\n\r\n            // value\r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x00); \r\n            data.setUint8 (c++, 0x80); \r\n            data.setUint8 (c++, 0x3f);\r\n\r\n        // End of header\r\n        data.setUint8 (c++, 0x00);\r\n    }\r\n    //console.log(\"header size = \" + c);\r\n\r\n    // Scanline table\r\n    var initc = c + height * 8;\r\n    for (var scanline = 0 ; scanline \u003c height ; scanline ++)\r\n    {\r\n        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); \r\n        data.setUint32 (c, jump, true);\r\n        c += 4; \r\n\r\n        data.setUint32 (c, 0x00, true);\r\n        c += 4;\r\n    }\r\n    //console.log(\"header + scanlines table size = \" + c);\r\n\r\n    // Scanlines\r\n    for (var scanline = 0 ; scanline \u003c height ; scanline ++)\r\n    {\r\n        // Scanline\r\n        data.setUint32(c, scanline, true);\r\n        c += 4;\r\n\r\n        // size 24\r\n        var size = width * numComponents * bytesPerComponent; \r\n        data.setUint32(c, size, true);\r\n        c += 4;\r\n\r\n        var numComponentsSource = 4; // number of components in the SOURCE image\r\n        for (var component = 0; component \u003c numComponents ; component ++) \r\n        {\r\n            for (var pixel = 0 ; pixel \u003c width ; pixel ++) \r\n            {\r\n                // flip vertical, so we read OpenGL buffers without JS image flipping\r\n                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];\r\n                if      (type==\"Float\") data.setFloat32(c, v, true);\r\n                else if (type==\"Half\")  data.setUint16(c, v, true);\r\n\r\n                c += bytesPerComponent;\r\n            }\r\n        }\r\n    }\r\n    //console.log(\"total size = \" + c);\r\n    return new Blob([buffer], {type: 'application/octet-stream'});\r\n}\r\n\r\n\r\nfunction piExportToWAV(numSamples, rate, bits, numChannels, words)\r\n{\r\n    let numBytes = numSamples * numChannels * bits/8;\r\n\r\n    let buffer = new ArrayBuffer(44 + numBytes); \r\n    let data = new DataView(buffer);\r\n\r\n    {\r\n        data.setUint32( 0, 0x46464952, true );  // RIFF\r\n        data.setUint32( 4, numBytes + 36, true);\n        {\n            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE\n            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT\n            {\n                data.setUint32( 16, 16, true);\n                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM\n                data.setUint16( 22, numChannels, true);\n                data.setUint32( 24, rate, true);\n                data.setUint32( 28, rate*numChannels*bits / 8, true);\n                data.setUint16( 32, numChannels*bits / 8, true);\n                data.setUint16( 34, bits, true);\n            }\n\n            data.setUint32( 36, 0x61746164, true);  // WAV_DATA\n            {\n                data.setUint32( 40, numBytes, true);\n                let numWords = numSamples * numChannels;\n                for(let i=0; i\u003cnumWords; i++ )\r\n                {\r\n                    data.setInt16( 44 + i*2, words[i], true );\r\n                }\n            }\n        }\n    }\r\n\r\n\r\n    //console.log(\"total size = \" + c);\r\n    return new Blob([buffer], {type: 'application/octet-stream'});\r\n}\r\n\r\nfunction piTriggerDownload(name, blob)\r\n{\r\n    let url = URL.createObjectURL(blob);\r\n    let aElement = document.createElement(\"a\");\r\n    aElement.href     = url;\r\n    aElement.target   = \"_self\";\r\n    aElement.download = name;\r\n    document.body.appendChild(aElement);\r\n    aElement.click();\r\n    document.body.removeChild(aElement);\r\n}\u003c/script\u003e\r\n    \u003cscript\u003e// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// This is CodeMirror (https://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n\n(function (global, factory) {\n\n  typeof exports === 'object' \u0026\u0026 typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' \u0026\u0026 define.amd ? define(factory) :\n  (global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie \u0026\u0026 (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge \u0026\u0026 /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit \u0026\u0026 /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge \u0026\u0026 /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = !edge \u0026\u0026 /AppleWebKit/.test(userAgent) \u0026\u0026 /Mobile\\/\\w+/.test(userAgent);\n  var android = /Android/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto \u0026\u0026 userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) { presto_version = Number(presto_version[1]); }\n  if (presto_version \u0026\u0026 presto_version \u003e= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac \u0026\u0026 (qtwebkit || presto \u0026\u0026 (presto_version == null || presto_version \u003c 12.11));\n  var captureRightClick = gecko || (ie \u0026\u0026 ie_version \u003e= 9);\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\n  var rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count \u003e 0; --count)\n      { e.removeChild(e.firstChild); }\n    return e\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e)\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) { e.className = className; }\n    if (style) { e.style.cssText = style; }\n    if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n    else if (content) { for (var i = 0; i \u003c content.length; ++i) { e.appendChild(content[i]); } }\n    return e\n  }\n  // wrapper for elt, which removes the elt from the accessibility tree\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e\n  }\n\n  var range;\n  if (document.createRange) { range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r\n  }; }\n  else { range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r\n  }; }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      { child = child.parentNode; }\n    if (parent.contains)\n      { return parent.contains(child) }\n    do {\n      if (child.nodeType == 11) { child = child.host; }\n      if (child == parent) { return true }\n    } while (child = child.parentNode)\n  }\n\n  function activeElt() {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE \u003c 10 will throw when accessed while the page is loading or in an iframe.\n    // IE \u003e 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n    try {\n      activeElement = document.activeElement;\n    } catch(e) {\n      activeElement = document.body || null;\n    }\n    while (activeElement \u0026\u0026 activeElement.shadowRoot \u0026\u0026 activeElement.shadowRoot.activeElement)\n      { activeElement = activeElement.shadowRoot.activeElement; }\n    return activeElement\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n  }\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i \u003c as.length; i++)\n      { if (as[i] \u0026\u0026 !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n    return b\n  }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\n  else if (ie) // Suppress mysterious IE10 errors\n    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args)}\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) { target = {}; }\n    for (var prop in obj)\n      { if (obj.hasOwnProperty(prop) \u0026\u0026 (overwrite !== false || !target.hasOwnProperty(prop)))\n        { target[prop] = obj[prop]; } }\n    return target\n  }\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) { end = string.length; }\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab \u003c 0 || nextTab \u003e= end)\n        { return n + (end - i) }\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function() {this.id = null;};\n  Delayed.prototype.set = function (ms, f) {\n    clearTimeout(this.id);\n    this.id = setTimeout(f, ms);\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i \u003c array.length; ++i)\n      { if (array[i] == elt) { return i } }\n    return -1\n  }\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n  // Reused option objects for setSelection \u0026 friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) { nextTab = string.length; }\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped \u003e= goal)\n        { return pos + Math.min(skipped, goal - col) }\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col \u003e= goal) { return pos }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length \u003c= n)\n      { spaceStrs.push(lst(spaceStrs) + \" \"); }\n    return spaceStrs[n]\n  }\n\n  function lst(arr) { return arr[arr.length-1] }\n\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i \u003c array.length; i++) { out[i] = f(array[i], i); }\n    return out\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0, priority = score(value);\n    while (pos \u003c array.length \u0026\u0026 score(array[pos]) \u003c= priority) { pos++; }\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) { copyObj(props, inst); }\n    return inst\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch \u003e \"\\x80\" \u0026\u0026\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n  }\n  function isWordChar(ch, helper) {\n    if (!helper) { return isWordCharBasic(ch) }\n    if (helper.source.indexOf(\"\\\\w\") \u003e -1 \u0026\u0026 isWordCharBasic(ch)) { return true }\n    return helper.test(ch)\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) { if (obj.hasOwnProperty(n) \u0026\u0026 obj[n]) { return false } }\n    return true\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) \u003e= 768 \u0026\u0026 extendingChars.test(ch) }\n\n  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir \u003c 0 ? pos \u003e 0 : pos \u003c str.length) \u0026\u0026 isExtendingChar(str.charAt(pos))) { pos += dir; }\n    return pos\n  }\n\n  // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from \u003e to ? -1 : 1;\n    for (;;) {\n      if (from == to) { return from }\n      var midF = (from + to) / 2, mid = dir \u003c 0 ? Math.ceil(midF) : Math.floor(midF);\n      if (mid == from) { return pred(mid) ? from : to }\n      if (pred(mid)) { to = mid; }\n      else { from = mid + dir; }\n    }\n  }\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) { return f(from, to, \"ltr\", 0) }\n    var found = false;\n    for (var i = 0; i \u003c order.length; ++i) {\n      var part = order[i];\n      if (part.from \u003c to \u0026\u0026 part.to \u003e from || from == to \u0026\u0026 part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n    if (!found) { f(from, to, \"ltr\"); }\n  }\n\n  var bidiOther = null;\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n    for (var i = 0; i \u003c order.length; ++i) {\n      var cur = order[i];\n      if (cur.from \u003c ch \u0026\u0026 cur.to \u003e ch) { return i }\n      if (cur.to == ch) {\n        if (cur.from != cur.to \u0026\u0026 sticky == \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n      if (cur.from == ch) {\n        if (cur.from != cur.to \u0026\u0026 sticky != \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n    }\n    return found != null ? found : bidiOther\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6f9\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n    function charType(code) {\n      if (code \u003c= 0xf7) { return lowTypes.charAt(code) }\n      else if (0x590 \u003c= code \u0026\u0026 code \u003c= 0x5f4) { return \"R\" }\n      else if (0x600 \u003c= code \u0026\u0026 code \u003c= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n      else if (0x6ee \u003c= code \u0026\u0026 code \u003c= 0x8ac) { return \"r\" }\n      else if (0x2000 \u003c= code \u0026\u0026 code \u003c= 0x200b) { return \"w\" }\n      else if (code == 0x200c) { return \"b\" }\n      else { return \"L\" }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" \u0026\u0026 !bidiRE.test(str)) { return false }\n      var len = str.length, types = [];\n      for (var i = 0; i \u003c len; ++i)\n        { types.push(charType(str.charCodeAt(i))); }\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i$1 = 0, prev = outerType; i$1 \u003c len; ++i$1) {\n        var type = types[i$1];\n        if (type == \"m\") { types[i$1] = prev; }\n        else { prev = type; }\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i$2 = 0, cur = outerType; i$2 \u003c len; ++i$2) {\n        var type$1 = types[i$2];\n        if (type$1 == \"1\" \u0026\u0026 cur == \"r\") { types[i$2] = \"n\"; }\n        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i$3 = 1, prev$1 = types[0]; i$3 \u003c len - 1; ++i$3) {\n        var type$2 = types[i$3];\n        if (type$2 == \"+\" \u0026\u0026 prev$1 == \"1\" \u0026\u0026 types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n        else if (type$2 == \",\" \u0026\u0026 prev$1 == types[i$3+1] \u0026\u0026\n                 (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n        prev$1 = type$2;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i$4 = 0; i$4 \u003c len; ++i$4) {\n        var type$3 = types[i$4];\n        if (type$3 == \",\") { types[i$4] = \"N\"; }\n        else if (type$3 == \"%\") {\n          var end = (void 0);\n          for (end = i$4 + 1; end \u003c len \u0026\u0026 types[end] == \"%\"; ++end) {}\n          var replace = (i$4 \u0026\u0026 types[i$4-1] == \"!\") || (end \u003c len \u0026\u0026 types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i$4; j \u003c end; ++j) { types[j] = replace; }\n          i$4 = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i$5 = 0, cur$1 = outerType; i$5 \u003c len; ++i$5) {\n        var type$4 = types[i$5];\n        if (cur$1 == \"L\" \u0026\u0026 type$4 == \"1\") { types[i$5] = \"L\"; }\n        else if (isStrong.test(type$4)) { cur$1 = type$4; }\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i$6 = 0; i$6 \u003c len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = (void 0);\n          for (end$1 = i$6 + 1; end$1 \u003c len \u0026\u0026 isNeutral.test(types[end$1]); ++end$1) {}\n          var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n          var after = (end$1 \u003c len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n          for (var j$1 = i$6; j$1 \u003c end$1; ++j$1) { types[j$1] = replace$1; }\n          i$6 = end$1 - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i$7 = 0; i$7 \u003c len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n          for (++i$7; i$7 \u003c len \u0026\u0026 countsAsLeft.test(types[i$7]); ++i$7) {}\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7, at = order.length;\n          for (++i$7; i$7 \u003c len \u0026\u0026 types[i$7] != \"L\"; ++i$7) {}\n          for (var j$2 = pos; j$2 \u003c i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos \u003c j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\n              var nstart = j$2;\n              for (++j$2; j$2 \u003c i$7 \u0026\u0026 countsAsNum.test(types[j$2]); ++j$2) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              pos = j$2;\n            } else { ++j$2; }\n          }\n          if (pos \u003c i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n        }\n      }\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 \u0026\u0026 (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n        if (lst(order).level == 1 \u0026\u0026 (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order\n    }\n  })();\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line, direction) {\n    var order = line.order;\n    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n    return order\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var noHandlers = [];\n\n  var on = function(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map$$1 = emitter._handlers || (emitter._handlers = {});\n      map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers \u0026\u0026 emitter._handlers[type] || noHandlers\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map$$1 = emitter._handlers, arr = map$$1 \u0026\u0026 map$$1[type];\n      if (arr) {\n        var index = indexOf(arr, f);\n        if (index \u003e -1)\n          { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n      }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type);\n    if (!handlers.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i \u003c handlers.length; ++i) { handlers[i].apply(null, args); }\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers \u0026\u0026 cm._handlers.cursorActivity;\n    if (!arr) { return }\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i \u003c arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n      { set.push(arr[i]); } }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length \u003e 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) { e.stopPropagation(); }\n    else { e.cancelBubble = true; }\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\n  function e_target(e) {return e.target || e.srcElement}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button \u0026 1) { b = 1; }\n      else if (e.button \u0026 2) { b = 3; }\n      else if (e.button \u0026 4) { b = 2; }\n    }\n    if (mac \u0026\u0026 e.ctrlKey \u0026\u0026 b == 1) { b = 3; }\n    return b\n  }\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie \u0026\u0026 ie_version \u003c 9) { return false }\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        { zwspSupported = test.offsetWidth \u003c= 1 \u0026\u0026 test.offsetHeight \u003e 2 \u0026\u0026 !(ie \u0026\u0026 ie_version \u003c 8); }\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) { return badBidiRects }\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right \u003c 3)\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos \u003c= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) { nl = string.length; }\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result\n  } : function (string) { return string.split(/\\r\\n?|\\n/); };\n\n  var hasSelection = window.getSelection ? function (te) {\n    try { return te.selectionStart != te.selectionEnd }\n    catch(e) { return false }\n  } : function (te) {\n    var range$$1;\n    try {range$$1 = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range$$1 || range$$1.parentElement() != te) { return false }\n    return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\n  };\n\n  var hasCopyEvent = (function () {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) { return true }\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\"\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) { return badZoomedRects }\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) \u003e 1\n  }\n\n  // Known modes, by name and by MIME\n  var modes = {}, mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  function defineMode(name, mode) {\n    if (arguments.length \u003e 2)\n      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  }\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" \u0026\u0026 mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec \u0026\u0026 typeof spec.name == \"string\" \u0026\u0026 mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") { found = {name: found}; }\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" \u0026\u0026 /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\")\n    } else if (typeof spec == \"string\" \u0026\u0026 /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\")\n    }\n    if (typeof spec == \"string\") { return {name: spec} }\n    else { return spec || {name: \"null\"} }\n  }\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) { return getMode(options, \"text/plain\") }\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) { continue }\n        if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) { modeObj.helperType = spec.helperType; }\n    if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n      { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n    return modeObj\n  }\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = {};\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) { return state }\n    if (mode.copyState) { return mode.copyState(state) }\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) { val = val.concat([]); }\n      nstate[n] = val;\n    }\n    return nstate\n  }\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  function innerMode(mode, state) {\n    var info;\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n      if (!info || info.mode == mode) { break }\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state}\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true\n  }\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = function(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {return this.pos \u003e= this.string.length};\n  StringStream.prototype.sol = function () {return this.pos == this.lineStart};\n  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\n  StringStream.prototype.next = function () {\n    if (this.pos \u003c this.string.length)\n      { return this.string.charAt(this.pos++) }\n  };\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n    if (typeof match == \"string\") { ok = ch == match; }\n    else { ok = ch \u0026\u0026 (match.test ? match.test(ch) : match(ch)); }\n    if (ok) {++this.pos; return ch}\n  };\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos \u003e start\n  };\n  StringStream.prototype.eatSpace = function () {\n      var this$1 = this;\n\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\n    return this.pos \u003e start\n  };\n  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found \u003e -1) {this.pos = found; return true}\n  };\n  StringStream.prototype.backUp = function (n) {this.pos -= n;};\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos \u003c this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) { this.pos += pattern.length; }\n        return true\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match \u0026\u0026 match.index \u003e 0) { return null }\n      if (match \u0026\u0026 consume !== false) { this.pos += match[0].length; }\n      return match\n    }\n  };\n  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n    try { return inner() }\n    finally { this.lineStart -= n; }\n  };\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle \u0026\u0026 oracle.lookAhead(n)\n  };\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle \u0026\u0026 oracle.baseToken(this.pos)\n  };\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n \u003c 0 || n \u003e= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n    var chunk = doc;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n \u003c sz) { chunk = child; break }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n]\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n      if (n == end.line) { text = text.slice(0, end.ch); }\n      if (n == start.line) { text = text.slice(start.ch); }\n      out.push(text);\n      ++n;\n    });\n    return out\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n    return out\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) { return null }\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) { break }\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i$1 = 0; i$1 \u003c chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1], ch = child.height;\n        if (h \u003c ch) { chunk = child; continue outer }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n\n    } while (!chunk.lines)\n    var i = 0;\n    for (; i \u003c chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h \u003c lh) { break }\n      h -= lh;\n    }\n    return n + i\n  }\n\n  function isLine(doc, l) {return l \u003e= doc.first \u0026\u0026 l \u003c doc.first + doc.size}\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber))\n  }\n\n  // A Pos instance represents a position within the text.\n  function Pos(line, ch, sticky) {\n    if ( sticky === void 0 ) sticky = null;\n\n    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  }\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\n  function equalCursorPos(a, b) { return a.sticky == b.sticky \u0026\u0026 cmp(a, b) == 0 }\n\n  function copyPos(x) {return Pos(x.line, x.ch)}\n  function maxPos(a, b) { return cmp(a, b) \u003c 0 ? b : a }\n  function minPos(a, b) { return cmp(a, b) \u003c 0 ? a : b }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\n  function clipPos(doc, pos) {\n    if (pos.line \u003c doc.first) { return Pos(doc.first, 0) }\n    var last = doc.first + doc.size - 1;\n    if (pos.line \u003e last) { return Pos(last, getLine(doc, last).text.length) }\n    return clipToLen(pos, getLine(doc, pos.line).text.length)\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch \u003e linelen) { return Pos(pos.line, linelen) }\n    else if (ch \u003c 0) { return Pos(pos.line, 0) }\n    else { return pos }\n  }\n  function clipPosArray(doc, array) {\n    var out = [];\n    for (var i = 0; i \u003c array.length; i++) { out[i] = clipPos(doc, array[i]); }\n    return out\n  }\n\n  var SavedContext = function(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n    if (line != null \u0026\u0026 n \u003e this.maxLookAhead) { this.maxLookAhead = n; }\n    return line\n  };\n\n  Context.prototype.baseToken = function (n) {\n      var this$1 = this;\n\n    if (!this.baseTokens) { return null }\n    while (this.baseTokens[this.baseTokenPos] \u003c= n)\n      { this$1.baseTokenPos += 2; }\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {type: type \u0026\u0026 type.replace(/( |^)overlay .*/, \"\"),\n            size: this.baseTokens[this.baseTokenPos] - n}\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n    if (this.maxLookAhead \u003e 0) { this.maxLookAhead--; }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext)\n      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n    else\n      { return new Context(doc, copyState(doc.mode, saved), line) }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead \u003e 0 ? new SavedContext(state, this.maxLookAhead) : state\n  };\n\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n            lineClasses, forceToEnd);\n    var state = context.state;\n\n    // Run overlays, adjust style array.\n    var loop = function ( o ) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at \u003c end) {\n          var i_end = st[i];\n          if (i_end \u003e end)\n            { st.splice(i, 1, end, st[i+1], i_end); }\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) { return }\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start \u003c i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o \u003c cm.state.overlays.length; ++o) loop( o );\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length \u003e cm.options.maxHighlightLength \u0026\u0026 copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n      if (resetState) { context.state = resetState; }\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n      if (result.classes) { line.styleClasses = result.classes; }\n      else if (line.styleClasses) { line.styleClasses = null; }\n      if (updateFrontier === cm.doc.highlightFrontier)\n        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n    }\n    return line.styles\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) { return new Context(doc, true, n) }\n    var start = findStartLine(cm, n, precise);\n    var saved = start \u003e doc.first \u0026\u0026 getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos \u003e= display.viewFrom \u0026\u0026 pos \u003c display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n    if (precise) { doc.modeFrontier = context.line; }\n    return context\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") { callBlankLine(mode, context.state); }\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) { return mode.blankLine(state) }\n    if (!mode.innerMode) { return }\n    var inner = innerMode(mode, state);\n    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i \u003c 10; i++) {\n      if (inner) { inner[0] = innerMode(mode, state).mode; }\n      var style = mode.token(stream, state);\n      if (stream.pos \u003e stream.start) { return style }\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n  }\n\n  var Token = function(stream, type, state) {\n    this.start = stream.start; this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  };\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n    if (asArray) { tokens = []; }\n    while ((asArray || stream.pos \u003c pos.ch) \u0026\u0026 !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n    }\n    return asArray ? tokens : new Token(stream, style, context.state)\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) { for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) { break }\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        { output[prop] = lineClass[2]; }\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n        { output[prop] += \" \" + lineClass[2]; }\n    } }\n    return type\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context), style;\n    var inner = cm.options.addModeClass \u0026\u0026 [null];\n    if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n    while (!stream.eol()) {\n      if (stream.pos \u003e cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart \u003c stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart \u003c stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search \u003e lim; --search) {\n      if (search \u003c= doc.first) { return doc.first }\n      var line = getLine(doc, search - 1), after = line.stateAfter;\n      if (after \u0026\u0026 (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) \u003c= doc.modeFrontier))\n        { return search }\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent \u003e indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n    if (doc.highlightFrontier \u003c n - 10) { return }\n    var start = doc.first;\n    for (var line = n - 1; line \u003e start; line--) {\n      var saved = getLine(doc, line).stateAfter;\n      // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 \u003c 3 should cover this\n      if (saved \u0026\u0026 (!(saved instanceof SavedContext) || line + saved.lookAhead \u003c n)) {\n        start = line + 1;\n        break\n      }\n    }\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  }\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) { for (var i = 0; i \u003c spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) { return span }\n    } }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    var r;\n    for (var i = 0; i \u003c spans.length; ++i)\n      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n    return r\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i \u003c old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from \u003c= startCh : span.from \u003c startCh);\n      if (startsBefore || span.from == startCh \u0026\u0026 marker.type == \"bookmark\" \u0026\u0026 (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to \u003e= startCh : span.to \u003e startCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    } }\n    return nw\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i \u003c old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to \u003e= endCh : span.to \u003e endCh);\n      if (endsAfter || span.from == endCh \u0026\u0026 marker.type == \"bookmark\" \u0026\u0026 (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from \u003c= endCh : span.from \u003c endCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    } }\n    return nw\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) { return null }\n    var oldFirst = isLine(doc, change.from.line) \u0026\u0026 getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) \u0026\u0026 getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst \u0026\u0026 !oldLast) { return null }\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i \u003c first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) { span.to = startCh; }\n          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 \u003c last.length; ++i$1) {\n        var span$1 = last[i$1];\n        if (span$1.to != null) { span$1.to += offset; }\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n          if (!found$1) {\n            span$1.from = offset;\n            if (sameLine) { (first || (first = [])).push(span$1); }\n          }\n        } else {\n          span$1.from += offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) { first = clearEmptySpans(first); }\n    if (last \u0026\u0026 last != first) { last = clearEmptySpans(last); }\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap \u003e 0 \u0026\u0026 first)\n        { for (var i$2 = 0; i$2 \u003c first.length; ++i$2)\n          { if (first[i$2].to == null)\n            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n      for (var i$3 = 0; i$3 \u003c gap; ++i$3)\n        { newMarkers.push(gapMarkers); }\n      newMarkers.push(last);\n    }\n    return newMarkers\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i \u003c spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null \u0026\u0026 span.from == span.to \u0026\u0026 span.marker.clearWhenEmpty !== false)\n        { spans.splice(i--, 1); }\n    }\n    if (!spans.length) { return null }\n    return spans\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) { for (var i = 0; i \u003c line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly \u0026\u0026 (!markers || indexOf(markers, mark) == -1))\n          { (markers || (markers = [])).push(mark); }\n      } }\n    });\n    if (!markers) { return null }\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i \u003c markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j \u003c parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) \u003c 0 || cmp(p.from, m.to) \u003e 0) { continue }\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom \u003c 0 || !mk.inclusiveLeft \u0026\u0026 !dfrom)\n          { newParts.push({from: p.from, to: m.from}); }\n        if (dto \u003e 0 || !mk.inclusiveRight \u0026\u0026 !dto)\n          { newParts.push({from: m.to, to: p.to}); }\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n    return parts\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) { return }\n    for (var i = 0; i \u003c spans.length; ++i)\n      { spans[i].marker.detachLine(line); }\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) { return }\n    for (var i = 0; i \u003c spans.length; ++i)\n      { spans[i].marker.attachLine(line); }\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) { return lenDiff }\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) { return -fromCmp }\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) { return toCmp }\n    return b.id - a.id\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans \u0026\u0026 line.markedSpans, found;\n    if (sps) { for (var sp = (void 0), i = 0; i \u003c sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed \u0026\u0026 (start ? sp.from : sp.to) == null \u0026\u0026\n          (!found || compareCollapsedMarkers(found, sp.marker) \u003c 0))\n        { found = sp.marker; }\n    } }\n    return found\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans \u0026\u0026 line.markedSpans, found;\n    if (sps) { for (var i = 0; i \u003c sps.length; ++i) {\n      var sp = sps[i];\n      if (sp.marker.collapsed \u0026\u0026 (sp.from == null || sp.from \u003c ch) \u0026\u0026 (sp.to == null || sp.to \u003e ch) \u0026\u0026\n          (!found || compareCollapsedMarkers(found, sp.marker) \u003c 0)) { found = sp.marker; }\n    } }\n    return found\n  }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n    var line = getLine(doc, lineNo$$1);\n    var sps = sawCollapsedSpans \u0026\u0026 line.markedSpans;\n    if (sps) { for (var i = 0; i \u003c sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp \u003e= 0 \u0026\u0026 toCmp \u003c= 0 || fromCmp \u003c= 0 \u0026\u0026 toCmp \u003e= 0) { continue }\n      if (fromCmp \u003c= 0 \u0026\u0026 (sp.marker.inclusiveRight \u0026\u0026 marker.inclusiveLeft ? cmp(found.to, from) \u003e= 0 : cmp(found.to, from) \u003e 0) ||\n          fromCmp \u003e= 0 \u0026\u0026 (sp.marker.inclusiveRight \u0026\u0026 marker.inclusiveLeft ? cmp(found.from, to) \u003c= 0 : cmp(found.from, to) \u003c 0))\n        { return true }\n    } }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      { line = merged.find(-1, true).line; }\n    return line\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return line\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line\n      ;(lines || (lines = [])).push(line);\n    }\n    return lines\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) { return lineN }\n    return lineNo(vis)\n  }\n\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN \u003e doc.lastLine()) { return lineN }\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) { return lineN }\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return lineNo(line) + 1\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans \u0026\u0026 line.markedSpans;\n    if (sps) { for (var sp = (void 0), i = 0; i \u003c sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      if (sp.from == null) { return true }\n      if (sp.marker.widgetNode) { continue }\n      if (sp.from == 0 \u0026\u0026 sp.marker.inclusiveLeft \u0026\u0026 lineIsHiddenInner(doc, line, sp))\n        { return true }\n    } }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n    }\n    if (span.marker.inclusiveRight \u0026\u0026 span.to == line.text.length)\n      { return true }\n    for (var sp = (void 0), i = 0; i \u003c line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed \u0026\u0026 !sp.marker.widgetNode \u0026\u0026 sp.from == span.to \u0026\u0026\n          (sp.to == null || sp.to != span.from) \u0026\u0026\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) \u0026\u0026\n          lineIsHiddenInner(doc, line, sp)) { return true }\n    }\n  }\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i \u003c chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) { break }\n      else { h += line.height; }\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 \u003c p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n        if (cur == chunk) { break }\n        else { h += cur.height; }\n      }\n    }\n    return h\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) { return 0 }\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n    return len\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n      if (len \u003e d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () { return lineNo(this) };\n  eventMixin(Line);\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n    if (line.order != null) { line.order = null; }\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) { return null }\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$\u0026\"))\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i \u003c= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) \u0026\u0026 (order = getOrder(line, cm.doc.direction)))\n        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured \u0026\u0026 lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n        if (line.styleClasses.textClass)\n          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild;\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector \u0026\u0026 last.querySelector(\".cm-tab\")))\n        { builder.content.className = \"cm-tab-wrap-hack\"; }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n    return builder\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) { return }\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    var content;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie \u0026\u0026 ie_version \u003c 9) { mustWrap = true; }\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie \u0026\u0026 ie_version \u003c 9) { content.appendChild(elt(\"span\", [txt])); }\n          else { content.appendChild(txt); }\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) { break }\n        pos += skipped + 1;\n        var txt$1 = (void 0);\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          if (ie \u0026\u0026 ie_version \u003c 9) { content.appendChild(elt(\"span\", [txt$1])); }\n          else { content.appendChild(txt$1); }\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n    if (style || startStyle || endStyle || mustWrap || css) {\n      var fullStyle = style || \"\";\n      if (startStyle) { fullStyle += startStyle; }\n      if (endStyle) { fullStyle += endStyle; }\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (attributes) {\n        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) \u0026\u0026 attr != \"style\" \u0026\u0026 attr != \"class\")\n          { token.setAttribute(attr, attributes[attr]); } }\n      }\n      return builder.content.appendChild(token)\n    }\n    builder.content.appendChild(content);\n  }\n\n  // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n  function splitSpaces(text, trailingBefore) {\n    if (text.length \u003e 1 \u0026\u0026 !/  /.test(text)) { return text }\n    var spaceBefore = trailingBefore, result = \"\";\n    for (var i = 0; i \u003c text.length; i++) {\n      var ch = text.charAt(i);\n      if (ch == \" \" \u0026\u0026 spaceBefore \u0026\u0026 (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        { ch = \"\\u00a0\"; }\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = (void 0);\n        for (var i = 0; i \u003c order.length; i++) {\n          part = order[i];\n          if (part.to \u003e start \u0026\u0026 part.from \u003c= start) { break }\n        }\n        if (part.to \u003e= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    }\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget \u0026\u0026 marker.widgetNode;\n    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n    if (!ignoreWidget \u0026\u0026 builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        { widget = builder.content.appendChild(document.createElement(\"span\")); }\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i$1 = 1; i$1 \u003c styles.length; i$1+=2)\n        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n      return\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles = (void 0);\n        for (var j = 0; j \u003c spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" \u0026\u0026 sp.from == pos \u0026\u0026 m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from \u003c= pos \u0026\u0026 (sp.to == null || sp.to \u003e pos || m.collapsed \u0026\u0026 sp.to == pos \u0026\u0026 sp.from == pos)) {\n            if (sp.to != null \u0026\u0026 sp.to != pos \u0026\u0026 nextChange \u003e sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) { spanStyle += \" \" + m.className; }\n            if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n            if (m.startStyle \u0026\u0026 sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n            if (m.endStyle \u0026\u0026 sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n            // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n            if (m.title) { (attributes || (attributes = {})).title = m.title; }\n            if (m.attributes) {\n              for (var attr in m.attributes)\n                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }\n            }\n            if (m.collapsed \u0026\u0026 (!collapsed || compareCollapsedMarkers(collapsed.marker, m) \u003c 0))\n              { collapsed = sp; }\n          } else if (sp.from \u003e pos \u0026\u0026 nextChange \u003e sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) { for (var j$1 = 0; j$1 \u003c endStyles.length; j$1 += 2)\n          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 \u003c foundBookmarks.length; ++j$2)\n          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n        if (collapsed \u0026\u0026 (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) { return }\n          if (collapsed.to == pos) { collapsed = false; }\n        }\n      }\n      if (pos \u003e= len) { break }\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end \u003e upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n          if (end \u003e= upto) {text = text.slice(upto - pos); pos = upto; break}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos \u003c to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i \u003c callbacks.length; i++)\n        { callbacks[i].call(null); }\n      for (var j = 0; j \u003c group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          { while (op.cursorActivityCalled \u003c op.cursorActivityHandlers.length)\n            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n      }\n    } while (i \u003c callbacks.length)\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n    if (!group) { return }\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type);\n    if (!arr.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    var loop = function ( i ) {\n      list.push(function () { return arr[i].apply(null, args); });\n    };\n\n    for (var i = 0; i \u003c arr.length; ++i)\n      loop( i );\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i \u003c delayed.length; ++i) { delayed[i](); }\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j \u003c lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") { updateLineText(cm, lineView); }\n      else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n      else if (type == \"class\") { updateLineClasses(cm, lineView); }\n      else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n      lineView.node.appendChild(lineView.text);\n      if (ie \u0026\u0026 ie_version \u003c 8) { lineView.node.style.zIndex = 2; }\n    }\n    return lineView.node\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) { cls += \" CodeMirror-linebackground\"; }\n    if (lineView.background) {\n      if (cls) { lineView.background.className = cls; }\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext \u0026\u0026 ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built\n    }\n    return buildLineContent(cm, lineView)\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) { lineView.node = built.pre; }\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n    if (lineView.line.wrapClass)\n      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n    else if (lineView.node != lineView.text)\n      { lineView.node.className = \"\"; }\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n      if (cm.options.lineNumbers \u0026\u0026 (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        { lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n      if (markers) { for (var k = 0; k \u003c cm.display.gutterSpecs.length; ++k) {\n        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) \u0026\u0026 markers[id];\n        if (found)\n          { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                     (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n      } }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) { lineView.alignable = null; }\n    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n      next = node.nextSibling;\n      if (node.className == \"CodeMirror-linewidget\")\n        { lineView.node.removeChild(node); }\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) { lineView.bgClass = built.bgClass; }\n    if (built.textClass) { lineView.textClass = built.textClass; }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) { for (var i = 0; i \u003c lineView.rest.length; i++)\n      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) { return }\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i \u003c ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove \u0026\u0026 widget.above)\n        { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n      else\n        { wrap.appendChild(node); }\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n  (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) { return widget.height }\n    var cm = widget.doc.cm;\n    if (!cm) { return 0 }\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n      if (widget.noHScroll)\n        { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight\n  }\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 \u0026\u0026 n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer \u0026\u0026 n != display.mover))\n        { return true }\n    }\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\n  function paddingH(display) {\n    if (display.cachedPaddingH) { return display.cachedPaddingH }\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\", \"CodeMirror-line-like\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) \u0026\u0026 !isNaN(data.right)) { display.cachedPaddingH = data; }\n    return data\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping \u0026\u0026 displayWidth(cm);\n    if (!lineView.measure.heights || wrapping \u0026\u0026 lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i \u003c rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) \u003e 2)\n            { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n    for (var i = 0; i \u003c lineView.rest.length; i++)\n      { if (lineView.rest[i] == line)\n        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n    for (var i$1 = 0; i$1 \u003c lineView.rest.length; i$1++)\n      { if (lineNo(lineView.rest[i$1]) \u003e lineN)\n        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN \u003e= cm.display.viewFrom \u0026\u0026 lineN \u003c cm.display.viewTo)\n      { return cm.display.view[findViewIndex(cm, lineN)] }\n    var ext = cm.display.externalMeasured;\n    if (ext \u0026\u0026 lineN \u003e= ext.lineN \u0026\u0026 lineN \u003c ext.lineN + ext.size)\n      { return ext }\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view \u0026\u0026 !view.text) {\n      view = null;\n    } else if (view \u0026\u0026 view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      { view = updateExternalMeasurement(cm, line); }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    }\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) { ch = -1; }\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) { prepared.cache[key] = found; }\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom}\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map$$1, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i \u003c map$$1.length; i += 3) {\n      mStart = map$$1[i];\n      mEnd = map$$1[i + 1];\n      if (ch \u003c mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch \u003c mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map$$1.length - 3 || ch == mEnd \u0026\u0026 map$$1[i + 3] \u003e ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch \u003e= mEnd) { collapse = \"right\"; }\n      }\n      if (start != null) {\n        node = map$$1[i + 2];\n        if (mStart == mEnd \u0026\u0026 bias == (node.insertLeft ? \"left\" : \"right\"))\n          { collapse = bias; }\n        if (bias == \"left\" \u0026\u0026 start == 0)\n          { while (i \u0026\u0026 map$$1[i - 2] == map$$1[i - 3] \u0026\u0026 map$$1[i - 1].insertLeft) {\n            node = map$$1[(i -= 3) + 2];\n            collapse = \"left\";\n          } }\n        if (bias == \"right\" \u0026\u0026 start == mEnd - mStart)\n          { while (i \u003c map$$1.length - 3 \u0026\u0026 map$$1[i + 3] == map$$1[i + 4] \u0026\u0026 !map$$1[i + 5].insertLeft) {\n            node = map$$1[(i += 3) + 2];\n            collapse = \"right\";\n          } }\n        break\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n    if (bias == \"left\") { for (var i = 0; i \u003c rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) { break }\n    } } else { for (var i$1 = rects.length - 1; i$1 \u003e= 0; i$1--) {\n      if ((rect = rects[i$1]).left != rect.right) { break }\n    } }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 \u003c 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start \u0026\u0026 isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n        while (place.coverStart + end \u003c place.coverEnd \u0026\u0026 isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n        if (ie \u0026\u0026 ie_version \u003c 9 \u0026\u0026 start == 0 \u0026\u0026 end == place.coverEnd - place.coverStart)\n          { rect = node.parentNode.getBoundingClientRect(); }\n        else\n          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n        if (rect.left || rect.right || start == 0) { break }\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie \u0026\u0026 ie_version \u003c 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start \u003e 0) { collapse = bias = \"right\"; }\n      var rects;\n      if (cm.options.lineWrapping \u0026\u0026 (rects = node.getClientRects()).length \u003e 1)\n        { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n      else\n        { rect = node.getBoundingClientRect(); }\n    }\n    if (ie \u0026\u0026 ie_version \u003c 9 \u0026\u0026 !start \u0026\u0026 (!rect || !rect.left \u0026\u0026 !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n      else\n        { rect = nullRect; }\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n    for (; i \u003c heights.length - 1; i++)\n      { if (mid \u003c heights[i]) { break } }\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left \u0026\u0026 !rect.right) { result.bogus = true; }\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      { return rect }\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) { for (var i = 0; i \u003c lineView.rest.length; i++)\n        { lineView.measure.caches[i] = {}; } }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i \u003c cm.display.view.length; i++)\n      { clearLineMeasurementCacheFor(cm.display.view[i]); }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome \u0026\u0026 android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n  }\n  function pageScrollY() {\n    if (chrome \u0026\u0026 android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop\n  }\n\n  function widgetTopHeight(lineObj) {\n    var height = 0;\n    if (lineObj.widgets) { for (var i = 0; i \u003c lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n      { height += widgetHeight(lineObj.widgets[i]); } } }\n    return height\n  }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height; rect.bottom += height;\n    }\n    if (context == \"line\") { return rect }\n    if (!context) { context = \"local\"; }\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") { yOff += paddingTop(cm.display); }\n    else { yOff -= cm.display.viewOffset; }\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") { return coords }\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) { m.left = m.right; } else { m.right = m.left; }\n      return intoCoordSystem(cm, lineObj, m, context)\n    }\n    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n    if (ch \u003e= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch \u003c= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n    if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos], right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert)\n    }\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n    if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n    return val\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height}\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel \u003e 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n    if (outside) { pos.outside = outside; }\n    return pos\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y \u003c 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN \u003e last)\n      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }\n    if (x \u003c 0) { x = 0; }\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel \u003e 0 || found.outside \u003e 0 ? 1 : 0));\n      if (!collapsed) { return found }\n      var rangeEnd = collapsed.find(1);\n      if (rangeEnd.line == lineN) { return rangeEnd }\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom \u003c= y; }, end, 0);\n    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top \u003e y; }, begin, end);\n    return {begin: begin, end: end}\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n  }\n\n  // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom \u003c= y ? false : box.top \u003e y ? true : (left ? box.left : box.right) \u003e x\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n    // Move y into line-local coordinate space\n    y -= heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n    var widgetHeight$$1 = widgetTopHeight(lineObj);\n    var begin = 0, end = lineObj.text.length, ltr = true;\n\n    var order = getOrder(lineObj, cm.doc.direction);\n    // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                   (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);\n      ltr = part.level != 1;\n      // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    }\n\n    // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n    var chAround = null, boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;\n      if (!boxIsAfter(box, x, y, false)) { return false }\n      if (box.top \u003c= y \u0026\u0026 box.left \u003c= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n      return true\n    }, begin, end);\n\n    var baseX, sticky, outside = false;\n    // If a box around the coordinates was found, use that\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left \u003c boxAround.right - x, atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr \u0026\u0026 (ch == end || ch == begin)) { ch++; }\n      // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 \u003c= y) == ltr ?\n        \"after\" : \"before\";\n      // Now get accurate coordinates for this place, in order to get a\n      // base X position\n      var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), \"line\", lineObj, preparedMeasure);\n      baseX = coords.left;\n      outside = y \u003c coords.top ? -1 : y \u003e= coords.bottom ? 1 : 0;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i], ltr = part.level != 1;\n      return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                     \"line\", lineObj, preparedMeasure), x, y, true)\n    }, 0, order.length - 1);\n    var part = order[index];\n    // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n    if (index \u003e 0) {\n      var ltr = part.level != 1;\n      var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                               \"line\", lineObj, preparedMeasure);\n      if (boxIsAfter(start, x, y, true) \u0026\u0026 start.top \u003e y)\n        { part = order[index - 1]; }\n    }\n    return part\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n    var part = null, closestDist = null;\n    for (var i = 0; i \u003c order.length; i++) {\n      var p = order[i];\n      if (p.from \u003e= end || p.to \u003c= begin) { continue }\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n      // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n      var dist = endX \u003c x ? x - endX + 1e9 : endX - x;\n      if (!part || closestDist \u003e dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n    if (!part) { part = order[order.length - 1]; }\n    // Clip the part to the wrapped line.\n    if (part.from \u003c begin) { part = {from: begin, to: part.to, level: part.level}; }\n    if (part.to \u003e end) { part = {from: part.from, to: end, level: part.level}; }\n    return part\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n    if (measureText == null) {\n      measureText = elt(\"pre\", null, \"CodeMirror-line-like\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i \u003c 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height \u003e 3) { display.cachedTextHeight = height; }\n    removeChildren(display.measure);\n    return height || 1\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor], \"CodeMirror-line-like\");\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width \u003e 2) { display.cachedCharWidth = width; }\n    return width || 10\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      var id = cm.display.gutterSpecs[i].className;\n      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[id] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth}\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping \u0026\u0026 Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) { return 0 }\n\n      var widgetsHeight = 0;\n      if (line.widgets) { for (var i = 0; i \u003c line.widgets.length; i++) {\n        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n      } }\n\n      if (wrapping)\n        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n      else\n        { return widgetsHeight + th }\n    }\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n    });\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal \u0026\u0026 e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e) { return null }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect \u0026\u0026 coords.xRel == 1 \u0026\u0026 (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n \u003e= cm.display.viewTo) { return null }\n    n -= cm.display.viewFrom;\n    if (n \u003c 0) { return null }\n    var view = cm.display.view;\n    for (var i = 0; i \u003c view.length; i++) {\n      n -= view[i].size;\n      if (n \u003c 0) { return i }\n    }\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) { from = cm.doc.first; }\n    if (to == null) { to = cm.doc.first + cm.doc.size; }\n    if (!lendiff) { lendiff = 0; }\n\n    var display = cm.display;\n    if (lendiff \u0026\u0026 to \u003c display.viewTo \u0026\u0026\n        (display.updateLineNumbers == null || display.updateLineNumbers \u003e from))\n      { display.updateLineNumbers = from; }\n\n    cm.curOp.viewChanged = true;\n\n    if (from \u003e= display.viewTo) { // Change after\n      if (sawCollapsedSpans \u0026\u0026 visualLineNo(cm.doc, from) \u003c display.viewTo)\n        { resetView(cm); }\n    } else if (to \u003c= display.viewFrom) { // Change before\n      if (sawCollapsedSpans \u0026\u0026 visualLineEndNo(cm.doc, to + lendiff) \u003e display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from \u003c= display.viewFrom \u0026\u0026 to \u003e= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from \u003c= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to \u003e= display.viewTo) { // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop \u0026\u0026 cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to \u003c ext.lineN)\n        { ext.lineN += lendiff; }\n      else if (from \u003c ext.lineN + ext.size)\n        { display.externalMeasured = null; }\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext \u0026\u0026 line \u003e= ext.lineN \u0026\u0026 line \u003c ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n\n    if (line \u003c display.viewFrom || line \u003e= display.viewTo) { return }\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) { return }\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) { arr.push(type); }\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      { return {index: index, lineN: newN} }\n    var n = cm.display.viewFrom;\n    for (var i = 0; i \u003c index; i++)\n      { n += view[i].size; }\n    if (n != oldN) {\n      if (dir \u003e 0) {\n        if (index == view.length - 1) { return null }\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir \u003c 0 ? 0 : view.length - 1)) { return null }\n      newN += dir * view[index - (dir \u003c 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN}\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from \u003e= display.viewTo || to \u003c= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom \u003e from)\n        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n      else if (display.viewFrom \u003c from)\n        { display.view = display.view.slice(findViewIndex(cm, from)); }\n      display.viewFrom = from;\n      if (display.viewTo \u003c to)\n        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n      else if (display.viewTo \u003e to)\n        { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i \u003c view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden \u0026\u0026 (!lineView.node || lineView.changes)) { ++dirty; }\n    }\n    return dirty\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if ( primary === void 0 ) primary = true;\n\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i \u003c doc.sel.ranges.length; i++) {\n      if (!primary \u0026\u0026 i == doc.sel.primIndex) { continue }\n      var range$$1 = doc.sel.ranges[i];\n      if (range$$1.from().line \u003e= cm.display.viewTo || range$$1.to().line \u003c cm.display.viewFrom) { continue }\n      var collapsed = range$$1.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        { drawSelectionCursor(cm, range$$1.head, curFragment); }\n      if (!collapsed)\n        { drawSelectionRange(cm, range$$1, selFragment); }\n    }\n    return result\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range$$1, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top \u003c 0) { top = 0; }\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop]\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n        var openStart = fromArg == null \u0026\u0026 from == 0, openEnd = toArg == null \u0026\u0026 to == lineLen;\n        var first = i == 0, last = !order || i == order.length - 1;\n        if (toPos.top - fromPos.top \u003c= 3) { // Single line\n          var openLeft = (docLTR ? openStart : openEnd) \u0026\u0026 first;\n          var openRight = (docLTR ? openEnd : openStart) \u0026\u0026 last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else { // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n          if (ltr) {\n            topLeft = docLTR \u0026\u0026 openStart \u0026\u0026 first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR \u0026\u0026 openEnd \u0026\u0026 last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR \u0026\u0026 openStart \u0026\u0026 first ? rightSide : fromPos.right;\n            botLeft = !docLTR \u0026\u0026 openEnd \u0026\u0026 last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n          if (fromPos.bottom \u003c toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) \u003c 0) { start = fromPos; }\n        if (cmpCoords(toPos, start) \u003c 0) { start = toPos; }\n        if (!end || cmpCoords(fromPos, end) \u003c 0) { end = fromPos; }\n        if (cmpCoords(toPos, end) \u003c 0) { end = toPos; }\n      });\n      return {start: start, end: end}\n    }\n\n    var sFrom = range$$1.from(), sTo = range$$1.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top \u003c rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom \u003c rightStart.top)\n        { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) { return }\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate \u003e 0)\n      { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\n        cm.options.cursorBlinkRate); }\n    else if (cm.options.cursorBlinkRate \u003c 0)\n      { display.cursorDiv.style.visibility = \"hidden\"; }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { if (cm.state.delayingBlurEvent) {\n      cm.state.delayingBlurEvent = false;\n      onBlur(cm);\n    } }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\n\n    if (cm.options.readOnly == \"nocursor\") { return }\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp \u0026\u0026 cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) { return }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i \u003c display.view.length; i++) {\n      var cur = display.view[i], wrapping = cm.options.lineWrapping;\n      var height = (void 0), width = 0;\n      if (cur.hidden) { continue }\n      if (ie \u0026\u0026 ie_version \u003c 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n        // Check that lines don't extend past the right of the current\n        // editor width\n        if (!wrapping \u0026\u0026 cur.text.firstChild)\n          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }\n      }\n      var diff = cur.line.height - height;\n      if (diff \u003e .005 || diff \u003c -.005) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) { for (var j = 0; j \u003c cur.rest.length; j++)\n          { updateWidgetHeight(cur.rest[j]); } }\n      }\n      if (width \u003e cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n        if (chWidth \u003e cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) { for (var i = 0; i \u003c line.widgets.length; ++i) {\n      var w = line.widgets[i], parent = w.node.parentNode;\n      if (parent) { w.height = parent.offsetHeight; }\n    } }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport \u0026\u0026 viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport \u0026\u0026 viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport \u0026\u0026 viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom \u003c from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) \u003e= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)}\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (rect.top + box.top \u003c 0) { doScroll = true; }\n    else if (rect.bottom + box.top \u003e (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n    if (doScroll != null \u0026\u0026 !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) { margin = 0; }\n    var rect;\n    if (!cm.options.lineWrapping \u0026\u0026 pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n    }\n    for (var limit = 0; limit \u003c 5; limit++) {\n      var changed = false;\n      var coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      rect = {left: Math.min(coords.left, endCoords.left),\n              top: Math.min(coords.top, endCoords.top) - margin,\n              right: Math.max(coords.left, endCoords.left),\n              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) \u003e 1) { changed = true; }\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) \u003e 1) { changed = true; }\n      }\n      if (!changed) { break }\n    }\n    return rect\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (rect.top \u003c 0) { rect.top = 0; }\n    var screentop = cm.curOp \u0026\u0026 cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (rect.bottom - rect.top \u003e screen) { rect.bottom = rect.top + screen; }\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top \u003c snapMargin, atBottom = rect.bottom \u003e docBottom - snapMargin;\n    if (rect.top \u003c screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom \u003e screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n      if (newTop != screentop) { result.scrollTop = newTop; }\n    }\n\n    var screenleft = cm.curOp \u0026\u0026 cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n    var tooWide = rect.right - rect.left \u003e screenw;\n    if (tooWide) { rect.right = rect.left + screenw; }\n    if (rect.left \u003c 10)\n      { result.scrollLeft = 0; }\n    else if (rect.left \u003c screenleft)\n      { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\n    else if (rect.right \u003e screenw + screenleft - 3)\n      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n    return result\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollTop(cm, top) {\n    if (top == null) { return }\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) { resolveScrollToPos(cm); }\n    if (x != null) { cm.curOp.scrollLeft = x; }\n    if (y != null) { cm.curOp.scrollTop = y; }\n  }\n\n  function scrollToRange(cm, range$$1) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range$$1;\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range$$1 = cm.curOp.scrollToPos;\n    if (range$$1) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\n      scrollToCoordsRange(cm, from, to, range$$1.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  }\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) \u003c 2) { return }\n    if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n    setScrollTop(cm, val, true);\n    if (gecko) { updateDisplaySimple(cm); }\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n    if (cm.display.scroller.scrollTop == val \u0026\u0026 !forceScroll) { return }\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n  }\n\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) \u003c 2) \u0026\u0026 !forceScroll) { return }\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    }\n  }\n\n  var NativeScrollbars = function(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie \u0026\u0026 ie_version \u003c 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth \u003e measure.clientWidth + 1;\n    var needsV = measure.scrollHeight \u003e measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      this.vert.firstChild.style.height =\n        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width =\n        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth \u0026\u0026 measure.clientHeight \u003e 0) {\n      if (sWidth == 0) { this.zeroWidthHack(); }\n      this.checkedZeroWidth = true;\n    }\n\n    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac \u0026\u0026 !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n    this.disableHoriz = new Delayed;\n    this.disableVert = new Delayed;\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.pointerEvents = \"auto\";\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n      if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\n      else { delay.set(1000, maybeDisable); }\n    }\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function () {};\n\n  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\n  NullScrollbars.prototype.setScrollLeft = function () {};\n  NullScrollbars.prototype.setScrollTop = function () {};\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) { measure = measureForScrollbars(cm); }\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i \u003c 4 \u0026\u0026 startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth \u0026\u0026 cm.options.lineWrapping)\n        { updateHeightsInViewport(cm); }\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right \u0026\u0026 sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else { d.scrollbarFiller.style.display = \"\"; }\n    if (sizes.bottom \u0026\u0026 cm.options.coverGutterNextToScrollbar \u0026\u0026 cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else { d.gutterFiller.style.display = \"\"; }\n  }\n\n  var scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n      else { updateScrollTop(cm, pos); }\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: 0,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    pushOperation(cm.curOp);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp;\n    if (op) { finishOperation(op, function (group) {\n      for (var i = 0; i \u003c group.ops.length; i++)\n        { group.ops[i].cm.curOp = null; }\n      endOperations(group);\n    }); }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i \u003c ops.length; i++) // Read DOM\n      { endOperation_R1(ops[i]); }\n    for (var i$1 = 0; i$1 \u003c ops.length; i$1++) // Write DOM (maybe)\n      { endOperation_W1(ops[i$1]); }\n    for (var i$2 = 0; i$2 \u003c ops.length; i$2++) // Read DOM\n      { endOperation_R2(ops[i$2]); }\n    for (var i$3 = 0; i$3 \u003c ops.length; i$3++) // Write DOM (maybe)\n      { endOperation_W2(ops[i$3]); }\n    for (var i$4 = 0; i$4 \u003c ops.length; i$4++) // Read DOM\n      { endOperation_finish(ops[i$4]); }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) { findMaxLine(cm); }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos \u0026\u0026 (op.scrollToPos.from.line \u003c display.viewFrom ||\n                         op.scrollToPos.to.line \u003e= display.viewTo) ||\n      display.maxLineChanged \u0026\u0026 cm.options.lineWrapping;\n    op.update = op.mustUpdate \u0026\u0026\n      new DisplayUpdate(cm, op.mustUpdate \u0026\u0026 {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate \u0026\u0026 updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged \u0026\u0026 !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      { op.preparedSelection = display.input.prepareSelection(); }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft \u003c cm.doc.scrollLeft)\n        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus \u0026\u0026 op.focus == activeElt();\n    if (op.preparedSelection)\n      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      { updateScrollbars(cm, op.barMeasure); }\n    if (op.updatedDisplay)\n      { setDocumentHeight(cm, op.barMeasure); }\n\n    if (op.selectionChanged) { restartBlink(cm); }\n\n    if (cm.state.focused \u0026\u0026 op.updateInput)\n      { cm.display.input.reset(op.typing); }\n    if (takeFocus) { ensureFocus(op.cm); }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null \u0026\u0026 (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      { display.wheelStartX = display.wheelStartY = null; }\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) { for (var i = 0; i \u003c hidden.length; ++i)\n      { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n    if (unhidden) { for (var i$1 = 0; i$1 \u003c unhidden.length; ++i$1)\n      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n    if (display.wrapper.offsetHeight)\n      { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      { signal(cm, \"changes\", cm, op.changeObjs); }\n    if (op.update)\n      { op.update.finish(); }\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) { return f() }\n    startOperation(cm);\n    try { return f() }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) { return f.apply(cm, arguments) }\n      startOperation(cm);\n      try { return f.apply(cm, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) { return f.apply(this, arguments) }\n      startOperation(this);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(this); }\n    }\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) { return f.apply(this, arguments) }\n      startOperation(cm);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier \u003c cm.display.viewTo)\n      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.highlightFrontier \u003e= cm.display.viewTo) { return }\n    var end = +new Date + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line \u003e= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length \u003e cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n        if (resetState) { context.state = resetState; }\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) { line.styleClasses = newCls; }\n        else if (oldCls) { line.styleClasses = null; }\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls \u0026\u0026 (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange \u0026\u0026 i \u003c oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n        if (ischange) { changedLines.push(context.line); }\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length \u003c= cm.options.maxHighlightLength)\n          { processLine(cm, line.text, context); }\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n      if (+new Date \u003e end) {\n        startWorker(cm, cm.options.workDelay);\n        return true\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n    if (changedLines.length) { runInOp(cm, function () {\n      for (var i = 0; i \u003c changedLines.length; i++)\n        { regLineChange(cm, changedLines[i], \"text\"); }\n    }); }\n  }\n\n  // DISPLAY DRAWING\n\n  var DisplayUpdate = function(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type))\n      { this.events.push(arguments); }\n  };\n  DisplayUpdate.prototype.finish = function () {\n      var this$1 = this;\n\n    for (var i = 0; i \u003c this.events.length; i++)\n      { signal.apply(null, this$1.events[i]); }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped \u0026\u0026 display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) { return null }\n    var active = activeElt();\n    if (!active || !contains(cm.display.lineDiv, active)) { return null }\n    var result = {activeElt: active};\n    if (window.getSelection) {\n      var sel = window.getSelection();\n      if (sel.anchorNode \u0026\u0026 sel.extend \u0026\u0026 contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n    return result\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n    snapshot.activeElt.focus();\n    if (snapshot.anchorNode \u0026\u0026 contains(document.body, snapshot.anchorNode) \u0026\u0026 contains(document.body, snapshot.focusNode)) {\n      var sel = window.getSelection(), range$$1 = document.createRange();\n      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range$$1.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range$$1);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force \u0026\u0026\n        update.visible.from \u003e= display.viewFrom \u0026\u0026 update.visible.to \u003c= display.viewTo \u0026\u0026\n        (display.updateLineNumbers == null || display.updateLineNumbers \u003e= display.viewTo) \u0026\u0026\n        display.renderedView == display.view \u0026\u0026 countDirtyView(cm) == 0)\n      { return false }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from \u0026 to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom \u003c from \u0026\u0026 from - display.viewFrom \u003c 20) { from = Math.max(doc.first, display.viewFrom); }\n    if (display.viewTo \u003e to \u0026\u0026 display.viewTo - to \u003c 20) { to = Math.min(end, display.viewTo); }\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different \u0026\u0026 toUpdate == 0 \u0026\u0026 !update.force \u0026\u0026 display.renderedView == display.view \u0026\u0026\n        (display.updateLineNumbers == null || display.updateLineNumbers \u003e= display.viewTo))\n      { return false }\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var selSnapshot = selectionSnapshot(cm);\n    if (toUpdate \u003e 4) { display.lineDiv.style.display = \"none\"; }\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate \u003e 4) { display.lineDiv.style.display = \"\"; }\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    restoreSelection(selSnapshot);\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport \u0026\u0026 viewport.top != null)\n          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from \u003e= cm.display.viewFrom \u0026\u0026 update.visible.to \u003c= cm.display.viewTo)\n          { break }\n      }\n      if (!updateDisplayIfNeeded(cm, update)) { break }\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit \u0026\u0026 mac \u0026\u0026 cm.display.currentWheelTarget == node)\n        { node.style.display = \"none\"; }\n      else\n        { node.parentNode.removeChild(node); }\n      return next\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i \u003c view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) { cur = rm(cur); }\n        var updateNumber = lineNumbers \u0026\u0026 updateNumbersFrom != null \u0026\u0026\n          updateNumbersFrom \u003c= lineN \u0026\u0026 lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") \u003e -1) { updateNumber = false; }\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) { cur = rm(cur); }\n  }\n\n  function updateGutterSpace(display) {\n    var width = display.gutters.offsetWidth;\n    display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n  }\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets \u0026\u0026 (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i \u003c view.length; i++) { if (!view[i].hidden) {\n      if (cm.options.fixedGutter) {\n        if (view[i].gutter)\n          { view[i].gutter.style.left = left; }\n        if (view[i].gutterBackground)\n          { view[i].gutterBackground.style.left = left; }\n      }\n      var align = view[i].alignable;\n      if (align) { for (var j = 0; j \u003c align.length; j++)\n        { align[j].style.left = left; } }\n    } }\n    if (cm.options.fixedGutter)\n      { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) { return false }\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm.display);\n      return true\n    }\n    return false\n  }\n\n  function getGutters(gutters, lineNumbers) {\n    var result = [], sawLineNumbers = false;\n    for (var i = 0; i \u003c gutters.length; i++) {\n      var name = gutters[i], style = null;\n      if (typeof name != \"string\") { style = name.style; name = name.className; }\n      if (name == \"CodeMirror-linenumbers\") {\n        if (!lineNumbers) { continue }\n        else { sawLineNumbers = true; }\n      }\n      result.push({className: name, style: style});\n    }\n    if (lineNumbers \u0026\u0026 !sawLineNumbers) { result.push({className: \"CodeMirror-linenumbers\", style: null}); }\n    return result\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function renderGutters(display) {\n    var gutters = display.gutters, specs = display.gutterSpecs;\n    removeChildren(gutters);\n    display.lineGutter = null;\n    for (var i = 0; i \u003c specs.length; ++i) {\n      var ref = specs[i];\n      var className = ref.className;\n      var style = ref.style;\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + className));\n      if (style) { gElt.style.cssText = style; }\n      if (className == \"CodeMirror-linenumbers\") {\n        display.lineGutter = gElt;\n        gElt.style.width = (display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = specs.length ? \"\" : \"none\";\n    updateGutterSpace(display);\n  }\n\n  function updateGutters(cm) {\n    renderGutters(cm.display);\n    regChange(cm);\n    alignHorizontally(cm);\n  }\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input, options) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [lines], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie \u0026\u0026 ie_version \u003c 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit \u0026\u0026 !(gecko \u0026\u0026 mobile)) { d.scroller.draggable = true; }\n\n    if (place) {\n      if (place.appendChild) { place.appendChild(d.wrapper); }\n      else { place(d.wrapper); }\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n    renderGutters(d);\n\n    input.init(d);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) { wheelPixelsPerUnit = -.53; }\n  else if (gecko) { wheelPixelsPerUnit = 15; }\n  else if (chrome) { wheelPixelsPerUnit = -.7; }\n  else if (safari) { wheelPixelsPerUnit = -1/3; }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null \u0026\u0026 e.detail \u0026\u0026 e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n    if (dy == null \u0026\u0026 e.detail \u0026\u0026 e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n    else if (dy == null) { dy = e.wheelDelta; }\n    return {x: dx, y: dy}\n  }\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta\n  }\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth \u003e scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight \u003e scroll.clientHeight;\n    if (!(dx \u0026\u0026 canScrollX || dy \u0026\u0026 canScrollY)) { return }\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy \u0026\u0026 mac \u0026\u0026 webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i \u003c view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx \u0026\u0026 !gecko \u0026\u0026 !presto \u0026\u0026 wheelPixelsPerUnit != null) {\n      if (dy \u0026\u0026 canScrollY)\n        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy \u0026\u0026 canScrollY))\n        { e_preventDefault(e); }\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy \u0026\u0026 wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels \u003c 0) { top = Math.max(0, top + pixels - 50); }\n      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples \u003c 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) { return }\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY \u0026\u0026 display.wheelDY \u0026\u0026 movedY / display.wheelDY) ||\n            (movedX \u0026\u0026 display.wheelDX \u0026\u0026 movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) { return }\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  var Selection = function(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\n  Selection.prototype.equals = function (other) {\n      var this$1 = this;\n\n    if (other == this) { return true }\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n    for (var i = 0; i \u003c this.ranges.length; i++) {\n      var here = this$1.ranges[i], there = other.ranges[i];\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n    }\n    return true\n  };\n\n  Selection.prototype.deepCopy = function () {\n      var this$1 = this;\n\n    var out = [];\n    for (var i = 0; i \u003c this.ranges.length; i++)\n      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\n    return new Selection(out, this.primIndex)\n  };\n\n  Selection.prototype.somethingSelected = function () {\n      var this$1 = this;\n\n    for (var i = 0; i \u003c this.ranges.length; i++)\n      { if (!this$1.ranges[i].empty()) { return true } }\n    return false\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n      var this$1 = this;\n\n    if (!end) { end = pos; }\n    for (var i = 0; i \u003c this.ranges.length; i++) {\n      var range = this$1.ranges[i];\n      if (cmp(end, range.from()) \u003e= 0 \u0026\u0026 cmp(pos, range.to()) \u003c= 0)\n        { return i }\n    }\n    return -1\n  };\n\n  var Range = function(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  };\n\n  Range.prototype.from = function () { return minPos(this.anchor, this.head) };\n  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };\n  Range.prototype.empty = function () { return this.head.line == this.anchor.line \u0026\u0026 this.head.ch == this.anchor.ch };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm \u0026\u0026 cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i \u003c ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n      if (mayTouch \u0026\u0026 !cur.empty() ? diff \u003e 0 : diff \u003e= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i \u003c= primIndex) { --primIndex; }\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex)\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0)\n  }\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  function changeEnd(change) {\n    if (!change.text) { return change.to }\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n  }\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) \u003c 0) { return pos }\n    if (cmp(pos, change.to) \u003c= 0) { return changeEnd(change) }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n    return Pos(line, ch)\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i \u003c doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex)\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n    else\n      { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i \u003c changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) \u003c 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex)\n  }\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) { line.stateAfter = null; }\n      if (line.styles) { line.styles = null; }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) { regChange(cm); }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 \u0026\u0026 change.to.ch == 0 \u0026\u0026 lst(change.text) == \"\" \u0026\u0026\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight$$1);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      var result = [];\n      for (var i = start; i \u003c end; ++i)\n        { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\n      return result\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) { doc.remove(from.line, nlines); }\n      if (added.length) { doc.insert(from.line, added); }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n      if (nlines \u003e 1) { doc.remove(from.line + 1, nlines - 1); }\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) { for (var i = 0; i \u003c doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) { continue }\n        var shared = sharedHist \u0026\u0026 rel.sharedHist;\n        if (sharedHistOnly \u0026\u0026 !shared) { continue }\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      } }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) { throw new Error(\"This document is already in use.\") }\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n    if (!cm.options.lineWrapping) { findMaxLine(cm); }\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n    return histChange\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) { array.pop(); }\n      else { break }\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done)\n    } else if (hist.done.length \u0026\u0026 !lst(hist.done).ranges) {\n      return lst(hist.done)\n    } else if (hist.done.length \u003e 1 \u0026\u0026 !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done)\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n    var last;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin \u0026\u0026 change.origin \u0026\u0026\n         ((change.origin.charAt(0) == \"+\" \u0026\u0026 hist.lastModTime \u003e time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||\n          change.origin.charAt(0) == \"*\")) \u0026\u0026\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 \u0026\u0026 cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        { pushSelectionToHistory(doc.sel, hist.done); }\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length \u003e hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) { hist.done.shift(); }\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) { signal(doc, \"historyAdded\"); }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" \u0026\u0026\n      prev.ranges.length == sel.ranges.length \u0026\u0026\n      prev.somethingSelected() == sel.somethingSelected() \u0026\u0026\n      new Date - doc.history.lastSelTime \u003c= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options \u0026\u0026 options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin \u0026\u0026 hist.lastSelOrigin == origin \u0026\u0026\n         (hist.lastModTime == hist.lastSelTime \u0026\u0026 hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      { hist.done[hist.done.length - 1] = sel; }\n    else\n      { pushSelectionToHistory(sel, hist.done); }\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options \u0026\u0026 options.clearRedo !== false)\n      { clearSelectionEvents(hist.undone); }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top \u0026\u0026 top.ranges \u0026\u0026 top.equals(sel)))\n      { dest.push(sel); }\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans)\n        { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) { return null }\n    var out;\n    for (var i = 0; i \u003c spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n      else if (out) { out.push(spans[i]); }\n    }\n    return !out ? spans : out.length ? out : null\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) { return null }\n    var nw = [];\n    for (var i = 0; i \u003c change.text.length; ++i)\n      { nw.push(removeClearedSpans(found[i])); }\n    return nw\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) { return stretched }\n    if (!stretched) { return old }\n\n    for (var i = 0; i \u003c old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur \u0026\u0026 stretchCur) {\n        spans: for (var j = 0; j \u003c stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k \u003c oldCur.length; ++k)\n            { if (oldCur[k].marker == span.marker) { continue spans } }\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n    for (var i = 0; i \u003c events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j \u003c changes.length; ++j) {\n        var change = changes[j], m = (void 0);\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) \u003e -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        } } }\n      }\n    }\n    return copy\n  }\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) \u003c 0;\n        if (posBefore != (cmp(other, anchor) \u003c 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) \u003c 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head)\n    } else {\n      return new Range(other || head, head)\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) { extend = doc.cm \u0026\u0026 (doc.cm.display.shift || doc.extend); }\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm \u0026\u0026 (doc.cm.display.shift || doc.extend);\n    for (var i = 0; i \u003c doc.sel.ranges.length; i++)\n      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        var this$1 = this;\n\n        this.ranges = [];\n        for (var i = 0; i \u003c ranges.length; i++)\n          { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head)); }\n      },\n      origin: options \u0026\u0026 options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }\n    else { return sel }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last \u0026\u0026 last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm \u0026\u0026 hasHandler(doc.cm, \"beforeSelectionChange\"))\n      { sel = filterSelectionChange(doc, sel, options); }\n\n    var bias = options \u0026\u0026 options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) \u003c 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options \u0026\u0026 options.scroll === false) \u0026\u0026 doc.cm)\n      { ensureCursorVisible(doc.cm); }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) { return }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i \u003c sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length \u0026\u0026 doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old \u0026\u0026 old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old \u0026\u0026 old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) { out = sel.ranges.slice(0, i); }\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) { for (var i = 0; i \u003c line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n\n      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker\n      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it\n      // is with selectLeft/Right\n      var preventCursorLeft = (\"selectLeft\" in m) ? !m.selectLeft : m.inclusiveLeft;\n      var preventCursorRight = (\"selectRight\" in m) ? !m.selectRight : m.inclusiveRight;\n\n      if ((sp.from == null || (preventCursorLeft ? sp.from \u003c= pos.ch : sp.from \u003c pos.ch)) \u0026\u0026\n          (sp.to == null || (preventCursorRight ? sp.to \u003e= pos.ch : sp.to \u003e pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) { break }\n            else {--i; continue}\n          }\n        }\n        if (!m.atomic) { continue }\n\n        if (oldPos) {\n          var near = m.find(dir \u003c 0 ? 1 : -1), diff = (void 0);\n          if (dir \u003c 0 ? preventCursorRight : preventCursorLeft)\n            { near = movePos(doc, near, -dir, near \u0026\u0026 near.line == pos.line ? line : null); }\n          if (near \u0026\u0026 near.line == pos.line \u0026\u0026 (diff = cmp(near, oldPos)) \u0026\u0026 (dir \u003c 0 ? diff \u003c 0 : diff \u003e 0))\n            { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n        }\n\n        var far = m.find(dir \u003c 0 ? -1 : 1);\n        if (dir \u003c 0 ? preventCursorLeft : preventCursorRight)\n          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n      }\n    } }\n    return pos\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear \u0026\u0026 skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear \u0026\u0026 skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0)\n    }\n    return found\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir \u003c 0 \u0026\u0026 pos.ch == 0) {\n      if (pos.line \u003e doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n      else { return null }\n    } else if (dir \u003e 0 \u0026\u0026 pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line \u003c doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n      else { return null }\n    } else {\n      return new Pos(pos.line, pos.ch + dir)\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  }\n\n  // UPDATING\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function () { return obj.canceled = true; }\n    };\n    if (update) { obj.update = function (from, to, text, origin) {\n      if (from) { obj.from = clipPos(doc, from); }\n      if (to) { obj.to = clipPos(doc, to); }\n      if (text) { obj.text = text; }\n      if (origin !== undefined) { obj.origin = origin; }\n    }; }\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n    if (obj.canceled) {\n      if (doc.cm) { doc.cm.curOp.updateInput = 2; }\n      return null\n    }\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n      if (doc.cm.state.suppressEdits) { return }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm \u0026\u0026 hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) { return }\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans \u0026\u0026 !ignoreReadOnly \u0026\u0026 removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i \u003e= 0; --i)\n        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 \u0026\u0026 change.text[0] == \"\" \u0026\u0026 cmp(change.from, change.to) == 0) { return }\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist \u0026\u0026 indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm \u0026\u0026 doc.cm.state.suppressEdits;\n    if (suppress \u0026\u0026 !allowSelectionOnly) { return }\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    var i = 0;\n    for (; i \u003c source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges \u0026\u0026 !event.equals(doc.sel) : !event.ranges)\n        { break }\n    }\n    if (i == source.length) { return }\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly \u0026\u0026 !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return\n        }\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return\n      } else { break }\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm \u0026\u0026 hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function ( i ) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter \u0026\u0026 !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {}\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i \u0026\u0026 doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist \u0026\u0026 indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 \u003e= 0; --i$1) {\n      var returned = loop( i$1 );\n\n      if ( returned ) return returned.v;\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) { return }\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n      Pos(range.anchor.line + distance, range.anchor.ch),\n      Pos(range.head.line + distance, range.head.ch)\n    ); }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l \u003c d.viewTo; l++)\n        { regLineChange(doc.cm, l, \"gutter\"); }\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm \u0026\u0026 !doc.cm.curOp)\n      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n    if (change.to.line \u003c doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return\n    }\n    if (change.from.line \u003e doc.lastLine()) { return }\n\n    // Clip the change to the size of this doc\n    if (change.from.line \u003c doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line \u003e last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n    else { updateDoc(doc, change, spans); }\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\n    if (doc.cantEdit \u0026\u0026 skipAtomic(doc, Pos(doc.firstLine(), 0)))\n      { doc.cantEdit = false; }\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) \u003e -1)\n      { signalCursorActivity(cm); }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n        if (len \u003e display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      { regChange(cm); }\n    else if (from.line == to.line \u0026\u0026 change.text.length == 1 \u0026\u0026 !isWholeLineUpdate(cm.doc, change))\n      { regLineChange(cm, from.line, \"text\"); }\n    else\n      { regChange(cm, from.line, to.line + 1, lendiff); }\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) { to = from; }\n    if (cmp(to, from) \u003c 0) { (assign = [to, from], from = assign[0], to = assign[1]); }\n    if (typeof code == \"string\") { code = doc.splitLines(code); }\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to \u003c pos.line) {\n      pos.line += diff;\n    } else if (from \u003c pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i \u003c array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j \u003c sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue\n      }\n      for (var j$1 = 0; j$1 \u003c sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n        if (to \u003c cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from \u003c= cur.to.line) {\n          ok = false;\n          break\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n    else { no = lineNo(handle); }\n    if (no == null) { return null }\n    if (op(line, no) \u0026\u0026 doc.cm) { regLineChange(doc.cm, no, changeType); }\n    return line\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    var this$1 = this;\n\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n    for (var i = 0; i \u003c lines.length; ++i) {\n      lines[i].parent = this$1;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length },\n\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      var this$1 = this;\n\n      for (var i = at, e = at + n; i \u003c e; ++i) {\n        var line = this$1.lines[i];\n        this$1.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      var this$1 = this;\n\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i \u003c lines.length; ++i) { lines[i].parent = this$1; }\n    },\n\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      var this$1 = this;\n\n      for (var e = at + n; at \u003c e; ++at)\n        { if (op(this$1.lines[at])) { return true } }\n    }\n  };\n\n  function BranchChunk(children) {\n    var this$1 = this;\n\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i \u003c children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this$1;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size },\n\n    removeInner: function(at, n) {\n      var this$1 = this;\n\n      this.size -= n;\n      for (var i = 0; i \u003c this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at \u003c sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this$1.height -= oldHeight - child.height;\n          if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n \u003c 25 \u0026\u0026\n          (this.children.length \u003e 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n\n    collapse: function(lines) {\n      var this$1 = this;\n\n      for (var i = 0; i \u003c this.children.length; ++i) { this$1.children[i].collapse(lines); }\n    },\n\n    insertInner: function(at, lines, height) {\n      var this$1 = this;\n\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i \u003c this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at \u003c= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines \u0026\u0026 child.lines.length \u003e 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n            for (var pos = remaining; pos \u003c child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this$1.children.splice(++i, 0, leaf);\n              leaf.parent = this$1;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this$1.maybeSpill();\n          }\n          break\n        }\n        at -= sz;\n      }\n    },\n\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length \u003c= 10) { return }\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length \u003e 10)\n      me.parent.maybeSpill();\n    },\n\n    iterN: function(at, n, op) {\n      var this$1 = this;\n\n      for (var i = 0; i \u003c this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at \u003c sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) { return true }\n          if ((n -= used) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n    }\n  };\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function(doc, node, options) {\n    var this$1 = this;\n\n    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n      { this$1[opt] = options[opt]; } } }\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n      var this$1 = this;\n\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) { return }\n    for (var i = 0; i \u003c ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\n    if (!ws.length) { line.widgets = null; }\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n      var this$1 = this;\n\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) { return }\n    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) \u003c ((cm.curOp \u0026\u0026 cm.curOp.scrollTop) || cm.doc.scrollTop))\n      { addToScrollTop(cm, diff); }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm \u0026\u0026 widget.noHScroll) { cm.display.alignWidgets = true; }\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) { widgets.push(widget); }\n      else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\n      widget.line = line;\n      if (cm \u0026\u0026 !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) \u003c doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) { addToScrollTop(cm, widget.height); }\n        cm.curOp.forceUpdate = true;\n      }\n      return true\n    });\n    if (cm) { signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle)); }\n    return widget\n  }\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  var TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function () {\n      var this$1 = this;\n\n    if (this.explicitlyCleared) { return }\n    var cm = this.doc.cm, withOp = cm \u0026\u0026 !cm.curOp;\n    if (withOp) { startOperation(cm); }\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) { signalLater(this, \"clear\", found.from, found.to); }\n    }\n    var min = null, max = null;\n    for (var i = 0; i \u003c this.lines.length; ++i) {\n      var line = this$1.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this$1);\n      if (cm \u0026\u0026 !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n      else if (cm) {\n        if (span.to != null) { max = lineNo(line); }\n        if (span.from != null) { min = lineNo(line); }\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null \u0026\u0026 this$1.collapsed \u0026\u0026 !lineIsHidden(this$1.doc, line) \u0026\u0026 cm)\n        { updateLineHeight(line, textHeight(cm.display)); }\n    }\n    if (cm \u0026\u0026 this.collapsed \u0026\u0026 !cm.options.lineWrapping) { for (var i$1 = 0; i$1 \u003c this.lines.length; ++i$1) {\n      var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\n      if (len \u003e cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    } }\n\n    if (min != null \u0026\u0026 cm \u0026\u0026 this.collapsed) { regChange(cm, min, max + 1); }\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic \u0026\u0026 this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) { reCheckSelection(cm.doc); }\n    }\n    if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n    if (withOp) { endOperation(cm); }\n    if (this.parent) { this.parent.clear(); }\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function (side, lineObj) {\n      var this$1 = this;\n\n    if (side == null \u0026\u0026 this.type == \"bookmark\") { side = 1; }\n    var from, to;\n    for (var i = 0; i \u003c this.lines.length; ++i) {\n      var line = this$1.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this$1);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) { return from }\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) { return to }\n      }\n    }\n    return from \u0026\u0026 {from: from, to: to}\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function () {\n      var this$1 = this;\n\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) { return }\n    runInOp(cm, function () {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) \u0026\u0026 widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          { updateLineHeight(line, line.height + dHeight); }\n      }\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length \u0026\u0026 this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n    }\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length \u0026\u0026 this.doc.cm) {\n      var op = this.doc.cm.curOp\n      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n  eventMixin(TextMarker);\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options \u0026\u0026 options.shared) { return markTextShared(doc, from, to, options, type) }\n    // Ensure we are in an operation.\n    if (doc.cm \u0026\u0026 !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) { copyObj(options, marker, false); }\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff \u003e 0 || diff == 0 \u0026\u0026 marker.clearWhenEmpty !== false)\n      { return marker }\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line \u0026\u0026 conflictingCollapsedRange(doc, to.line, from, to, marker))\n        { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory)\n      { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm \u0026\u0026 marker.collapsed \u0026\u0026 !cm.options.lineWrapping \u0026\u0026 visualLine(line) == cm.display.maxLine)\n        { updateMaxLine = true; }\n      if (marker.collapsed \u0026\u0026 curLine != from.line) { updateLineHeight(line, 0); }\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n    }); }\n\n    if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n      if (doc.history.done.length || doc.history.undone.length)\n        { doc.clearHistory(); }\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n      if (marker.collapsed)\n        { regChange(cm, from.line, to.line + 1); }\n      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||\n               marker.attributes || marker.title)\n        { for (var i = from.line; i \u003c= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n      if (marker.atomic) { reCheckSelection(cm.doc); }\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = function(markers, primary) {\n    var this$1 = this;\n\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i \u003c markers.length; ++i)\n      { markers[i].parent = this$1; }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n      var this$1 = this;\n\n    if (this.explicitlyCleared) { return }\n    this.explicitlyCleared = true;\n    for (var i = 0; i \u003c this.markers.length; ++i)\n      { this$1.markers[i].clear(); }\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj)\n  };\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) { options.widgetNode = widget.cloneNode(true); }\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i \u003c doc.linked.length; ++i)\n        { if (doc.linked[i].isParent) { return } }\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary)\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i \u003c markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function ( i ) {\n      var marker = markers[i], linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n      for (var j = 0; j \u003c marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i \u003c markers.length; i++) loop( i );\n  }\n\n  var nextDocId = 0;\n  var Doc = function(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n    if (firstLine == null) { firstLine = 0; }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") { text = this.splitLines(text); }\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) { this.iterN(from - this.first, to - from, op); }\n      else { this.iterN(this.first, this.first + this.size, from); }\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i \u003c lines.length; ++i) { height += lines[i].height; }\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l \u0026\u0026 l.text},\n\n    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n    getLineNumber: function(line) {return lineNo(line)},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") { line = getLine(this, line); }\n      return visualLine(line)\n    },\n\n    lineCount: function() {return this.size},\n    firstLine: function() {return this.first},\n    lastLine: function() {return this.first + this.size - 1},\n\n    clipPos: function(pos) {return clipPos(this, pos)},\n\n    getCursor: function(start) {\n      var range$$1 = this.sel.primary(), pos;\n      if (start == null || start == \"head\") { pos = range$$1.head; }\n      else if (start == \"anchor\") { pos = range$$1.anchor; }\n      else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\n      else { pos = range$$1.from(); }\n      return pos\n    },\n    listSelections: function() { return this.sel.ranges },\n    somethingSelected: function() {return this.sel.somethingSelected()},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other \u0026\u0026 clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      var this$1 = this;\n\n      if (!ranges.length) { return }\n      var out = [];\n      for (var i = 0; i \u003c ranges.length; i++)\n        { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\n                           clipPos(this$1, ranges[i].head)); }\n      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var this$1 = this;\n\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i \u003c ranges.length; i++) {\n        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) { return lines }\n      else { return lines.join(lineSep || this.lineSeparator()) }\n    },\n    getSelections: function(lineSep) {\n      var this$1 = this;\n\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i \u003c ranges.length; i++) {\n        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\n        parts[i] = sel;\n      }\n      return parts\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i \u003c this.sel.ranges.length; i++)\n        { dup[i] = code; }\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var this$1 = this;\n\n      var changes = [], sel = this.sel;\n      for (var i = 0; i \u003c sel.ranges.length; i++) {\n        var range$$1 = sel.ranges[i];\n        changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse \u0026\u0026 collapse != \"end\" \u0026\u0026 computeReplacedSel(this, changes, collapse);\n      for (var i$1 = changes.length - 1; i$1 \u003e= 0; i$1--)\n        { makeChange(this$1, changes[i$1]); }\n      if (newSel) { setSelectionReplaceHistory(this, newSel); }\n      else if (this.cm) { ensureCursorVisible(this.cm); }\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i \u003c hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n      for (var i$1 = 0; i$1 \u003c hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n      return {undo: done, redo: undone}\n    },\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n      return this.history.generation\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration)\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)}\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    setGutterMarker: docMethodOp(function(line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value \u0026\u0026 isEmpty(markers)) { line.gutterMarkers = null; }\n        return true\n      })\n    }),\n\n    clearGutter: docMethodOp(function(gutterID) {\n      var this$1 = this;\n\n      this.iter(function (line) {\n        if (line.gutterMarkers \u0026\u0026 line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n            return true\n          });\n        }\n      });\n    }),\n\n    lineInfo: function(line) {\n      var n;\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) { return null }\n        n = line;\n        line = getLine(this, line);\n        if (!line) { return null }\n      } else {\n        n = lineNo(line);\n        if (n == null) { return null }\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets}\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) { line[prop] = cls; }\n        else if (classTest(cls).test(line[prop])) { return false }\n        else { line[prop] += \" \" + cls; }\n        return true\n      })\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) { return false }\n        else if (cls == null) { line[prop] = null; }\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) { return false }\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true\n      })\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options)\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options \u0026\u0026 options.type || \"range\")\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options \u0026\u0026 (options.nodeType == null ? options.widget : options),\n                      insertLeft: options \u0026\u0026 options.insertLeft,\n                      clearWhenEmpty: false, shared: options \u0026\u0026 options.shared,\n                      handleMouseEvents: options \u0026\u0026 options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\")\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) { for (var i = 0; i \u003c spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from \u003c= pos.ch) \u0026\u0026\n            (span.to == null || span.to \u003e= pos.ch))\n          { markers.push(span.marker.parent || span.marker); }\n      } }\n      return markers\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo$$1 = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n        if (spans) { for (var i = 0; i \u003c spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null \u0026\u0026 lineNo$$1 == from.line \u0026\u0026 from.ch \u003e= span.to ||\n                span.from == null \u0026\u0026 lineNo$$1 != from.line ||\n                span.from != null \u0026\u0026 lineNo$$1 == to.line \u0026\u0026 span.from \u003e= to.ch) \u0026\u0026\n              (!filter || filter(span.marker)))\n            { found.push(span.marker.parent || span.marker); }\n        } }\n        ++lineNo$$1;\n      });\n      return found\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n        if (sps) { for (var i = 0; i \u003c sps.length; ++i)\n          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n      });\n      return markers\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n        if (sz \u003e off) { ch = off; return true }\n        off -= sz;\n        ++lineNo$$1;\n      });\n      return clipPos(this, Pos(lineNo$$1, ch))\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line \u003c this.first || coords.ch \u003c 0) { return 0 }\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc\n    },\n\n    linkedDoc: function(options) {\n      if (!options) { options = {}; }\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null \u0026\u0026 options.from \u003e from) { from = options.from; }\n      if (options.to != null \u0026\u0026 options.to \u003c to) { to = options.to; }\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n      if (options.sharedHist) { copy.history = this.history\n      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy\n    },\n    unlinkDoc: function(other) {\n      var this$1 = this;\n\n      if (other instanceof CodeMirror) { other = other.doc; }\n      if (this.linked) { for (var i = 0; i \u003c this.linked.length; ++i) {\n        var link = this$1.linked[i];\n        if (link.doc != other) { continue }\n        this$1.linked.splice(i, 1);\n        other.unlinkDoc(this$1);\n        detachSharedMarkers(findSharedMarkers(this$1));\n        break\n      } }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode},\n    getEditor: function() {return this.cm},\n\n    splitLines: function(str) {\n      if (this.lineSep) { return str.split(this.lineSep) }\n      return splitLinesAuto(str)\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") { dir = \"ltr\"; }\n      if (dir == this.direction) { return }\n      this.direction = dir;\n      this.iter(function (line) { return line.order = null; });\n      if (this.cm) { directionChanged(this.cm); }\n    })\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      { return }\n    e_preventDefault(e);\n    if (ie) { lastDrop = +new Date; }\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) { return }\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files \u0026\u0026 files.length \u0026\u0026 window.FileReader \u0026\u0026 window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function (file, i) {\n        if (cm.options.allowDropFileTypes \u0026\u0026\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n          { return }\n\n        var reader = new FileReader;\n        reader.onload = operation(cm, function () {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\n          text[i] = content;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n      for (var i = 0; i \u003c n; ++i) { loadFile(files[i], i); }\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText \u0026\u0026 cm.doc.sel.contains(pos) \u003e -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function () { return cm.display.input.focus(); }, 20);\n        return\n      }\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n        if (text$1) {\n          var selected;\n          if (cm.state.draggingText \u0026\u0026 !cm.state.draggingText.copy)\n            { selected = cm.listSelections(); }\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) { for (var i$1 = 0; i$1 \u003c selected.length; ++i$1)\n            { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie \u0026\u0026 (!cm.state.draggingText || +new Date - lastDrop \u003c 100)) { e_stop(e); return }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\";\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage \u0026\u0026 !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) { img.parentNode.removeChild(img); }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) { return }\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) { return }\n    var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\n    for (var i = 0; i \u003c byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) { editors.push(cm); }\n    }\n    if (editors.length) { editors[0].operation(function () {\n      for (var i = 0; i \u003c editors.length; i++) { f(editors[i]); }\n    }); }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) { return }\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100); }\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n  }\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 145: \"ScrollLock\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n\n  // Number keys\n  for (var i = 0; i \u003c 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n  // Alphabetic keys\n  for (var i$1 = 65; i$1 \u003c= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n  // Function keys\n  for (var i$2 = 1; i$2 \u003c= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\n  var keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n    \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i \u003c parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n      else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n      else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n      else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n    }\n    if (alt) { name = \"Alt-\" + name; }\n    if (ctrl) { name = \"Ctrl-\" + name; }\n    if (cmd) { name = \"Cmd-\" + name; }\n    if (shift) { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n      if (value == \"...\") { delete keymap[keyname]; continue }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i \u003c keys.length; i++) {\n        var val = (void 0), name = (void 0);\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) { copy[name] = val; }\n        else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n      }\n      delete keymap[keyname];\n    } }\n    for (var prop in copy) { keymap[prop] = copy[prop]; }\n    return keymap\n  }\n\n  function lookupKey(key, map$$1, handle, context) {\n    map$$1 = getKeyMap(map$$1);\n    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n    if (found === false) { return \"nothing\" }\n    if (found === \"...\") { return \"multi\" }\n    if (found != null \u0026\u0026 handle(found)) { return \"handled\" }\n\n    if (map$$1.fallthrough) {\n      if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\n        { return lookupKey(key, map$$1.fallthrough, handle, context) }\n      for (var i = 0; i \u003c map$$1.fallthrough.length; i++) {\n        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n        if (result) { return result }\n      }\n    }\n  }\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n    if (event.altKey \u0026\u0026 base != \"Alt\") { name = \"Alt-\" + name; }\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) \u0026\u0026 base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) \u0026\u0026 base != \"Cmd\") { name = \"Cmd-\" + name; }\n    if (!noShift \u0026\u0026 event.shiftKey \u0026\u0026 base != \"Shift\") { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // Look up the name of a key as indicated by an event object.\n  function keyName(event, noShift) {\n    if (presto \u0026\u0026 event.keyCode == 34 \u0026\u0026 event[\"char\"]) { return false }\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) { return false }\n    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n    if (event.keyCode == 3 \u0026\u0026 event.code) { name = event.code; }\n    return addModifierNames(name, event, noShift)\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i \u003c ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length \u0026\u0026 cmp(toKill.from, lst(kill).to) \u003c= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) \u003c 0) {\n          toKill.from = replaced.from;\n          break\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i \u003e= 0; i--)\n        { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target \u003c 0 || target \u003e line.text.length ? null : target\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir \u003c 0 ? \"after\" : \"before\")\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      var order = getOrder(lineObj, cm.doc.direction);\n      if (order) {\n        var part = dir \u003c 0 ? lst(order) : order[0];\n        var moveInStorageOrder = (dir \u003c 0) == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch;\n        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n        if (part.level \u003e 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir \u003c 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir \u003c 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n          if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n        } else { ch = dir \u003c 0 ? part.to : part.from; }\n        return new Pos(lineNo, ch, sticky)\n      }\n    }\n    return new Pos(lineNo, dir \u003c 0 ? lineObj.text.length : 0, dir \u003c 0 ? \"before\" : \"after\")\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n    if (!bidi) { return moveLogically(line, start, dir) }\n    if (start.ch \u003e= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch \u003c= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n    if (cm.doc.direction == \"ltr\" \u0026\u0026 part.level % 2 == 0 \u0026\u0026 (dir \u003e 0 ? part.to \u003e start.ch : part.from \u003c start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir)\n    }\n\n    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n    var prep;\n    var getWrappedLineExtent = function (ch) {\n      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch)\n    };\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = (part.level == 1) == (dir \u003c 0);\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n      if (ch != null \u0026\u0026 (!moveInStorageOrder ? ch \u003e= part.from \u0026\u0026 ch \u003e= wrappedLineExtent.begin : ch \u003c= part.to \u0026\u0026 ch \u003c= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky)\n      }\n    }\n\n    // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n        ? new Pos(start.line, mv(ch, 1), \"before\")\n        : new Pos(start.line, ch, \"after\"); };\n\n      for (; partPos \u003e= 0 \u0026\u0026 partPos \u003c bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = (dir \u003e 0) == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n        if (part.from \u003c= ch \u0026\u0026 ch \u003c part.to) { return getRes(ch, moveInStorageOrder) }\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n        if (wrappedLineExtent.begin \u003c= ch \u0026\u0026 ch \u003c wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n      }\n    };\n\n    // Case 3a: Look for other bidi parts on the same visual line\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n    if (res) { return res }\n\n    // Case 3b: Look for other bidi parts on the next visual line\n    var nextCh = dir \u003e 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n    if (nextCh != null \u0026\u0026 !(dir \u003e 0 \u0026\u0026 nextCh == line.text.length)) {\n      res = searchInVisualLine(dir \u003e 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n      if (res) { return res }\n    }\n\n    // Case 4: Nowhere to move\n    return null\n  }\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n    killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n      if (range.empty()) {\n        var len = getLine(cm.doc, range.head.line).text.length;\n        if (range.head.ch == len \u0026\u0026 range.head.line \u003c cm.lastLine())\n          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n        else\n          { return {from: range.head, to: Pos(range.head.line, len)} }\n      } else {\n        return {from: range.from(), to: range.to()}\n      }\n    }); },\n    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0),\n      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n    }); }); },\n    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0), to: range.from()\n    }); }); },\n    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n      return {from: leftPos, to: range.from()}\n    }); },\n    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      return {from: range.from(), to: rightPos }\n    }); },\n    undo: function (cm) { return cm.undo(); },\n    redo: function (cm) { return cm.redo(); },\n    undoSelection: function (cm) { return cm.undoSelection(); },\n    redoSelection: function (cm) { return cm.redoSelection(); },\n    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n      {origin: \"+move\", bias: -1}\n    ); },\n    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: 0, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n      if (pos.ch \u003c cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n      return pos\n    }, sel_move); },\n    goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n    goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n    goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n    goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n    goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n    goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n    goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n    goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n    goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n    goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n    goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n    goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n    delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\n    delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n    delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n    delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n    delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n    delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n    indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n    indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n    indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n    insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n    insertSoftTab: function (cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i \u003c ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function (cm) {\n      if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n      else { cm.execCommand(\"insertTab\"); }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function (cm) { return runInOp(cm, function () {\n      var ranges = cm.listSelections(), newSel = [];\n      for (var i = 0; i \u003c ranges.length; i++) {\n        if (!ranges[i].empty()) { continue }\n        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n        if (line) {\n          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n          if (cur.ch \u003e 0) {\n            cur = new Pos(cur.line, cur.ch + 1);\n            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                            Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n          } else if (cur.line \u003e cm.doc.first) {\n            var prev = getLine(cm.doc, cur.line - 1).text;\n            if (prev) {\n              cur = new Pos(cur.line, 1);\n              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                              prev.charAt(prev.length - 1),\n                              Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n            }\n          }\n        }\n        newSel.push(new Range(cur, cur));\n      }\n      cm.setSelections(newSel);\n    }); },\n    newlineAndIndent: function (cm) { return runInOp(cm, function () {\n      var sels = cm.listSelections();\n      for (var i = sels.length - 1; i \u003e= 0; i--)\n        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n      sels = cm.listSelections();\n      for (var i$1 = 0; i$1 \u003c sels.length; i$1++)\n        { cm.indentLine(sels[i$1].from().line, null, true); }\n      ensureCursorVisible(cm);\n    }); },\n    openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n  };\n\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, visual, lineN, 1)\n  }\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, line, lineN, -1)\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line \u0026\u0026 pos.ch \u003c= firstNonWS \u0026\u0026 pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n    }\n    return start\n  }\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) { return false }\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      if (dropShift) { cm.display.shift = false; }\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i \u003c cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) { return result }\n    }\n    return (cm.options.extraKeys \u0026\u0026 lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm)\n  }\n\n  // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n  var stopSeq = new Delayed;\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) { return \"handled\" }\n      if (/\\'$/.test(name))\n        { cm.state.keySeq = null; }\n      else\n        { stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        }); }\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\n    }\n    return dispatchKeyInner(cm, name, e, handle)\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      { cm.state.keySeq = name; }\n    if (result == \"handled\")\n      { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) { return false }\n\n    if (e.shiftKey \u0026\u0026 !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n          || dispatchKey(cm, name, e, function (b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 { return doHandleBinding(cm, b) }\n             })\n    } else {\n      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) { return }\n    // IE does strange things with escape.\n    if (ie \u0026\u0026 ie_version \u003c 11 \u0026\u0026 e.keyCode == 27) { e.returnValue = false; }\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled \u0026\u0026 code == 88 \u0026\u0026 !hasCopyEvent \u0026\u0026 (mac ? e.metaKey : e.ctrlKey))\n        { cm.replaceSelection(\"\", null, \"cut\"); }\n    }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 \u0026\u0026 !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      { showCrossHair(cm); }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) { this.doc.sel.shift = false; }\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey \u0026\u0026 !e.altKey || mac \u0026\u0026 e.metaKey) { return }\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto \u0026\u0026 keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n    if ((presto \u0026\u0026 (!e.which || e.which \u003c 10)) \u0026\u0026 handleKeyBinding(cm, e)) { return }\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    // Some browsers fire keypress events for backspace\n    if (ch == \"\\x08\") { return }\n    if (handleCharBinding(cm, e, ch)) { return }\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY \u003e time \u0026\u0026\n      cmp(pos, this.pos) == 0 \u0026\u0026 button == this.button\n  };\n\n  var lastClick, lastDoubleClick;\n  function clickRepeat(pos, button) {\n    var now = +new Date;\n    if (lastDoubleClick \u0026\u0026 lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\"\n    } else if (lastClick \u0026\u0026 lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\"\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\"\n    }\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch \u0026\u0026 display.input.supportsTouch()) { return }\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () { return display.scroller.draggable = true; }, 100);\n      }\n      return\n    }\n    if (clickInGutter(cm, e)) { return }\n    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n    window.focus();\n\n    // #3261: make sure, that we're not starting a second selection\n    if (button == 1 \u0026\u0026 cm.state.selectingText)\n      { cm.state.selectingText(e); }\n\n    if (pos \u0026\u0026 handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n    if (button == 1) {\n      if (pos) { leftButtonDown(cm, pos, repeat, e); }\n      else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n    } else if (button == 2) {\n      if (pos) { extendSelection(cm.doc, pos); }\n      setTimeout(function () { return display.input.focus(); }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) { cm.display.input.onContextMenu(e); }\n      else { delayBlurEvent(cm); }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n    if (repeat == \"double\") { name = \"Double\" + name; }\n    else if (repeat == \"triple\") { name = \"Triple\" + name; }\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") { bound = commands[bound]; }\n      if (!bound) { return false }\n      var done = false;\n      try {\n        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n      return done\n    })\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey \u0026\u0026 event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n    return value\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n    else { cm.curOp.focus = activeElt(); }\n\n    var behavior = configureMouse(cm, repeat, event);\n\n    var sel = cm.doc.sel, contained;\n    if (cm.options.dragDrop \u0026\u0026 dragAndDrop \u0026\u0026 !cm.isReadOnly() \u0026\u0026\n        repeat == \"single\" \u0026\u0026 (contained = sel.contains(pos)) \u003e -1 \u0026\u0026\n        (cmp((contained = sel.ranges[contained]).from(), pos) \u003c 0 || pos.xRel \u003e 0) \u0026\u0026\n        (cmp(contained.to(), pos) \u003e 0 || pos.xRel \u003c 0))\n      { leftButtonStartDrag(cm, event, pos, behavior); }\n    else\n      { leftButtonSelect(cm, event, pos, behavior); }\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display, moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) { display.scroller.draggable = false; }\n      cm.state.draggingText = false;\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n      if (!moved) {\n        e_preventDefault(e);\n        if (!behavior.addNew)\n          { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if (webkit || ie \u0026\u0026 ie_version == 9)\n          { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }\n        else\n          { display.input.focus(); }\n      }\n    });\n    var mouseMove = function(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) \u003e= 10;\n    };\n    var dragStart = function () { return moved = true; };\n    // Let the drag handler handle this.\n    if (webkit) { display.scroller.draggable = true; }\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n\n    delayBlurEvent(cm);\n    setTimeout(function () { return display.input.focus(); }, 20);\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") { return new Range(pos, pos) }\n    if (unit == \"word\") { return cm.findWordAt(pos) }\n    if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to)\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, event, start, behavior) {\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(event);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (behavior.addNew \u0026\u0026 !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex \u003e -1)\n        { ourRange = ranges[ourIndex]; }\n      else\n        { ourRange = new Range(start, start); }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) { ourRange = new Range(start, start); }\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range$$1 = rangeForUnit(cm, start, behavior.unit);\n      if (behavior.extend)\n        { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }\n      else\n        { ourRange = range$$1; }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length \u003e 1 \u0026\u0026 ranges[ourIndex].empty() \u0026\u0026 behavior.unit == \"char\" \u0026\u0026 !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) { return }\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line \u003c= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n          else if (text.length \u003e leftPos)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n        }\n        if (!ranges.length) { ranges.push(new Range(start, start)); }\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range$$1 = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor, head;\n        if (cmp(range$$1.anchor, anchor) \u003e 0) {\n          head = range$$1.head;\n          anchor = minPos(oldRange.from(), range$$1.anchor);\n        } else {\n          head = range$$1.anchor;\n          anchor = maxPos(oldRange.to(), range$$1.head);\n        }\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n      if (!cur) { return }\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line \u003e= visible.to || cur.line \u003c visible.from)\n          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n      } else {\n        var outside = e.clientY \u003c editorSize.top ? -20 : e.clientY \u003e editorSize.bottom ? 20 : 0;\n        if (outside) { setTimeout(operation(cm, function () {\n          if (counter != curCount) { return }\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50); }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      // If e is null or undefined we interpret this as someone trying\n      // to explicitly cancel the selection rather than the user\n      // letting go of the mouse button.\n      if (e) {\n        e_preventDefault(e);\n        display.input.focus();\n      }\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) { done(e); }\n      else { extend(e); }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  }\n\n  // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n  function bidiSimplify(cm, range$$1) {\n    var anchor = range$$1.anchor;\n    var head = range$$1.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n    if (cmp(anchor, head) == 0 \u0026\u0026 anchor.sticky == head.sticky) { return range$$1 }\n    var order = getOrder(anchorLine);\n    if (!order) { return range$$1 }\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n    if (part.from != anchor.ch \u0026\u0026 part.to != anchor.ch) { return range$$1 }\n    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n    if (boundary == 0 || boundary == order.length) { return range$$1 }\n\n    // Compute the relative visual position of the head compared to the\n    // anchor (\u003c0 is to the left, \u003e0 to the right)\n    var leftSide;\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) \u003e 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n      if (headIndex == boundary - 1 || headIndex == boundary)\n        { leftSide = dir \u003c 0; }\n      else\n        { leftSide = dir \u003e 0; }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch \u0026\u0026 anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)\n  }\n\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try { mX = e.clientX; mY = e.clientY; }\n      catch(e) { return false }\n    }\n    if (mX \u003e= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n    if (prevent) { e_preventDefault(e); }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY \u003e lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i \u003c cm.display.gutterSpecs.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g \u0026\u0026 g.getBoundingClientRect().right \u003e= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.display.gutterSpecs[i];\n        signal(cm, type, cm, line, gutter.className, e);\n        return e_defaultPrevented(e)\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true)\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n    if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n    if (!captureRightClick) { cm.display.input.onContextMenu(e); }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n    return gutterEvent(cm, e, \"gutterContextMenu\", false)\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {toString: function(){return \"CodeMirror.Init\"}};\n\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n      if (handle) { optionHandlers[name] =\n        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n    }\n\n    CodeMirror.defineOption = option;\n\n    // Passed to option handlers when there is no old value.\n    CodeMirror.Init = Init;\n\n    // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n    option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n      if (!val) { return }\n      var newBreaks = [], lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n          if (found == -1) { break }\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n        lineNo++;\n      });\n      for (var i = newBreaks.length - 1; i \u003e= 0; i--)\n        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n      if (old != Init) { cm.refresh(); }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n    option(\"autocorrect\", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);\n    option(\"autocapitalize\", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      updateGutters(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init \u0026\u0026 getKeyMap(old);\n      if (prev \u0026\u0026 prev.detach) { prev.detach(cm, next); }\n      if (next.attach) { next.attach(cm, prev || null); }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm, val) {\n      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n      updateGutters(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm, val) {\n      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n      updateGutters(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, updateGutters, true);\n    option(\"lineNumberFormatter\", function (integer) { return integer; }, updateGutters, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n      cm.display.input.readOnlyChanged(val);\n    });\n    option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) { cm.display.input.resetPosition(); }\n    });\n\n    option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n    option(\"phrases\", null);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old \u0026\u0026 old != Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () { return updateScrollbars(cm); }, 100);\n  }\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n    else if (options.mode) { doc.modeOption = options.mode; }\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input, options);\n    display.wrapper.CodeMirror = this;\n    themeChanged(this);\n    if (options.lineWrapping)\n      { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus \u0026\u0026 !mobile) { display.input.focus(); }\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie \u0026\u0026 ie_version \u003c 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus \u0026\u0026 !mobile) || this.hasFocus())\n      { setTimeout(bind(onFocus, this), 20); }\n    else\n      { onBlur(this); }\n\n    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n      { optionHandlers[opt](this$1, options[opt], Init); } }\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) { options.finishInit(this); }\n    for (var i = 0; i \u003c initHooks.length; ++i) { initHooks[i](this$1); }\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit \u0026\u0026 options.lineWrapping \u0026\u0026\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      { display.lineDiv.style.textRendering = \"auto\"; }\n  }\n\n  // The default configuration options.\n  CodeMirror.defaults = defaults;\n  // Functions to run when options are changed.\n  CodeMirror.optionHandlers = optionHandlers;\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie \u0026\u0026 ie_version \u003c 11)\n      { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) { return }\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      })); }\n    else\n      { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); });\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    }\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) { return false }\n      var touch = e.touches[0];\n      return touch.radiusX \u003c= 1 \u0026\u0026 touch.radiusY \u003c= 1\n    }\n    function farAway(touch, other) {\n      if (other.left == null) { return true }\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy \u003e 20 * 20\n    }\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) \u0026\u0026 !isMouseLikeTouchEvent(e) \u0026\u0026 !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end \u003c= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) { d.activeTouch.moved = true; }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n      if (touch \u0026\u0026 !eventInWidget(d, e) \u0026\u0026 touch.left != null \u0026\u0026\n          !touch.moved \u0026\u0026 new Date - touch.start \u003c 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          { range = new Range(pos, pos); }\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          { range = cm.findWordAt(pos); }\n        else // Triple tap\n          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n    on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function (e) { return onDragStart(cm, e); },\n      drop: operation(cm, onDrop),\n      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n    on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n  }\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) { how = \"add\"; }\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) { how = \"prev\"; }\n      else { state = getContextBefore(cm, n).state; }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) { line.stateAfter = null; }\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive \u0026\u0026 !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation \u003e 150) {\n        if (!aggressive) { return }\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n \u003e doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n      else { indentation = 0; }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n    if (pos \u003c indentation) { indentString += spaceStr(indentation - pos); }\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 \u003c doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n        if (range.head.line == n \u0026\u0026 range.head.ch \u003c curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break\n        }\n      }\n    }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) { sel = doc.sel; }\n\n    var recent = +new Date - 200;\n    var paste = origin == \"paste\" || cm.state.pasteIncoming \u003e recent;\n    var textLines = splitLinesAuto(inserted), multiPaste = null;\n    // When pasting N lines into N selections, insert one line per selection\n    if (paste \u0026\u0026 sel.ranges.length \u003e 1) {\n      if (lastCopied \u0026\u0026 lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i \u003c lastCopied.text.length; i++)\n            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n        }\n      } else if (textLines.length == sel.ranges.length \u0026\u0026 cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) { return [l]; });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput;\n    // Normal behavior is to insert the new text into every selection\n    for (var i$1 = sel.ranges.length - 1; i$1 \u003e= 0; i$1--) {\n      var range$$1 = sel.ranges[i$1];\n      var from = range$$1.from(), to = range$$1.to();\n      if (range$$1.empty()) {\n        if (deleted \u0026\u0026 deleted \u003e 0) // Handle deletion\n          { from = Pos(from.line, from.ch - deleted); }\n        else if (cm.state.overwrite \u0026\u0026 !paste) // Handle overwrite\n          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n        else if (paste \u0026\u0026 lastCopied \u0026\u0026 lastCopied.lineWise \u0026\u0026 lastCopied.text.join(\"\\n\") == inserted)\n          { from = to = Pos(from.line, 0); }\n      }\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming \u003e recent ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted \u0026\u0026 !paste)\n      { triggerElectric(cm, inserted); }\n\n    ensureCursorVisible(cm);\n    if (cm.curOp.updateInput \u003c 2) { cm.curOp.updateInput = updateInput; }\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData \u0026\u0026 e.clipboardData.getData(\"Text\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() \u0026\u0026 !cm.options.disableInput)\n        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n      return true\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i \u003e= 0; i--) {\n      var range$$1 = sel.ranges[i];\n      if (range$$1.head.ch \u003e 100 || (i \u0026\u0026 sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\n      var mode = cm.getModeAt(range$$1.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j \u003c mode.electricChars.length; j++)\n          { if (inserted.indexOf(mode.electricChars.charAt(j)) \u003e -1) {\n            indented = indentLine(cm, range$$1.head.line, \"smart\");\n            break\n          } }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\n          { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\n      }\n      if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i \u003c cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges}\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute(\"autocorrect\", autocorrect ? \"\" : \"off\");\n    field.setAttribute(\"autocapitalize\", autocapitalize ? \"\" : \"off\");\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) { te.style.width = \"1000px\"; }\n    else { te.setAttribute(\"wrap\", \"off\"); }\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) { te.style.border = \"1px solid black\"; }\n    disableBrowserMagic(te);\n    return div\n  }\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    var helpers = CodeMirror.helpers = {};\n\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function(){window.focus(); this.display.input.focus();},\n\n      setOption: function(option, value) {\n        var options = this.options, old = options[option];\n        if (options[option] == value \u0026\u0026 option != \"mode\") { return }\n        options[option] = value;\n        if (optionHandlers.hasOwnProperty(option))\n          { operation(this, optionHandlers[option])(this, value, old); }\n        signal(this, \"optionChange\", this, option);\n      },\n\n      getOption: function(option) {return this.options[option]},\n      getDoc: function() {return this.doc},\n\n      addKeyMap: function(map$$1, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n      },\n      removeKeyMap: function(map$$1) {\n        var maps = this.state.keyMaps;\n        for (var i = 0; i \u003c maps.length; ++i)\n          { if (maps[i] == map$$1 || maps[i].name == map$$1) {\n            maps.splice(i, 1);\n            return true\n          } }\n      },\n\n      addOverlay: methodOp(function(spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n        if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n        insertSorted(this.state.overlays,\n                     {mode: mode, modeSpec: spec, opaque: options \u0026\u0026 options.opaque,\n                      priority: (options \u0026\u0026 options.priority) || 0},\n                     function (overlay) { return overlay.priority; });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function(spec) {\n        var this$1 = this;\n\n        var overlays = this.state.overlays;\n        for (var i = 0; i \u003c overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n          if (cur == spec || typeof spec == \"string\" \u0026\u0026 cur.name == spec) {\n            overlays.splice(i, 1);\n            this$1.state.modeGen++;\n            regChange(this$1);\n            return\n          }\n        }\n      }),\n\n      indentLine: methodOp(function(n, dir, aggressive) {\n        if (typeof dir != \"string\" \u0026\u0026 typeof dir != \"number\") {\n          if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n          else { dir = dir ? \"add\" : \"subtract\"; }\n        }\n        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n      }),\n      indentSelection: methodOp(function(how) {\n        var this$1 = this;\n\n        var ranges = this.doc.sel.ranges, end = -1;\n        for (var i = 0; i \u003c ranges.length; i++) {\n          var range$$1 = ranges[i];\n          if (!range$$1.empty()) {\n            var from = range$$1.from(), to = range$$1.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n            for (var j = start; j \u003c end; ++j)\n              { indentLine(this$1, j, how); }\n            var newRanges = this$1.doc.sel.ranges;\n            if (from.ch == 0 \u0026\u0026 ranges.length == newRanges.length \u0026\u0026 newRanges[i].from().ch \u003e 0)\n              { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n          } else if (range$$1.head.line \u003e end) {\n            indentLine(this$1, range$$1.head.line, how, true);\n            end = range$$1.head.line;\n            if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\n          }\n        }\n      }),\n\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function(pos, precise) {\n        return takeToken(this, pos, precise)\n      },\n\n      getLineTokens: function(line, precise) {\n        return takeToken(this, Pos(line), precise, true)\n      },\n\n      getTokenTypeAt: function(pos) {\n        pos = clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n        var type;\n        if (ch == 0) { type = styles[2]; }\n        else { for (;;) {\n          var mid = (before + after) \u003e\u003e 1;\n          if ((mid ? styles[mid * 2 - 1] : 0) \u003e= ch) { after = mid; }\n          else if (styles[mid * 2 + 1] \u003c ch) { before = mid + 1; }\n          else { type = styles[mid * 2 + 2]; break }\n        } }\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut \u003c 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n      },\n\n      getModeAt: function(pos) {\n        var mode = this.doc.mode;\n        if (!mode.innerMode) { return mode }\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n      },\n\n      getHelper: function(pos, type) {\n        return this.getHelpers(pos, type)[0]\n      },\n\n      getHelpers: function(pos, type) {\n        var this$1 = this;\n\n        var found = [];\n        if (!helpers.hasOwnProperty(type)) { return found }\n        var help = helpers[type], mode = this.getModeAt(pos);\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) { found.push(help[mode[type]]); }\n        } else if (mode[type]) {\n          for (var i = 0; i \u003c mode[type].length; i++) {\n            var val = help[mode[type][i]];\n            if (val) { found.push(val); }\n          }\n        } else if (mode.helperType \u0026\u0026 help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n        for (var i$1 = 0; i$1 \u003c help._global.length; i$1++) {\n          var cur = help._global[i$1];\n          if (cur.pred(mode, this$1) \u0026\u0026 indexOf(found, cur.val) == -1)\n            { found.push(cur.val); }\n        }\n        return found\n      },\n\n      getStateAfter: function(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n        return getContextBefore(this, line + 1, precise).state\n      },\n\n      cursorCoords: function(start, mode) {\n        var pos, range$$1 = this.doc.sel.primary();\n        if (start == null) { pos = range$$1.head; }\n        else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n        else { pos = start ? range$$1.from() : range$$1.to(); }\n        return cursorCoords(this, pos, mode || \"page\")\n      },\n\n      charCoords: function(pos, mode) {\n        return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n      },\n\n      coordsChar: function(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return coordsChar(this, coords.left, coords.top)\n      },\n\n      lineAtHeight: function(height, mode) {\n        height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n        return lineAtHeight(this.doc, height + this.display.viewOffset)\n      },\n      heightAtLine: function(line, mode, includeWidgets) {\n        var end = false, lineObj;\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n          if (line \u003c this.doc.first) { line = this.doc.first; }\n          else if (line \u003e last) { line = last; end = true; }\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n          (end ? this.doc.height - heightAtLine(lineObj) : 0)\n      },\n\n      defaultTextHeight: function() { return textHeight(this.display) },\n      defaultCharWidth: function() { return charWidth(this.display) },\n\n      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = cursorCoords(this, clipPos(this.doc, pos));\n        var top = pos.bottom, left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n          // Default to positioning above (if specified and possible); otherwise default to positioning below\n          if ((vert == 'above' || pos.bottom + node.offsetHeight \u003e vspace) \u0026\u0026 pos.top \u003e node.offsetHeight)\n            { top = pos.top - node.offsetHeight; }\n          else if (pos.bottom + node.offsetHeight \u003c= vspace)\n            { top = pos.bottom; }\n          if (left + node.offsetWidth \u003e hspace)\n            { left = hspace - node.offsetWidth; }\n        }\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") { left = 0; }\n          else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n          node.style.left = left + \"px\";\n        }\n        if (scroll)\n          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n      },\n\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n\n      execCommand: function(cmd) {\n        if (commands.hasOwnProperty(cmd))\n          { return commands[cmd].call(null, this) }\n      },\n\n      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n      findPosH: function(from, amount, unit, visually) {\n        var this$1 = this;\n\n        var dir = 1;\n        if (amount \u003c 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i \u003c amount; ++i) {\n          cur = findPosH(this$1.doc, cur, dir, unit, visually);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveH: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        this.extendSelectionsBy(function (range$$1) {\n          if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\n            { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\n          else\n            { return dir \u003c 0 ? range$$1.from() : range$$1.to() }\n        }, sel_move);\n      }),\n\n      deleteH: methodOp(function(dir, unit) {\n        var sel = this.doc.sel, doc = this.doc;\n        if (sel.somethingSelected())\n          { doc.replaceSelection(\"\", null, \"+delete\"); }\n        else\n          { deleteNearSelection(this, function (range$$1) {\n            var other = findPosH(doc, range$$1.head, dir, unit, false);\n            return dir \u003c 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\n          }); }\n      }),\n\n      findPosV: function(from, amount, unit, goalColumn) {\n        var this$1 = this;\n\n        var dir = 1, x = goalColumn;\n        if (amount \u003c 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i \u003c amount; ++i) {\n          var coords = cursorCoords(this$1, cur, \"div\");\n          if (x == null) { x = coords.left; }\n          else { coords.left = x; }\n          cur = findPosV(this$1, coords, dir, unit);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveV: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        var doc = this.doc, goals = [];\n        var collapse = !this.display.shift \u0026\u0026 !doc.extend \u0026\u0026 doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range$$1) {\n          if (collapse)\n            { return dir \u003c 0 ? range$$1.from() : range$$1.to() }\n          var headPos = cursorCoords(this$1, range$$1.head, \"div\");\n          if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\n          goals.push(headPos.left);\n          var pos = findPosV(this$1, headPos, dir, unit);\n          if (unit == \"page\" \u0026\u0026 range$$1 == doc.sel.primary())\n            { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n          return pos\n        }, sel_move);\n        if (goals.length) { for (var i = 0; i \u003c doc.sel.ranges.length; i++)\n          { doc.sel.ranges[i].goalColumn = goals[i]; } }\n      }),\n\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function(pos) {\n        var doc = this.doc, line = getLine(doc, pos.line).text;\n        var start = pos.ch, end = pos.ch;\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n          if ((pos.sticky == \"before\" || end == line.length) \u0026\u0026 start) { --start; } else { ++end; }\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper)\n            ? function (ch) { return isWordChar(ch, helper); }\n            : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n            : function (ch) { return (!/\\s/.test(ch) \u0026\u0026 !isWordChar(ch)); };\n          while (start \u003e 0 \u0026\u0026 check(line.charAt(start - 1))) { --start; }\n          while (end \u003c line.length \u0026\u0026 check(line.charAt(end))) { ++end; }\n        }\n        return new Range(Pos(pos.line, start), Pos(pos.line, end))\n      },\n\n      toggleOverwrite: function(value) {\n        if (value != null \u0026\u0026 value == this.state.overwrite) { return }\n        if (this.state.overwrite = !this.state.overwrite)\n          { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n        else\n          { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function() { return this.display.input.getField() == activeElt() },\n      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n      getScrollInfo: function() {\n        var scroller = this.display.scroller;\n        return {left: scroller.scrollLeft, top: scroller.scrollTop,\n                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n      },\n\n      scrollIntoView: methodOp(function(range$$1, margin) {\n        if (range$$1 == null) {\n          range$$1 = {from: this.doc.sel.primary().head, to: null};\n          if (margin == null) { margin = this.options.cursorScrollMargin; }\n        } else if (typeof range$$1 == \"number\") {\n          range$$1 = {from: Pos(range$$1, 0), to: null};\n        } else if (range$$1.from == null) {\n          range$$1 = {from: range$$1, to: null};\n        }\n        if (!range$$1.to) { range$$1.to = range$$1.from; }\n        range$$1.margin = margin || 0;\n\n        if (range$$1.from.line != null) {\n          scrollToRange(this, range$$1);\n        } else {\n          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n        }\n      }),\n\n      setSize: methodOp(function(width, height) {\n        var this$1 = this;\n\n        var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n        if (width != null) { this.display.wrapper.style.width = interpret(width); }\n        if (height != null) { this.display.wrapper.style.height = interpret(height); }\n        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n        var lineNo$$1 = this.display.viewFrom;\n        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n          if (line.widgets) { for (var i = 0; i \u003c line.widgets.length; i++)\n            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\n          ++lineNo$$1;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n\n      operation: function(f){return runInOp(this, f)},\n      startOperation: function(){return startOperation(this)},\n      endOperation: function(){return endOperation(this)},\n\n      refresh: methodOp(function() {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this.display);\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) \u003e .5)\n          { estimateLineHeights(this); }\n        signal(this, \"refresh\", this);\n      }),\n\n      swapDoc: methodOp(function(doc) {\n        var old = this.doc;\n        old.cm = null;\n        // Cancel the current text selection if any (#5821)\n        if (this.state.selectingText) { this.state.selectingText(); }\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old\n      }),\n\n      phrase: function(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases \u0026\u0026 Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText\n      },\n\n      getInputField: function(){return this.display.input.getField()},\n      getWrapperElement: function(){return this.display.wrapper},\n      getScrollerElement: function(){return this.display.scroller},\n      getGutterElement: function(){return this.display.gutters}\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function(type, name, value) {\n      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n      helpers[type][name] = value;\n    };\n    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n      helpers[type]._global.push({pred: predicate, val: value});\n    };\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    function findNextLine() {\n      var l = pos.line + dir;\n      if (l \u003c doc.first || l \u003e= doc.first + doc.size) { return false }\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l)\n    }\n    function moveOnce(boundToLine) {\n      var next;\n      if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n      if (next == null) {\n        if (!boundToLine \u0026\u0026 findNextLine())\n          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\n        else\n          { return false }\n      } else {\n        pos = next;\n      }\n      return true\n    }\n\n    if (unit == \"char\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm \u0026\u0026 doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir \u003c 0 \u0026\u0026 !moveOnce(!first)) { break }\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group \u0026\u0026 cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group \u0026\u0026 !first \u0026\u0026 !type) { type = \"s\"; }\n        if (sawType \u0026\u0026 sawType != type) {\n          if (dir \u003c 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n          break\n        }\n\n        if (type) { sawType = type; }\n        if (dir \u003e 0 \u0026\u0026 !moveOnce(!first)) { break }\n      }\n    }\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n    return result\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir \u003e 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n    } else if (unit == \"line\") {\n      y = dir \u003e 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    var target;\n    for (;;) {\n      target = coordsChar(cm, x, y);\n      if (!target.outside) { break }\n      if (dir \u003c 0 ? y \u003c= 0 : y \u003e= doc.height) { target.hitSide = true; break }\n      y += dir * 5;\n    }\n    return target\n  }\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  var ContentEditableInput = function(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = input.cm;\n    var div = input.div = display.lineDiv;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n\n    on(div, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n      // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n      if (ie_version \u003c= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n    });\n\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {data: e.data, done: false};\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n        this$1.composing.done = true;\n      }\n    });\n\n    on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n    on(div, \"input\", function () {\n      if (!this$1.composing) { this$1.readFromDOMSoon(); }\n    });\n\n    function onCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n        if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\");\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        e.clipboardData.setData(\"Text\", content);\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return\n        }\n      }\n      // Old-fashioned briefly-focus-a-textarea hack\n      var kludge = hiddenTextarea(), te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = document.activeElement;\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n        if (hadFocus == div) { input.showPrimarySelection(); }\n      }, 50);\n    }\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = this.cm.state.focused;\n    return result\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) { return }\n    if (info.focus || takeFocus) { this.showPrimarySelection(); }\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection()\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n    var from = prim.from(), to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line \u003e= cm.display.viewTo || to.line \u003c cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (curAnchor \u0026\u0026 !curAnchor.bad \u0026\u0026 curFocus \u0026\u0026 !curFocus.bad \u0026\u0026\n        cmp(minPos(curAnchor, curFocus), from) == 0 \u0026\u0026\n        cmp(maxPos(curAnchor, curFocus), to) == 0)\n      { return }\n\n    var view = cm.display.view;\n    var start = (from.line \u003e= cm.display.viewFrom \u0026\u0026 posToDOM(cm, from)) ||\n        {node: view[0].measure.map[2], offset: 0};\n    var end = to.line \u003c cm.display.viewTo \u0026\u0026 posToDOM(cm, to);\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var old = sel.rangeCount \u0026\u0026 sel.getRangeAt(0), rng;\n    try { rng = range(start.node, start.offset, end.offset, end.node); }\n    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n    if (rng) {\n      if (!gecko \u0026\u0026 cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n      if (old \u0026\u0026 sel.anchorNode == null) { sel.addRange(old); }\n      else if (gecko) { this.startGracePeriod(); }\n    }\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n      var this$1 = this;\n\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n      if (this$1.selectionChanged())\n        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n    if (!sel.rangeCount) { return false }\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node)\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor())\n        { this.showSelection(this.prepareSelection(), true); }\n      this.div.focus();\n    }\n  };\n  ContentEditableInput.prototype.blur = function () { this.div.blur(); };\n  ContentEditableInput.prototype.getField = function () { return this.div };\n\n  ContentEditableInput.prototype.supportsTouch = function () { return true };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n    var input = this;\n    if (this.selectionInEditor())\n      { this.pollSelection(); }\n    else\n      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n    var sel = this.getSelection(), cm = this.cm;\n    // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n    if (android \u0026\u0026 chrome \u0026\u0026 this.cm.display.gutterSpecs.length \u0026\u0026 isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n      this.blur();\n      this.focus();\n      return\n    }\n    if (this.composing) { return }\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (anchor \u0026\u0026 head) { runInOp(cm, function () {\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n    }); }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n    var from = sel.from(), to = sel.to();\n    if (from.ch == 0 \u0026\u0026 from.line \u003e cm.firstLine())\n      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n    if (to.ch == getLine(cm.doc, to.line).text.length \u0026\u0026 to.line \u003c cm.lastLine())\n      { to = Pos(to.line + 1, 0); }\n    if (from.line \u003c display.viewFrom || to.line \u003e display.viewTo - 1) { return false }\n\n    var fromIndex, fromLine, fromNode;\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) { return false }\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n    while (newText.length \u003e 1 \u0026\u0026 oldText.length \u003e 1) {\n      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n      else { break }\n    }\n\n    var cutFront = 0, cutEnd = 0;\n    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n    while (cutFront \u003c maxCutFront \u0026\u0026 newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n      { ++cutFront; }\n    var newBot = lst(newText), oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                             oldBot.length - (oldText.length == 1 ? cutFront : 0));\n    while (cutEnd \u003c maxCutEnd \u0026\u0026\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n      { ++cutEnd; }\n    // Try to move start of change to start of selection if ambiguous\n    if (newText.length == 1 \u0026\u0026 oldText.length == 1 \u0026\u0026 fromLine == from.line) {\n      while (cutFront \u0026\u0026 cutFront \u003e from.ch \u0026\u0026\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n    if (newText.length \u003e 1 || newText[0] || cmp(chFrom, chTo)) {\n      replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n      return true\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) { return }\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n      var this$1 = this;\n\n    if (this.readDOMTimeout != null) { return }\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n      if (this$1.composing) {\n        if (this$1.composing.done) { this$1.composing = null; }\n        else { return }\n      }\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n      var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent())\n      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) { return }\n    e.preventDefault();\n    if (!this.cm.isReadOnly())\n      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) { return null }\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line, cm.doc.direction), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode)\n      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n    return false\n  }\n\n  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n    function close() {\n      if (closing) {\n        text += lineSep;\n        if (extraLinebreak) { text += lineSep; }\n        closing = extraLinebreak = false;\n      }\n    }\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText) {\n          addText(cmText);\n          return\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range$$1;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length \u0026\u0026 (range$$1 = found[0].find(0)))\n            { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\n          return\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n        if (!/^br$/i.test(node.nodeName) \u0026\u0026 node.textContent.length == 0) { return }\n\n        if (isBlock) { close(); }\n        for (var i = 0; i \u003c node.childNodes.length; i++)\n          { walk(node.childNodes[i]); }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }\n        if (isBlock) { closing = true; }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) { break }\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n    return text\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n        if (lineNode.parentNode \u0026\u0026 lineNode.parentNode == cm.display.lineDiv) { break }\n      }\n    }\n    for (var i = 0; i \u003c cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        { return locateNodeInLineView(lineView, node, offset) }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad)\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode \u0026\u0026 node.childNodes.length == 1 \u0026\u0026 node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) { offset = textNode.nodeValue.length; }\n    }\n    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i \u003c (maps ? maps.length : 0); i++) {\n        var map$$1 = i \u003c 0 ? measure.map : maps[i];\n        for (var j = 0; j \u003c map$$1.length; j += 3) {\n          var curNode = map$$1[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i \u003c 0 ? lineView.line : lineView.rest[i]);\n            var ch = map$$1[j] + offset;\n            if (offset \u003c 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\n            return Pos(line, ch)\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) { return badPos(found, bad) }\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        { return badPos(Pos(found.line, found.ch - dist), bad) }\n      else\n        { dist += after.textContent.length; }\n    }\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n      else\n        { dist$1 += before.textContent.length; }\n    }\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  var TextareaInput = function(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n    if (ios) { te.style.width = \"0px\"; }\n\n    on(te, \"input\", function () {\n      if (ie \u0026\u0026 ie_version \u003e= 9 \u0026\u0026 this$1.hasSelection) { this$1.hasSelection = null; }\n      input.poll();\n    });\n\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n      cm.state.pasteIncoming = +new Date;\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n      if (e.type == \"cut\") { cm.state.cutIncoming = +new Date; }\n    }\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date;\n        input.focus();\n        return\n      }\n\n      // Pass the `paste` event to the textarea so it's handled by its event listener.\n      var event = new Event(\"paste\");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    });\n\n    // Prevent normal selection in the editor (we handle our own)\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) { e_preventDefault(e); }\n    });\n\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n      if (input.composing) { input.composing.range.clear(); }\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea();\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm, display = cm.display, doc = cm.doc;\n    var result = prepareSelection(cm);\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm, display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  };\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing) { return }\n    var cm = this.cm;\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n      if (cm.state.focused) { selectInput(this.textarea); }\n      if (ie \u0026\u0026 ie_version \u003e= 9) { this.hasSelection = content; }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n      if (ie \u0026\u0026 ie_version \u003e= 9) { this.hasSelection = null; }\n    }\n  };\n\n  TextareaInput.prototype.getField = function () { return this.textarea };\n\n  TextareaInput.prototype.supportsTouch = function () { return false };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" \u0026\u0026 (!mobile || activeElt() != this.textarea)) {\n      try { this.textarea.focus(); }\n      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n    }\n  };\n\n  TextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  TextareaInput.prototype.slowPoll = function () {\n      var this$1 = this;\n\n    if (this.pollingFast) { return }\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n      if (this$1.cm.state.focused) { this$1.slowPoll(); }\n    });\n  };\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false, input = this;\n    input.pollingFast = true;\n    function p() {\n      var changed = input.poll();\n      if (!changed \u0026\u0026 !missed) {missed = true; input.polling.set(60, p);}\n      else {input.pollingFast = false; input.slowPoll();}\n    }\n    input.polling.set(20, p);\n  };\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  TextareaInput.prototype.poll = function () {\n      var this$1 = this;\n\n    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (this.contextMenuPending || !cm.state.focused ||\n        (hasSelection(input) \u0026\u0026 !prevInput \u0026\u0026 !this.composing) ||\n        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n      { return false }\n\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput \u0026\u0026 !cm.somethingSelected()) { return false }\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie \u0026\u0026 ie_version \u003e= 9 \u0026\u0026 this.hasSelection === text ||\n        mac \u0026\u0026 /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n      if (first == 0x200b \u0026\u0026 !prevInput) { prevInput = \"\\u200b\"; }\n      if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n    }\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same \u003c l \u0026\u0026 prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same,\n                     null, this$1.composing ? \"*compose\" : null);\n\n      // Don't leave long text in the textarea, since it makes further polling slow\n      if (text.length \u003e 1000 || text.indexOf(\"\\n\") \u003e -1) { input.value = this$1.prevInput = \"\"; }\n      else { this$1.prevInput = text; }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                           {className: \"CodeMirror-composing\"});\n      }\n    });\n    return true\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast \u0026\u0026 this.poll()) { this.pollingFast = false; }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie \u0026\u0026 ie_version \u003e= 9) { this.hasSelection = null; }\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n    if (input.contextMenuPending) { input.contextMenuPending(); }\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) { return } // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset \u0026\u0026 cm.doc.sel.contains(pos) == -1)\n      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n    display.input.focus();\n    if (webkit) { window.scrollTo(null, oldScrollY); }\n    display.input.reset();\n    // Adds \"Select all\" to context menu in FF\n    if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200b\" + (selected ? te.value : \"\");\n        te.value = \"\\u21da\"; // Used to catch context-menu undo\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200b\";\n        te.selectionStart = 1; te.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      if (input.contextMenuPending != rehide) { return }\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n      if (ie \u0026\u0026 ie_version \u003c 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n      // Try to detect the user choosing select-all\n      if (te.selectionStart != null) {\n        if (!ie || (ie \u0026\u0026 ie_version \u003c 9)) { prepareSelectAllHack(); }\n        var i = 0, poll = function () {\n          if (display.selForContextMenu == cm.doc.sel \u0026\u0026 te.selectionStart == 0 \u0026\u0026\n              te.selectionEnd \u003e 0 \u0026\u0026 input.prevInput == \"\\u200b\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ \u003c 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie \u0026\u0026 ie_version \u003e= 9) { prepareSelectAllHack(); }\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function () {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) { this.reset(); }\n    this.textarea.disabled = val == \"nocursor\";\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex \u0026\u0026 textarea.tabIndex)\n      { options.tabindex = textarea.tabIndex; }\n    if (!options.placeholder \u0026\u0026 textarea.placeholder)\n      { options.placeholder = textarea.placeholder; }\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null \u0026\u0026 hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n\n    var realSubmit;\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n      cm.getTextArea = function () { return textarea; };\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (!options.leaveSubmitMethodAlone \u0026\u0026 typeof textarea.form.submit == \"function\")\n            { textarea.form.submit = realSubmit; }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n      options);\n    return cm\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  }\n\n  // EDITOR CONSTRUCTOR\n\n  defineOptions(CodeMirror);\n\n  addEditorMethods(CodeMirror);\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) \u0026\u0026 indexOf(dontDelegate, prop) \u003c 0)\n    { CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments)}\n    })(Doc.prototype[prop]); } }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name/*, mode, …*/) {\n    if (!CodeMirror.defaults.mode \u0026\u0026 name != \"null\") { CodeMirror.defaults.mode = name; }\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME;\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n\n  addLegacyProps(CodeMirror);\n\n  CodeMirror.version = \"5.49.0\";\n\n  return CodeMirror;\n\n})));\n\u003c/script\u003e\r\n    \u003cscript\u003e// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function(mod) {\n  if (typeof exports == \"object\" \u0026\u0026 typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" \u0026\u0026 define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.getWrapperElement();\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\n    else\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    CodeMirror.addClass(wrap, 'dialog-opened');\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        closed = true;\n        CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      inp.focus();\n\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) {\n          inp.select();\n        }\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options \u0026\u0026 options.onKeyDown \u0026\u0026 options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 27 || (options.closeOnEnter !== false \u0026\u0026 e.keyCode == 13)) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n        if (e.keyCode == 13) callback(inp.value, e);\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options \u0026\u0026 options.bottom);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i \u003c buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.on(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.on(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring \u003c= 0) close(); }, 200);\n      });\n      CodeMirror.on(b, \"focus\", function() { ++blurring; });\n    }\n  });\n\n  /*\n   * openNotification\n   * Opens a notification, that can be closed with an optional timer\n   * (default 5000ms timer) and always closes on click.\n   *\n   * If a notification is opened while another is opened, it will close the\n   * currently opened one and open the new one immediately.\n   */\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options \u0026\u0026 options.bottom);\n    var closed = false, doneTimer;\n    var duration = options \u0026\u0026 typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n});\n\u003c/script\u003e\r\n    \u003cscript\u003e// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" \u0026\u0026 typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" \u0026\u0026 define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp), target = current\n    for (var i = 0; i \u003c flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\n      target += flags.charAt(i)\n    return current == target ? regexp : new RegExp(regexp.source, target)\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line \u003c= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line \u003c= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i \u003c chunk; i++) {\n        if (line \u003e last) break\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp) {\n    var cutOff = 0, match\n    for (;;) {\n      regexp.lastIndex = cutOff\n      var newMatch = regexp.exec(string)\n      if (!newMatch) return match\n      match = newMatch\n      cutOff = match.index + (match[0].length || 1)\n      if (cutOff == string.length) return match\n    }\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line \u003e= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      if (ch \u003e -1) string = string.slice(0, ch)\n      var match = lastMatchIn(string, regexp)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, first = doc.firstLine(); line \u003e= first;) {\n      for (var i = 0; i \u003c chunk; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine.slice(0, start.ch) : curLine + \"\\n\" + string\n      }\n      chunk *= 2\n\n      var match = lastMatchIn(string, regexp)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) \u003e\u003e 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len \u003e pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line \u003c= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i \u003c lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line \u003e= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch \u003e -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i \u003c lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureFlags(query, \"gm\")\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))\n\n      // Implements weird auto-growing behavior on null-matches for\n      // backwards-compatiblity with the vim code (unfortunately)\n      while (result \u0026\u0026 CodeMirror.cmpPos(result.from, result.to) == 0) {\n        if (reverse) {\n          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)\n          else if (result.from.line == this.doc.firstLine()) result = null\n          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))\n        } else {\n          if (result.to.ch \u003c this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)\n          else if (result.to.line == this.doc.lastLine()) result = null\n          else result = this.matches(reverse, Pos(result.to.line + 1, 0))\n        }\n      }\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) \u003e 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n\u003c/script\u003e\r\n    \u003cscript\u003e// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Define search commands. Depends on dialog.js or another\n// implementation of the openDialog method.\n\n// Replace works a little oddly -- it will do the replace on the next\n// Ctrl-G (or whatever is bound to findNext) press. You prevent a\n// replace by making sure the match is no longer selected when hitting\n// Ctrl-G.\n\n(function(mod) {\n  if (typeof exports == \"object\" \u0026\u0026 typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./searchcursor\"), require(\"../dialog/dialog\"));\n  else if (typeof define == \"function\" \u0026\u0026 define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../dialog/dialog\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function searchOverlay(query, caseInsensitive) {\n    if (typeof query == \"string\")\n      query = new RegExp(query.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$\u0026\"), caseInsensitive ? \"gi\" : \"g\");\n    else if (!query.global)\n      query = new RegExp(query.source, query.ignoreCase ? \"gi\" : \"g\");\n\n    return {token: function(stream) {\n      query.lastIndex = stream.pos;\n      var match = query.exec(stream.string);\n      if (match \u0026\u0026 match.index == stream.pos) {\n        stream.pos += match[0].length || 1;\n        return \"searching\";\n      } else if (match) {\n        stream.pos = match.index;\n      } else {\n        stream.skipToEnd();\n      }\n    }};\n  }\n\n  function SearchState() {\n    this.posFrom = this.posTo = this.lastQuery = this.query = null;\n    this.overlay = null;\n  }\n\n  function getSearchState(cm) {\n    return cm.state.search || (cm.state.search = new SearchState());\n  }\n\n  function queryCaseInsensitive(query) {\n    return typeof query == \"string\" \u0026\u0026 query == query.toLowerCase();\n  }\n\n  function getSearchCursor(cm, query, pos) {\n    // Heuristic: if the query string is all lowercase, do a case insensitive search.\n    return cm.getSearchCursor(query, pos, {caseFold: queryCaseInsensitive(query), multiline: true});\n  }\n\n  function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {\n    cm.openDialog(text, onEnter, {\n      value: deflt,\n      selectValueOnOpen: true,\n      closeOnEnter: false,\n      onClose: function() { clearSearch(cm); },\n      onKeyDown: onKeyDown\n    });\n  }\n\n  function dialog(cm, text, shortText, deflt, f) {\n    if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});\n    else f(prompt(shortText, deflt));\n  }\n\n  function confirmDialog(cm, text, shortText, fs) {\n    if (cm.openConfirm) cm.openConfirm(text, fs);\n    else if (confirm(shortText)) fs[0]();\n  }\n\n  function parseString(string) {\n    return string.replace(/\\\\([nrt\\\\])/g, function(match, ch) {\n      if (ch == \"n\") return \"\\n\"\n      if (ch == \"r\") return \"\\r\"\n      if (ch == \"t\") return \"\\t\"\n      if (ch == \"\\\\\") return \"\\\\\"\n      return match\n    })\n  }\n\n  function parseQuery(query) {\n    var isRE = query.match(/^\\/(.*)\\/([a-z]*)$/);\n    if (isRE) {\n      try { query = new RegExp(isRE[1], isRE[2].indexOf(\"i\") == -1 ? \"\" : \"i\"); }\n      catch(e) {} // Not a regular expression after all, do a string search\n    } else {\n      query = parseString(query)\n    }\n    if (typeof query == \"string\" ? query == \"\" : query.test(\"\"))\n      query = /x^/;\n    return query;\n  }\n\n  function startSearch(cm, state, query) {\n    state.queryText = query;\n    state.query = parseQuery(query);\n    cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));\n    state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));\n    cm.addOverlay(state.overlay);\n    if (cm.showMatchesOnScrollbar) {\n      if (state.annotate) { state.annotate.clear(); state.annotate = null; }\n      state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));\n    }\n  }\n\n  function doSearch(cm, rev, persistent, immediate) {\n    var state = getSearchState(cm);\n    if (state.query) return findNext(cm, rev);\n    var q = cm.getSelection() || state.lastQuery;\n    if (q instanceof RegExp \u0026\u0026 q.source == \"x^\") q = null\n    if (persistent \u0026\u0026 cm.openDialog) {\n      var hiding = null\n      var searchNext = function(query, event) {\n        CodeMirror.e_stop(event);\n        if (!query) return;\n        if (query != state.queryText) {\n          startSearch(cm, state, query);\n          state.posFrom = state.posTo = cm.getCursor();\n        }\n        if (hiding) hiding.style.opacity = 1\n        findNext(cm, event.shiftKey, function(_, to) {\n          var dialog\n          if (to.line \u003c 3 \u0026\u0026 document.querySelector \u0026\u0026\n              (dialog = cm.display.wrapper.querySelector(\".CodeMirror-dialog\")) \u0026\u0026\n              dialog.getBoundingClientRect().bottom - 4 \u003e cm.cursorCoords(to, \"window\").top)\n            (hiding = dialog).style.opacity = .4\n        })\n      };\n      persistentDialog(cm, getQueryDialog(cm), q, searchNext, function(event, query) {\n        var keyName = CodeMirror.keyName(event)\n        var extra = cm.getOption('extraKeys'), cmd = (extra \u0026\u0026 extra[keyName]) || CodeMirror.keyMap[cm.getOption(\"keyMap\")][keyName]\n        if (cmd == \"findNext\" || cmd == \"findPrev\" ||\n          cmd == \"findPersistentNext\" || cmd == \"findPersistentPrev\") {\n          CodeMirror.e_stop(event);\n          startSearch(cm, getSearchState(cm), query);\n          cm.execCommand(cmd);\n        } else if (cmd == \"find\" || cmd == \"findPersistent\") {\n          CodeMirror.e_stop(event);\n          searchNext(query, event);\n        }\n      });\n      if (immediate \u0026\u0026 q) {\n        startSearch(cm, state, q);\n        findNext(cm, rev);\n      }\n    } else {\n      dialog(cm, getQueryDialog(cm), \"Search for:\", q, function(query) {\n        if (query \u0026\u0026 !state.query) cm.operation(function() {\n          startSearch(cm, state, query);\n          state.posFrom = state.posTo = cm.getCursor();\n          findNext(cm, rev);\n        });\n      });\n    }\n  }\n\n  function findNext(cm, rev, callback) {cm.operation(function() {\n    var state = getSearchState(cm);\n    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);\n    if (!cursor.find(rev)) {\n      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));\n      if (!cursor.find(rev)) return;\n    }\n    cm.setSelection(cursor.from(), cursor.to());\n    cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);\n    state.posFrom = cursor.from(); state.posTo = cursor.to();\n    if (callback) callback(cursor.from(), cursor.to())\n  });}\n\n  function clearSearch(cm) {cm.operation(function() {\n    var state = getSearchState(cm);\n    state.lastQuery = state.query;\n    if (!state.query) return;\n    state.query = state.queryText = null;\n    cm.removeOverlay(state.overlay);\n    if (state.annotate) { state.annotate.clear(); state.annotate = null; }\n  });}\n\n\n  function getQueryDialog(cm)  {\n    return '\u003cspan class=\"CodeMirror-search-label\"\u003e' + cm.phrase(\"Search:\") + '\u003c/span\u003e \u003cinput type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/\u003e \u003cspan style=\"color: #888\" class=\"CodeMirror-search-hint\"\u003e' + cm.phrase(\"(Use /re/ syntax for regexp search)\") + '\u003c/span\u003e';\n  }\n  function getReplaceQueryDialog(cm) {\n    return ' \u003cinput type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/\u003e \u003cspan style=\"color: #888\" class=\"CodeMirror-search-hint\"\u003e' + cm.phrase(\"(Use /re/ syntax for regexp search)\") + '\u003c/span\u003e';\n  }\n  function getReplacementQueryDialog(cm) {\n    return '\u003cspan class=\"CodeMirror-search-label\"\u003e' + cm.phrase(\"With:\") + '\u003c/span\u003e \u003cinput type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/\u003e';\n  }\n  function getDoReplaceConfirm(cm) {\n    return '\u003cspan class=\"CodeMirror-search-label\"\u003e' + cm.phrase(\"Replace?\") + '\u003c/span\u003e \u003cbutton\u003e' + cm.phrase(\"Yes\") + '\u003c/button\u003e \u003cbutton\u003e' + cm.phrase(\"No\") + '\u003c/button\u003e \u003cbutton\u003e' + cm.phrase(\"All\") + '\u003c/button\u003e \u003cbutton\u003e' + cm.phrase(\"Stop\") + '\u003c/button\u003e ';\n  }\n\n  function replaceAll(cm, query, text) {\n    cm.operation(function() {\n      for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {\n        if (typeof query != \"string\") {\n          var match = cm.getRange(cursor.from(), cursor.to()).match(query);\n          cursor.replace(text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\n        } else cursor.replace(text);\n      }\n    });\n  }\n\n  function replace(cm, all) {\n    if (cm.getOption(\"readOnly\")) return;\n    var query = cm.getSelection() || getSearchState(cm).lastQuery;\n    var dialogText = '\u003cspan class=\"CodeMirror-search-label\"\u003e' + (all ? cm.phrase(\"Replace all:\") : cm.phrase(\"Replace:\")) + '\u003c/span\u003e';\n    dialog(cm, dialogText + getReplaceQueryDialog(cm), dialogText, query, function(query) {\n      if (!query) return;\n      query = parseQuery(query);\n      dialog(cm, getReplacementQueryDialog(cm), cm.phrase(\"Replace with:\"), \"\", function(text) {\n        text = parseString(text)\n        if (all) {\n          replaceAll(cm, query, text)\n        } else {\n          clearSearch(cm);\n          var cursor = getSearchCursor(cm, query, cm.getCursor(\"from\"));\n          var advance = function() {\n            var start = cursor.from(), match;\n            if (!(match = cursor.findNext())) {\n              cursor = getSearchCursor(cm, query);\n              if (!(match = cursor.findNext()) ||\n                  (start \u0026\u0026 cursor.from().line == start.line \u0026\u0026 cursor.from().ch == start.ch)) return;\n            }\n            cm.setSelection(cursor.from(), cursor.to());\n            cm.scrollIntoView({from: cursor.from(), to: cursor.to()});\n            confirmDialog(cm, getDoReplaceConfirm(cm), cm.phrase(\"Replace?\"),\n                          [function() {doReplace(match);}, advance,\n                           function() {replaceAll(cm, query, text)}]);\n          };\n          var doReplace = function(match) {\n            cursor.replace(typeof query == \"string\" ? text :\n                           text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\n            advance();\n          };\n          advance();\n        }\n      });\n    });\n  }\n\n  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};\n  CodeMirror.commands.findPersistent = function(cm) {clearSearch(cm); doSearch(cm, false, true);};\n  CodeMirror.commands.findPersistentNext = function(cm) {doSearch(cm, false, true, true);};\n  CodeMirror.commands.findPersistentPrev = function(cm) {doSearch(cm, true, true, true);};\n  CodeMirror.commands.findNext = doSearch;\n  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};\n  CodeMirror.commands.clearSearch = clearSearch;\n  CodeMirror.commands.replace = replace;\n  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};\n});\n\u003c/script\u003e\r\n    \u003cscript\u003e// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" \u0026\u0026 typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" \u0026\u0026 define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function doFold(cm, pos, options, force) {\n    if (options \u0026\u0026 options.call) {\n      var finder = options;\n      options = null;\n    } else {\n      var finder = getOption(cm, options, \"rangeFinder\");\n    }\n    if (typeof pos == \"number\") pos = CodeMirror.Pos(pos, 0);\n    var minSize = getOption(cm, options, \"minFoldSize\");\n\n    function getRange(allowFolded) {\n      var range = finder(cm, pos);\n      if (!range || range.to.line - range.from.line \u003c minSize) return null;\n      var marks = cm.findMarksAt(range.from);\n      for (var i = 0; i \u003c marks.length; ++i) {\n        if (marks[i].__isFold \u0026\u0026 force !== \"fold\") {\n          if (!allowFolded) return null;\n          range.cleared = true;\n          marks[i].clear();\n        }\n      }\n      return range;\n    }\n\n    var range = getRange(true);\n    if (getOption(cm, options, \"scanUp\")) while (!range \u0026\u0026 pos.line \u003e cm.firstLine()) {\n      pos = CodeMirror.Pos(pos.line - 1, 0);\n      range = getRange(false);\n    }\n    if (!range || range.cleared || force === \"unfold\") return;\n\n    var myWidget = makeWidget(cm, options);\n    CodeMirror.on(myWidget, \"mousedown\", function(e) {\n      myRange.clear();\n      CodeMirror.e_preventDefault(e);\n    });\n    var myRange = cm.markText(range.from, range.to, {\n      replacedWith: myWidget,\n      clearOnEnter: getOption(cm, options, \"clearOnEnter\"),\n      __isFold: true\n    });\n    myRange.on(\"clear\", function(from, to) {\n      CodeMirror.signal(cm, \"unfold\", cm, from, to);\n    });\n    CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\n  }\n\n  function makeWidget(cm, options) {\n    var widget = getOption(cm, options, \"widget\");\n    if (typeof widget == \"string\") {\n      var text = document.createTextNode(widget);\n      widget = document.createElement(\"span\");\n      widget.appendChild(text);\n      widget.className = \"CodeMirror-foldmarker\";\n    } else if (widget) {\n      widget = widget.cloneNode(true)\n    }\n    return widget;\n  }\n\n  // Clumsy backwards-compatible interface\n  CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };\n  };\n\n  // New-style interface\n  CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\n    doFold(this, pos, options, force);\n  });\n\n  CodeMirror.defineExtension(\"isFolded\", function(pos) {\n    var marks = this.findMarksAt(pos);\n    for (var i = 0; i \u003c marks.length; ++i)\n      if (marks[i].__isFold) return true;\n  });\n\n  CodeMirror.commands.toggleFold = function(cm) {\n    cm.foldCode(cm.getCursor());\n  };\n  CodeMirror.commands.fold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"fold\");\n  };\n  CodeMirror.commands.unfold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"unfold\");\n  };\n  CodeMirror.commands.foldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i \u003c= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\n    });\n  };\n  CodeMirror.commands.unfoldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i \u003c= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"unfold\");\n    });\n  };\n\n  CodeMirror.registerHelper(\"fold\", \"combine\", function() {\n    var funcs = Array.prototype.slice.call(arguments, 0);\n    return function(cm, start) {\n      for (var i = 0; i \u003c funcs.length; ++i) {\n        var found = funcs[i](cm, start);\n        if (found) return found;\n      }\n    };\n  });\n\n  CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start) {\n    var helpers = cm.getHelpers(start, \"fold\");\n    for (var i = 0; i \u003c helpers.length; i++) {\n      var cur = helpers[i](cm, start);\n      if (cur) return cur;\n    }\n  });\n\n  var defaultOptions = {\n    rangeFinder: CodeMirror.fold.auto,\n    widget: \"\\u2194\",\n    minFoldSize: 0,\n    scanUp: false,\n    clearOnEnter: true\n  };\n\n  CodeMirror.defineOption(\"foldOptions\", null);\n\n  function getOption(cm, options, name) {\n    if (options \u0026\u0026 options[name] !== undefined)\n      return options[name];\n    var editorOptions = cm.options.foldOptions;\n    if (editorOptions \u0026\u0026 editorOptions[name] !== undefined)\n      return editorOptions[name];\n    return defaultOptions[name];\n  }\n\n  CodeMirror.defineExtension(\"foldOption\", function(options, name) {\n    return getOption(this, options, name);\n  });\n});\n\u003c/script\u003e\r\n    \u003cscript\u003e// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" \u0026\u0026 typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./foldcode\"));\n  else if (typeof define == \"function\" \u0026\u0026 define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./foldcode\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n    if (old \u0026\u0026 old != CodeMirror.Init) {\n      cm.clearGutter(cm.state.foldGutter.options.gutter);\n      cm.state.foldGutter = null;\n      cm.off(\"gutterClick\", onGutterClick);\n      cm.off(\"changes\", onChange);\n      cm.off(\"viewportChange\", onViewportChange);\n      cm.off(\"fold\", onFold);\n      cm.off(\"unfold\", onFold);\n      cm.off(\"swapDoc\", onChange);\n    }\n    if (val) {\n      cm.state.foldGutter = new State(parseOptions(val));\n      updateInViewport(cm);\n      cm.on(\"gutterClick\", onGutterClick);\n      cm.on(\"changes\", onChange);\n      cm.on(\"viewportChange\", onViewportChange);\n      cm.on(\"fold\", onFold);\n      cm.on(\"unfold\", onFold);\n      cm.on(\"swapDoc\", onChange);\n    }\n  });\n\n  var Pos = CodeMirror.Pos;\n\n  function State(options) {\n    this.options = options;\n    this.from = this.to = 0;\n  }\n\n  function parseOptions(opts) {\n    if (opts === true) opts = {};\n    if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\n    if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n    if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n    return opts;\n  }\n\n  function isFolded(cm, line) {\n    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\n    for (var i = 0; i \u003c marks.length; ++i) {\n      if (marks[i].__isFold) {\n        var fromPos = marks[i].find(-1);\n        if (fromPos \u0026\u0026 fromPos.line === line)\n          return marks[i];\n      }\n    }\n  }\n\n  function marker(spec) {\n    if (typeof spec == \"string\") {\n      var elt = document.createElement(\"div\");\n      elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n      return elt;\n    } else {\n      return spec.cloneNode(true);\n    }\n  }\n\n  function updateFoldInfo(cm, from, to) {\n    var opts = cm.state.foldGutter.options, cur = from;\n    var minSize = cm.foldOption(opts, \"minFoldSize\");\n    var func = cm.foldOption(opts, \"rangeFinder\");\n    cm.eachLine(from, to, function(line) {\n      var mark = null;\n      if (isFolded(cm, cur)) {\n        mark = marker(opts.indicatorFolded);\n      } else {\n        var pos = Pos(cur, 0);\n        var range = func \u0026\u0026 func(cm, pos);\n        if (range \u0026\u0026 range.to.line - range.from.line \u003e= minSize)\n          mark = marker(opts.indicatorOpen);\n      }\n      cm.setGutterMarker(line, opts.gutter, mark);\n      ++cur;\n    });\n  }\n\n  function updateInViewport(cm) {\n    var vp = cm.getViewport(), state = cm.state.foldGutter;\n    if (!state) return;\n    cm.operation(function() {\n      updateFoldInfo(cm, vp.from, vp.to);\n    });\n    state.from = vp.from; state.to = vp.to;\n  }\n\n  function onGutterClick(cm, line, gutter) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    if (gutter != opts.gutter) return;\n    var folded = isFolded(cm, line);\n    if (folded) folded.clear();\n    else cm.foldCode(Pos(line, 0), opts);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    state.from = state.to = 0;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\n  }\n\n  function onViewportChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() {\n      var vp = cm.getViewport();\n      if (state.from == state.to || vp.from - state.to \u003e 20 || state.from - vp.to \u003e 20) {\n        updateInViewport(cm);\n      } else {\n        cm.operation(function() {\n          if (vp.from \u003c state.from) {\n            updateFoldInfo(cm, vp.from, state.from);\n            state.from = vp.from;\n          }\n          if (vp.to \u003e state.to) {\n            updateFoldInfo(cm, state.to, vp.to);\n            state.to = vp.to;\n          }\n        });\n      }\n    }, opts.updateViewportTimeSpan || 400);\n  }\n\n  function onFold(cm, from) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var line = from.line;\n    if (line \u003e= state.from \u0026\u0026 line \u003c state.to)\n      updateFoldInfo(cm, line, line + 1);\n  }\n});\n\u003c/script\u003e\r\n    \u003cscript\u003e// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" \u0026\u0026 typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" \u0026\u0026 define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"fold\", \"brace\", function(cm, start) {\n  var line = start.line, lineText = cm.getLine(line);\n  var tokenType;\n\n  function findOpening(openCh) {\n    for (var at = start.ch, pass = 0;;) {\n      var found = at \u003c= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\n      if (found == -1) {\n        if (pass == 1) break;\n        pass = 1;\n        at = lineText.length;\n        continue;\n      }\n      if (pass == 1 \u0026\u0026 found \u003c start.ch) break;\n      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n      if (!/^(comment|string)/.test(tokenType)) return found + 1;\n      at = found - 1;\n    }\n  }\n\n  var startToken = \"{\", endToken = \"}\", startCh = findOpening(\"{\");\n  if (startCh == null) {\n    startToken = \"[\", endToken = \"]\";\n    startCh = findOpening(\"[\");\n  }\n\n  if (startCh == null) return;\n  var count = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i \u003c= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen \u003c 0) nextOpen = text.length;\n      if (nextClose \u003c 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {\n        if (pos == nextOpen) ++count;\n        else if (!--count) { end = i; endCh = pos; break outer; }\n      }\n      ++pos;\n    }\n  }\n  if (end == null || line == end) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\nCodeMirror.registerHelper(\"fold\", \"import\", function(cm, start) {\n  function hasImport(line) {\n    if (line \u003c cm.firstLine() || line \u003e cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type != \"keyword\" || start.string != \"import\") return null;\n    // Now find closing semicolon, return its position\n    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i \u003c= e; ++i) {\n      var text = cm.getLine(i), semi = text.indexOf(\";\");\n      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};\n    }\n  }\n\n  var startLine = start.line, has = hasImport(startLine), prev;\n  if (!has || hasImport(startLine - 1) || ((prev = hasImport(startLine - 2)) \u0026\u0026 prev.end.line == startLine - 1))\n    return null;\n  for (var end = has.end;;) {\n    var next = hasImport(end.line + 1);\n    if (next == null) break;\n    end = next.end;\n  }\n  return {from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end};\n});\n\nCodeMirror.registerHelper(\"fold\", \"include\", function(cm, start) {\n  function hasInclude(line) {\n    if (line \u003c cm.firstLine() || line \u003e cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type == \"meta\" \u0026\u0026 start.string.slice(0, 8) == \"#include\") return start.start + 8;\n  }\n\n  var startLine = start.line, has = hasInclude(startLine);\n  if (has == null || hasInclude(startLine - 1) != null) return null;\n  for (var end = startLine;;) {\n    var next = hasInclude(end + 1);\n    if (next == null) break;\n    ++end;\n  }\n  return {from: CodeMirror.Pos(startLine, has + 1),\n          to: cm.clipPos(CodeMirror.Pos(end))};\n});\n\n});\n\u003c/script\u003e\r\n    \u003cscript\u003eCodeMirror.defineMode(\"glsl\", function(config, parserConfig) {\r\n  var indentUnit = config.indentUnit,\r\n      keywords = parserConfig.keywords || {},\r\n      builtins = parserConfig.builtins || {},\r\n      blockKeywords = parserConfig.blockKeywords || {},\r\n      atoms = parserConfig.atoms || {},\r\n      hooks = parserConfig.hooks || {},\r\n      multiLineStrings = parserConfig.multiLineStrings;\r\n  var isOperatorChar = /[+\\-*\u0026%=\u003c\u003e!?|\\/]/;\r\n\r\n  var curPunc;\r\n\r\n  function tokenBase(stream, state) {\r\n    var ch = stream.next();\r\n    if (hooks[ch]) {\r\n      var result = hooks[ch](stream, state);\r\n      if (result !== false) return result;\r\n    }\r\n    if (ch == '\"' || ch == \"'\") {\r\n      state.tokenize = tokenString(ch);\r\n      return state.tokenize(stream, state);\r\n    }\r\n    if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\r\n      curPunc = ch;\r\n      return \"bracket\";\r\n    }\r\n    if (/\\d/.test(ch)) {\r\n      stream.eatWhile(/[\\w\\.]/);\r\n      return \"number\";\r\n    }\r\n    if (ch == \"/\") {\r\n      if (stream.eat(\"*\")) {\r\n        state.tokenize = tokenComment;\r\n        return tokenComment(stream, state);\r\n      }\r\n      if (stream.eat(\"/\")) {\r\n        stream.skipToEnd();\r\n        return \"comment\";\r\n      }\r\n    }\r\n    if (isOperatorChar.test(ch)) {\r\n      stream.eatWhile(isOperatorChar);\r\n      return \"operator\";\r\n    }\r\n    stream.eatWhile(/[\\w\\$_]/);\r\n    var cur = stream.current();\r\n    if (keywords.propertyIsEnumerable(cur)) {\r\n      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\r\n      return \"keyword\";\r\n    }\r\n    if (builtins.propertyIsEnumerable(cur)) {\r\n      return \"builtin\";\r\n    }\r\n    if (atoms.propertyIsEnumerable(cur)) return \"atom\";\r\n    return \"word\";\r\n  }\r\n\r\n  function tokenString(quote) {\r\n    return function(stream, state) {\r\n      var escaped = false, next, end = false;\r\n      while ((next = stream.next()) != null) {\r\n        if (next == quote \u0026\u0026 !escaped) {end = true; break;}\r\n        escaped = !escaped \u0026\u0026 next == \"\\\\\";\r\n      }\r\n      if (end || !(escaped || multiLineStrings))\r\n        state.tokenize = tokenBase;\r\n      return \"string\";\r\n    };\r\n  }\r\n\r\n  function tokenComment(stream, state) {\r\n    var maybeEnd = false, ch;\r\n    while (ch = stream.next()) {\r\n      if (ch == \"/\" \u0026\u0026 maybeEnd) {\r\n        state.tokenize = tokenBase;\r\n        break;\r\n      }\r\n      maybeEnd = (ch == \"*\");\r\n    }\r\n    return \"comment\";\r\n  }\r\n\r\n  function Context(indented, column, type, align, prev) {\r\n    this.indented = indented;\r\n    this.column = column;\r\n    this.type = type;\r\n    this.align = align;\r\n    this.prev = prev;\r\n  }\r\n  function pushContext(state, col, type) {\r\n    return state.context = new Context(state.indented, col, type, null, state.context);\r\n  }\r\n  function popContext(state) {\r\n    var t = state.context.type;\r\n    if (t == \")\" || t == \"]\" || t == \"}\")\r\n      state.indented = state.context.indented;\r\n    return state.context = state.context.prev;\r\n  }\r\n\r\n  // Interface\r\n\r\n  return {\r\n    startState: function(basecolumn) {\r\n      return {\r\n        tokenize: null,\r\n        context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", false),\r\n        indented: 0,\r\n        startOfLine: true\r\n      };\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      var ctx = state.context;\r\n      if (stream.sol()) {\r\n        if (ctx.align == null) ctx.align = false;\r\n        state.indented = stream.indentation();\r\n        state.startOfLine = true;\r\n      }\r\n      if (stream.eatSpace()) return null;\r\n      curPunc = null;\r\n      var style = (state.tokenize || tokenBase)(stream, state);\r\n      if (style == \"comment\" || style == \"meta\") return style;\r\n      if (ctx.align == null) ctx.align = true;\r\n\r\n      if ((curPunc == \";\" || curPunc == \":\") \u0026\u0026 ctx.type == \"statement\") popContext(state);\r\n      else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");\r\n      else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");\r\n      else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");\r\n      else if (curPunc == \"}\") {\r\n        while (ctx.type == \"statement\") ctx = popContext(state);\r\n        if (ctx.type == \"}\") ctx = popContext(state);\r\n        while (ctx.type == \"statement\") ctx = popContext(state);\r\n      }\r\n      else if (curPunc == ctx.type) popContext(state);\r\n      else if (ctx.type == \"}\" || ctx.type == \"top\" || (ctx.type == \"statement\" \u0026\u0026 curPunc == \"newstatement\"))\r\n        pushContext(state, stream.column(), \"statement\");\r\n      state.startOfLine = false;\r\n      return style;\r\n    },\r\n\r\n    indent: function(state, textAfter) {\r\n      if (state.tokenize != tokenBase \u0026\u0026 state.tokenize != null) return 0;\r\n      var firstChar = textAfter \u0026\u0026 textAfter.charAt(0), ctx = state.context, closing = firstChar == ctx.type;\r\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : indentUnit);\r\n      else if (ctx.align) return ctx.column + (closing ? 0 : 1);\r\n      else return ctx.indented + (closing ? 0 : indentUnit);\r\n    },\r\n\r\n    electricChars: \"{}\",\r\n    fold: \"brace\"\r\n  };\r\n});\r\n\r\n(function() {\r\n  function words(str) {\r\n    var obj = {}, words = str.split(\" \");\r\n    for (var i = 0; i \u003c words.length; ++i) obj[words[i]] = true;\r\n    return obj;\r\n  }\r\n  var glslKeywords = \"const uniform break continue \" +\r\n    \"do for while if else switch case in out inout float int uint void bool true false \" +\r\n    \"invariant discard return mat2 mat3 mat2x2 mat2x3 mat2x4 mat3x2 mat3x3 mat3x4 mat4x2 mat4x3 mat4x4 \" +\r\n    \"mat4 vec2 vec3 vec4 ivec2 ivec3 ivec4 uvec2 uvec3 uvec4 bvec2 bvec3 bvec4 sampler2D \" +\r\n    \"samplerCube sampler3D struct\";\r\n  var glslBuiltins = \"radians degrees sin cos tan asin acos atan pow sinh cosh tanh asinh acosh atanh \" +\r\n    \"exp log exp2 log2 sqrt inversesqrt abs sign floor ceil round roundEven trunc fract mod modf \" +\r\n    \"min max clamp mix step smoothstep length distance dot cross \" +\r\n    \"determinant inverse normalize faceforward reflect refract matrixCompMult outerProduct transpose lessThan \" +\r\n    \"lessThanEqual greaterThan greaterThanEqual equal notEqual any all not packUnorm2x16 unpackUnorm2x16 packSnorm2x16 unpackSnorm2x16 packHalf2x16 unpackHalf2x16 \" +\r\n    \"dFdx dFdy fwidth textureSize texture textureProj textureLod textureGrad texelFetch texelFetchOffset \" +\r\n    \"textureProjLod textureLodOffset textureGradOffset textureProjLodOffset textureProjGrad intBitsToFloat uintBitsToFloat floatBitsToInt floatBitsToUint isnan isinf\";\r\n\r\n  function cppHook(stream, state) {\r\n    if (!state.startOfLine) return false;\r\n    stream.skipToEnd();\r\n    return \"meta\";\r\n  }\r\n\r\n  // C#-style strings where \"\" escapes a quote.\r\n  function tokenAtString(stream, state) {\r\n    var next;\r\n    while ((next = stream.next()) != null) {\r\n      if (next == '\"' \u0026\u0026 !stream.eat('\"')) {\r\n        state.tokenize = null;\r\n        break;\r\n      }\r\n    }\r\n    return \"string\";\r\n  }\r\n\r\n  CodeMirror.defineMIME(\"text/x-glsl\", {\r\n    name: \"glsl\",\r\n    keywords: words(glslKeywords),\r\n    builtins: words(glslBuiltins),\r\n    blockKeywords: words(\"case do else for if switch while struct\"),\r\n    atoms: words(\"null\"),\r\n    hooks: {\"#\": cppHook}\r\n  });\r\n}());\r\n\u003c/script\u003e\r\n    \u003cscript\u003e\"use strict\";\n\nclass SoundCloud \n{\n    resolve(url, callback, errcallback) \n    {\n        var url2 = \"surl=\" + url;\n        var mHttpReq = new XMLHttpRequest();\n        mHttpReq.open( \"POST\", \"/shadertoy\", true );\n        mHttpReq.responseType = \"json\";\n        mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n        mHttpReq.onload = function()\n        {\n            var jsn = mHttpReq.response;\n            if( jsn===null ) errcallback(0);\n            if( jsn.result!==0 )\n            {\n                callback(JSON.parse(jsn.soundcloud));\n            } else {\n                errcallback(0);\n            }\n        };\n        mHttpReq.onerror = function()\n        {\n            errcallback(0);\n        };\n        mHttpReq.send( url2 );\n    }\n}\n\nconst SC = new SoundCloud();\n\u003c/script\u003e\r\n    \u003cscript\u003e\"use strict\"\n\nfunction bbc2html( content, allowMultimedia )\n{\n    //content = content.replace(new RegExp('\\r?\\n','g'), '\u003cbr /\u003e');\n\n    content = content.replace( /(\\[url=)javascript:?(.*?)(\\])(.*?)(\\[\\/url\\])/gi, '');\n    content = content.replace( /(\\[url\\])javascript:?(.*?)(\\[\\/url\\])/gi,         '');\n    content = content.replace( /(\\[img\\])javascript:?(.*?)(\\[\\/img\\])/gi,         '');\n\n    content = content.replace( /(\\[url=)(.*?)(\\])(.*?)(\\[\\/url\\])/gi, '\u003ca href=\"$2\" class=\"regular\" target=\"_blank\"\u003e$4\u003c/a\u003e');\n    content = content.replace( /(\\[url\\])(.*?)(\\[\\/url\\])/gi,         '\u003ca href=\"$2\" class=\"regular\" target=\"_blank\"\u003e$2\u003c/a\u003e');\n\n    content = content.replace( /(:\\))/g,                  '\u003cimg src=\"/img/emoticonHappy.png\"\u003e'   );\n    content = content.replace( /(:\\()/g,                  '\u003cimg src=\"/img/emoticonSad.png\"\u003e'     );\n    content = content.replace( /(:D)/g,                   '\u003cimg src=\"/img/emoticonLaugh.png\"\u003e'   );\n    content = content.replace( /(:love:)/gi,               '\u003cimg src=\"/img/emoticonLove.png\"\u003e'    );\n    content = content.replace( /(:octopus:)/gi,            '\u003cimg src=\"/img/emoticonOctopus.png\"\u003e' );\n    content = content.replace( /(:octopusballoon:)/gi,     '\u003cimg src=\"/img/emoticonOctopusBalloon.png\"\u003e' );\n    content = content.replace( /(:alpha:)/gi,              '\u0026#945;'  );\n    content = content.replace( /(:beta:)/gi,               '\u0026#946;'  );\n    content = content.replace( /(:delta:)/gi,              '\u0026#9169;' );\n    content = content.replace( /(:epsilon:)/gi,            '\u0026#949;'  );\n    content = content.replace( /(:nabla:)/gi,              '\u0026#8711;' );\n    content = content.replace( /(:square:)/gi,             '\u0026#178;'  );\n    content = content.replace( /(:sube:)/gi,               '\u0026#179;'  );\n    content = content.replace( /(:limit:)/gi,              '\u0026#8784;' );\n\n    content = content.replace( /(\\[b\\])([.\\s\\S]*?)(\\[\\/b\\])/gi,       '\u003cstrong\u003e$2\u003c/strong\u003e' );\n    content = content.replace( /(\\[i\\])([.\\s\\S]*?)(\\[\\/i\\])/gi,       '\u003cem\u003e$2\u003c/em\u003e'         );\n    content = content.replace( /(\\[u\\])([.\\s\\S]*?)(\\[\\/u\\])/gi,       '\u003cu\u003e$2\u003c/u\u003e'           );\n    content = content.replace( /(\\[ul\\])([.\\s\\S]*?)(\\[\\/ul\\])/gi,     '\u003cul\u003e$2\u003c/ul\u003e'         );\n    content = content.replace( /(\\[li\\])([.\\s\\S]*?)(\\[\\/li\\])/gi,     '\u003cli\u003e$2\u003c/li\u003e'         );\n    content = content.replace( /(\\[code\\])([.\\s\\S]*?)(\\[\\/code\\])/gi, '\u003cpre\u003e$2\u003c/pre\u003e'       );\n\n    if( allowMultimedia )\n    {\n        content = content.replace( /(\\[img\\])(.*?)(\\[\\/img\\])/gi, '\u003ca href=\"$2\"\u003e\u003cimg src=\"$2\" style=\"max-width:100%;\"/\u003e\u003c/a\u003e' );\n        content = content.replace( /(\\[video\\])(?:http|https|)(?::\\/\\/|)(?:www.|)(?:youtu\\.be\\/|youtube\\.com(?:\\/embed\\/|\\/v\\/|\\/watch\\?v=|\\/ytscreeningroom\\?v=|\\/feeds\\/api\\/videos\\/|\\/user\\S*[^\\w\\-\\s]|\\S*[^\\w\\-\\s]))([\\w\\-]{11})(.*?)(\\[\\/video\\])/gi, '\u003ciframe width=\"100%\" height=\"360\" src=\"https://www.youtube.com/embed/$2?hd=1\" frameborder=\"0\" allowfullscreen\u003e\u003c/iframe\u003e' );\n    }\n\n    return content;\n}\u003c/script\u003e\r\n    \u003cscript\u003e\"use strict\"\r\n\r\nconst kMaxCompileTime = 10.0;\r\n\r\nfunction iReportCrash(shaderID)\r\n{\r\n    let req = new XMLHttpRequest();\r\n    req.onload = function ()\r\n    {\r\n        let jsn = req.response;\r\n        if (jsn === null) return;\r\n        if (jsn.result === 0)\r\n        {\r\n            // yep\r\n        }\r\n    };\r\n    req.open(\"POST\", \"/shadertoy\", true);\r\n    req.responseType = \"json\";\r\n    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n    req.send( \"s=\" + shaderID + \"\u0026r=2\" );\r\n}\r\n\u003c/script\u003e\r\n    \u003cscript\u003e\"use strict\"\r\n\r\nfunction bufferID_to_assetID( id )\r\n{\r\n    if( id===0 ) return '4dXGR8';\r\n    if( id===1 ) return 'XsXGR8';\r\n    if( id===2 ) return '4sXGR8';\r\n    if( id===3 ) return 'XdfGR8';\r\n    return 'none';\r\n}\r\nfunction assetID_to_bufferID( id )\r\n{\r\n    if( id==='4dXGR8' ) return 0;\r\n    if( id==='XsXGR8' ) return 1;\r\n    if( id==='4sXGR8' ) return 2;\r\n    if( id==='XdfGR8' ) return 3;\r\n    return -1;\r\n}\r\n\r\nfunction assetID_to_cubemapBuferID( id )\r\n{\r\n    if( id==='4dX3Rr' ) return 0;\r\n    return -1;\r\n}\r\nfunction cubamepBufferID_to_assetID( id )\r\n{\r\n    if( id===0 ) return '4dX3Rr';\r\n    return 'none';\r\n}\r\n\r\nfunction EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )\r\n{\r\n    this.mID = id;\r\n    this.mInputs  = [null, null, null, null ];\r\n    this.mOutputs = [null, null, null, null ];\r\n    this.mSource = null;\r\n\r\n    this.mGainNode = outputGainNode;\r\n    this.mSoundShaderCompiled = false;\r\n\r\n    this.mEffect = effect;\r\n    this.mRenderer = renderer;\r\n    this.mProgramCopy = copyProgram; \r\n    this.mCompilationTime = 0;\r\n\r\n    this.mType = \"none\";\r\n    this.mName = \"none\";\r\n    this.mFrame = 0;\r\n\r\n    this.mShaderTextureLOD = hasShaderTextureLOD;\r\n    this.mIs20 = is20;\r\n    this.mIsLowEnd = isLowEnd;\r\n    this.mTextureCallbackFun = callback;\r\n    this.mTextureCallbackObj = obj;\r\n    this.mForceMuted = forceMuted;\r\n    this.mForcePaused = forcePaused;\r\n}\r\n\r\nEffectPass.prototype.MakeHeader_Image = function()\r\n{\r\n    let header = \"\";\r\n\r\n    header += \"#define HW_PERFORMANCE \" + ((this.mIsLowEnd===true)?\"0\":\"1\") + \"\\n\";\r\n\r\n    header += \"uniform vec3      iResolution;\\n\" +\r\n              \"uniform float     iTime;\\n\" +\r\n              \"uniform float     iChannelTime[4];\\n\" +\r\n              \"uniform vec4      iMouse;\\n\" +\r\n              \"uniform vec4      iDate;\\n\" +\r\n              \"uniform float     iSampleRate;\\n\" +\r\n              \"uniform vec3      iChannelResolution[4];\\n\" +\r\n              \"uniform int       iFrame;\\n\" +\r\n              \"uniform float     iTimeDelta;\\n\" +\r\n              \"uniform float     iFrameRate;\\n\";\r\n\r\n    for( let i=0; i\u003cthis.mInputs.length; i++ )\r\n    {\r\n        let inp = this.mInputs[i];\r\n\r\n        // old API\r\n             if( inp===null )                  header += \"uniform sampler2D iChannel\" + i + \";\\n\";\r\n        else if( inp.mInfo.mType===\"cubemap\" ) header += \"uniform samplerCube iChannel\" + i + \";\\n\";\r\n        else if( inp.mInfo.mType===\"volume\"  ) header += \"uniform sampler3D iChannel\" + i + \";\\n\";\r\n        else                                   header += \"uniform sampler2D iChannel\" + i + \";\\n\";\r\n\r\n        // new API (see shadertoy.com/view/wtdGW8)\r\n        header += \"uniform struct {\\n\";\r\n             if( inp===null )                  header += \"  sampler2D\";\r\n        else if( inp.mInfo.mType===\"cubemap\" ) header += \"  samplerCube\";\r\n        else if( inp.mInfo.mType===\"volume\"  ) header += \"  sampler3D\";\r\n        else                                  header += \"  sampler2D\";\r\n        header +=        \" sampler;\\n\";\r\n        header += \"  vec3  size;\\n\";\r\n        header += \"  float time;\\n\";\r\n        header += \"  int   loaded;\\n\";\r\n        header += \"}iCh\" + i + \";\\n\";\r\n    }\r\n\theader += \"void mainImage( out vec4 c, in vec2 f );\\n\";\r\n    header += \"void st_assert( bool cond );\\n\";\r\n    header += \"void st_assert( bool cond, int v );\\n\";\r\n\r\n    if( this.mIs20 ) \r\n    {\r\n        header += \"\\nout vec4 shadertoy_out_color;\\n\" +\r\n        \"void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\\n\" +\r\n        \"void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\\n\" +\r\n        \"void main( void )\" +\r\n        \"{\" +\r\n            \"shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);\" + \r\n            \"vec4 color = vec4(1e20);\" +\r\n            \"mainImage( color, gl_FragCoord.xy );\" +\r\n            \"if(shadertoy_out_color.x\u003c0.0) color=vec4(1.0,0.0,0.0,1.0);\" +\r\n            \"if(shadertoy_out_color.y\u003c0.0) color=vec4(0.0,1.0,0.0,1.0);\" +\r\n            \"if(shadertoy_out_color.z\u003c0.0) color=vec4(0.0,0.0,1.0,1.0);\" +\r\n            \"if(shadertoy_out_color.w\u003c0.0) color=vec4(1.0,1.0,0.0,1.0);\" +\r\n            \"shadertoy_out_color = vec4(color.xyz,1.0);\" +\r\n        \"}\";\r\n    }\r\n    else\r\n    {\r\n        header += \"\" +\r\n        \"void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\\n\" +\r\n        \"void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\\n\" +\r\n        \"void main( void )\" +\r\n        \"{\" +\r\n            \"gl_FragColor = vec4(0.0,0.0,0.0,1.0);\" + \r\n            \"vec4 color = vec4(1e20);\" +\r\n            \"mainImage( color, gl_FragCoord.xy );\" +\r\n            \"color.w = 1.0;\" +\r\n            \"if(gl_FragColor.w\u003c0.0) color=vec4(1.0,0.0,0.0,1.0);\" +\r\n            \"if(gl_FragColor.x\u003c0.0) color=vec4(1.0,0.0,0.0,1.0);\" +\r\n            \"if(gl_FragColor.y\u003c0.0) color=vec4(0.0,1.0,0.0,1.0);\" +\r\n            \"if(gl_FragColor.z\u003c0.0) color=vec4(0.0,0.0,1.0,1.0);\" +\r\n            \"if(gl_FragColor.w\u003c0.0) color=vec4(1.0,1.0,0.0,1.0);\" +\r\n            \"gl_FragColor = vec4(color.xyz,1.0);\"+\r\n        \"}\";\r\n    }\r\n    header += \"\\n\";\r\n\r\n    /*\r\n    this.mImagePassFooterVR = \"\\n\" +\r\n    \"uniform vec4 unViewport;\\n\" +\r\n    \"uniform vec3 unCorners[5];\\n\";\r\n    if( this.mIs20 ) \r\n        this.mImagePassFooterVR += \"\\nout vec4 outColor;\\n\";\r\n    this.mImagePassFooterVR += \"void main( void )\" +\r\n    \"{\" +\r\n        \"vec4 color = vec4(1e20);\" +\r\n\r\n        \"vec3 ro = unCorners[4];\" +\r\n        \"vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;\" + \r\n        \"vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x ),\" +\r\n                                  \"mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);\" + \r\n\r\n        \"mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );\" +\r\n        \"color.w = 1.0;\"\r\n    if( this.mIs20 ) \r\n        this.mImagePassFooterVR +=  \"outColor = color;}\";\r\n    else\r\n        this.mImagePassFooterVR +=  \"gl_FragColor = color;}\";\r\n    */\r\n    this.mHeader = header;\r\n    this.mHeaderLength = 0;\r\n}\r\n\r\nEffectPass.prototype.MakeHeader_Buffer = function()\r\n{\r\n    let header = \"\";\r\n    \r\n    header += \"#define HW_PERFORMANCE \" + ((this.mIsLowEnd===true)?\"0\":\"1\") + \"\\n\";\r\n\r\n    header += \"uniform vec3      iResolution;\\n\" +\r\n              \"uniform float     iTime;\\n\" +\r\n              \"uniform float     iChannelTime[4];\\n\" +\r\n              \"uniform vec4      iMouse;\\n\" +\r\n              \"uniform vec4      iDate;\\n\" +\r\n              \"uniform float     iSampleRate;\\n\" +\r\n              \"uniform vec3      iChannelResolution[4];\\n\" +\r\n              \"uniform int       iFrame;\\n\" +\r\n              \"uniform float     iTimeDelta;\\n\" +\r\n              \"uniform float     iFrameRate;\\n\";\r\n\r\n    for (let i = 0; i \u003c this.mInputs.length; i++)\r\n    {\r\n        let inp = this.mInputs[i];\r\n             if( inp===null )                  header += \"uniform sampler2D iChannel\" + i + \";\\n\";\r\n        else if( inp.mInfo.mType===\"cubemap\" ) header += \"uniform samplerCube iChannel\" + i + \";\\n\";\r\n        else if( inp.mInfo.mType===\"volume\"  ) header += \"uniform sampler3D iChannel\" + i + \";\\n\";\r\n        else                                  header += \"uniform sampler2D iChannel\" + i + \";\\n\";\r\n    }\r\n\r\n\theader += \"void mainImage( out vec4 c,  in vec2 f );\\n\"\r\n\r\n    if( this.mIs20 )\r\n        header += \"\\nout vec4 outColor;\\n\";\r\n    header += \"\\nvoid main( void )\\n\" +\r\n    \"{\" +\r\n        \"vec4 color = vec4(1e20);\" +\r\n        \"mainImage( color, gl_FragCoord.xy );\";\r\n    if( this.mIs20 )\r\n        header +=\"outColor = color; }\";\r\n    else\r\n        header +=\"gl_FragColor = color; }\";\r\n    header += \"\\n\";\r\n\r\n    /*\r\n    this.mImagePassFooterVR = \"\\n\" +\r\n    \"uniform vec4 unViewport;\\n\" +\r\n    \"uniform vec3 unCorners[5];\\n\";\r\n    if( this.mIs20 )\r\n    this.mImagePassFooterVR += \"\\nout vec4 outColor;\\n\";\r\n    this.mImagePassFooterVR += \"\\nvoid main( void )\\n\" +\r\n    \"{\" +\r\n        \"vec4 color = vec4(1e20);\" +\r\n\r\n        \"vec3 ro = unCorners[4];\" +\r\n        \"vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;\" + \r\n        \"vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x ),\" +\r\n                                  \"mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);\" + \r\n\r\n        \"mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );\";\r\n    if( this.mIs20 )\r\n        this.mImagePassFooterVR +=\"outColor = color; }\";\r\n    else\r\n        this.mImagePassFooterVR +=\"gl_FragColor = color; }\";\r\n    */\r\n    this.mHeader = header;\r\n    this.mHeaderLength = 0;\r\n}\r\n\r\nEffectPass.prototype.MakeHeader_Cubemap = function()\r\n{\r\n    let header = \"\";\r\n    \r\n    header += \"#define HW_PERFORMANCE \" + ((this.mIsLowEnd===true)?\"0\":\"1\") + \"\\n\";\r\n\r\n    header += \"uniform vec3      iResolution;\\n\" +\r\n              \"uniform float     iTime;\\n\" +\r\n              \"uniform float     iChannelTime[4];\\n\" +\r\n              \"uniform vec4      iMouse;\\n\" +\r\n              \"uniform vec4      iDate;\\n\" +\r\n              \"uniform float     iSampleRate;\\n\" +\r\n              \"uniform vec3      iChannelResolution[4];\\n\" +\r\n              \"uniform int       iFrame;\\n\" +\r\n              \"uniform float     iTimeDelta;\\n\" +\r\n              \"uniform float     iFrameRate;\\n\";\r\n\r\n    for (let i = 0; i \u003c this.mInputs.length; i++)\r\n    {\r\n        let inp = this.mInputs[i];\r\n             if( inp===null )                  header += \"uniform sampler2D iChannel\" + i + \";\\n\";\r\n        else if( inp.mInfo.mType===\"cubemap\" ) header += \"uniform samplerCube iChannel\" + i + \";\\n\";\r\n        else if( inp.mInfo.mType===\"volume\"  ) header += \"uniform sampler3D iChannel\" + i + \";\\n\";\r\n        else                                   header += \"uniform sampler2D iChannel\" + i + \";\\n\";\r\n    }\r\n\r\n\theader += \"void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\\n\"\r\n\r\n    header += \"\\n\" +\r\n    \"uniform vec4 unViewport;\\n\" +\r\n    \"uniform vec3 unCorners[5];\\n\";\r\n    if( this.mIs20 )\r\n        header += \"\\nout vec4 outColor;\\n\";\r\n    header += \"\\nvoid main( void )\\n\" +\r\n    \"{\" +\r\n        \"vec4 color = vec4(1e20);\" +\r\n\r\n        \"vec3 ro = unCorners[4];\" +\r\n        \"vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;\" + \r\n        \"vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x ),\" +\r\n                                  \"mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);\" + \r\n\r\n        \"mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );\";\r\n    if( this.mIs20 )\r\n        header +=\"outColor = color; }\";\r\n    else\r\n        header +=\"gl_FragColor = color; }\";\r\n    header += \"\\n\";\r\n\r\n    this.mHeader = header;\r\n    this.mHeaderLength = 0;\r\n}\r\n\r\nEffectPass.prototype.MakeHeader_Sound = function()\r\n{\r\n    let header = \"\";\r\n\r\n    header += \"#define HW_PERFORMANCE \" + ((this.mIsLowEnd===true)?\"0\":\"1\") + \"\\n\";\r\n\r\n    header += \"uniform float     iChannelTime[4];\\n\" +\r\n              \"uniform float     iTimeOffset;\\n\" +\r\n              \"uniform int       iSampleOffset;\\n\" +\r\n              \"uniform vec4      iDate;\\n\" +\r\n              \"uniform float     iSampleRate;\\n\" +\r\n              \"uniform vec3      iChannelResolution[4];\\n\";\r\n\r\n    for (let i=0; i\u003cthis.mInputs.length; i++ )\r\n    {\r\n        let inp = this.mInputs[i];\r\n\r\n        if( inp!==null \u0026\u0026 inp.mInfo.mType===\"cubemap\" )\r\n            header += \"uniform samplerCube iChannel\" + i + \";\\n\";\r\n        else\r\n            header += \"uniform sampler2D iChannel\" + i + \";\\n\";\r\n    }\r\n    header += \"\\n\";\r\n    header += \"vec2 mainSound( in int samp, float time );\\n\";\r\n\r\n    if( this.mIs20 )\r\n    {\r\n        header += \"out vec4 outColor; void main()\" +\r\n            \"{\" +\r\n            \"float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;\" +\r\n            \"int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);\" +\r\n            \"vec2 y = mainSound( s, t );\" +\r\n            \"vec2 v  = floor((0.5+0.5*y)*65536.0);\" +\r\n            \"vec2 vl =   mod(v,256.0)/255.0;\" +\r\n            \"vec2 vh = floor(v/256.0)/255.0;\" +\r\n            \"outColor = vec4(vl.x,vh.x,vl.y,vh.y);\" +\r\n            \"}\";\r\n    }\r\n    else\r\n    {\r\n        header += \"void main()\" +\r\n            \"{\" +\r\n            \"float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;\" +\r\n            \"vec2 y = mainSound( 0, t );\" +\r\n            \"vec2 v  = floor((0.5+0.5*y)*65536.0);\" +\r\n            \"vec2 vl =   mod(v,256.0)/255.0;\" +\r\n            \"vec2 vh = floor(v/256.0)/255.0;\" +\r\n            \"gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);\" +\r\n            \"}\";\r\n    }\r\n    header += \"\\n\";\r\n    this.mHeader = header;\r\n    this.mHeaderLength = 0;\r\n}\r\n\r\n\r\nEffectPass.prototype.MakeHeader_Common = function ()\r\n{\r\n    let header = \"\";\r\n    let headerlength = 0;\r\n\r\n    header += \"uniform vec4      iDate;\\n\" +\r\n              \"uniform float     iSampleRate;\\n\";\r\n    headerlength += 2;\r\n\r\n    if (this.mIs20)\r\n    {\r\n        header += \"out vec4 outColor;\\n\";\r\n        headerlength += 1;\r\n    }\r\n    header += \"void main( void )\\n\";\r\n    headerlength += 1;\r\n\r\n    if (this.mIs20)\r\n        header += \"{ outColor = vec4(0.0); }\";\r\n    else\r\n        header += \"{ gl_FragColor = vec4(0.0); }\";\r\n    headerlength += 1;\r\n    header += \"\\n\";\r\n    headerlength += 1;\r\n\r\n    this.mHeader = header;\r\n    this.mHeaderLength = headerlength;\r\n}\r\n\r\nEffectPass.prototype.MakeHeader = function()\r\n{\r\n         if( this.mType===\"image\" ) this.MakeHeader_Image();\r\n    else if( this.mType===\"sound\" ) this.MakeHeader_Sound();\r\n    else if( this.mType===\"buffer\") this.MakeHeader_Buffer();\r\n    else if( this.mType===\"common\") this.MakeHeader_Common();\r\n    else if( this.mType===\"cubemap\") this.MakeHeader_Cubemap();\r\n    else console.log(\"ERROR 4\");\r\n}\r\n\r\nEffectPass.prototype.Create_Image = function( wa )\r\n{\r\n    this.MakeHeader();\r\n    this.mSampleRate = 44100;\r\n    this.mSupportsVR = false;\r\n    this.mProgram = null;\r\n    this.mError = false;\r\n    this.mErrorStr = \"\";\r\n    this.mTranslatedSource = null;\r\n    //this.mProgramVR = null;\r\n}\r\nEffectPass.prototype.Destroy_Image = function( wa )\r\n{\r\n}\r\n\r\nEffectPass.prototype.Create_Buffer = function( wa )\r\n{\r\n    this.MakeHeader();\r\n    this.mSampleRate = 44100;\r\n    this.mSupportsVR = false;\r\n    this.mProgram = null;\r\n    this.mError = false;\r\n    this.mErrorStr = \"\";\r\n    this.mTranslatedSource = null;\r\n    //this.mProgramVR = null;\r\n}\r\n\r\nEffectPass.prototype.Destroy_Buffer = function( wa )\r\n{\r\n}\r\n\r\nEffectPass.prototype.Create_Cubemap = function( wa )\r\n{\r\n    this.MakeHeader();\r\n    this.mSampleRate = 44100;\r\n    this.mProgram = null;\r\n    this.mError = false;\r\n    this.mErrorStr = \"\";\r\n    this.mTranslatedSource = null;\r\n}\r\n\r\nEffectPass.prototype.Destroy_Cubemap = function( wa )\r\n{\r\n}\r\n\r\nEffectPass.prototype.Create_Common = function( wa )\r\n{\r\n    this.mProgram = null;\r\n    this.mError = false;\r\n    this.mErrorStr = \"\";\r\n    this.MakeHeader();\r\n}\r\nEffectPass.prototype.Destroy_Common = function( wa )\r\n{\r\n}\r\n\r\nEffectPass.prototype.Create_Sound = function (wa)\r\n{\r\n    this.MakeHeader();\r\n\r\n    this.mProgram = null;\r\n    this.mError = false;\r\n    this.mErrorStr = \"\";\r\n    this.mTranslatedSource = null;\r\n    this.mSampleRate = 44100;\r\n    this.mPlayTime = 60*3;\r\n    this.mPlaySamples = this.mPlayTime*this.mSampleRate;\r\n    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );\r\n\r\n    //-------------------\r\n    this.mTextureDimensions = 512;\r\n    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, \r\n                                                       this.mTextureDimensions, this.mTextureDimensions,\r\n                                                       this.mRenderer.TEXFMT.C4I8,\r\n                                                       this.mRenderer.FILTER.NONE,\r\n                                                       this.mRenderer.TEXWRP.CLAMP, null);\r\n    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);\r\n\r\n    //-----------------------------\r\n\r\n    // ArrayBufferView pixels;\r\n    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;\r\n    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );\r\n\r\n    this.mPlaying = false;\r\n}\r\n\r\nEffectPass.prototype.Destroy_Sound = function( wa )\r\n{\r\n    if( this.mPlayNode!==null ) this.mPlayNode.stop();\r\n    this.mPlayNode = null;\r\n    this.mBuffer = null;\r\n    this.mData = null;\r\n\r\n    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);\r\n    this.mRenderer.DestroyTexture(this.mRenderTexture);\r\n}\r\n\r\nEffectPass.prototype.Create = function( passType, wa )\r\n{\r\n    this.mType = passType;\r\n    this.mSource = null;\r\n\r\n         if( passType===\"image\" ) this.Create_Image( wa );\r\n    else if( passType===\"sound\" ) this.Create_Sound( wa );\r\n    else if( passType===\"buffer\") this.Create_Buffer( wa );\r\n    else if( passType===\"common\") this.Create_Common( wa );\r\n    else if( passType===\"cubemap\") this.Create_Cubemap( wa );\r\n    else alert(\"ERROR 1\");\r\n}\r\n\r\nEffectPass.prototype.SetName = function (passName)\r\n{\r\n    this.mName = passName;\r\n}\r\n\r\nEffectPass.prototype.SetCode = function (src)\r\n{\r\n    this.mSource = src;\r\n}\r\n\r\nEffectPass.prototype.Destroy = function( wa )\r\n{\r\n    this.mSource = null;\r\n         if( this.mType===\"image\" ) this.Destroy_Image( wa );\r\n    else if( this.mType===\"sound\" ) this.Destroy_Sound( wa );\r\n    else if( this.mType===\"buffer\") this.Destroy_Buffer( wa );\r\n    else if( this.mType===\"common\") this.Destroy_Common( wa );\r\n    else if( this.mType===\"cubemap\") this.Destroy_Cubemap( wa );\r\n    else alert(\"ERROR 2\");\r\n}\r\n\r\nEffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)\r\n{\r\n    let vsSource = null;\r\n\r\n    if( this.mIs20 )\r\n        vsSource = \"layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n    else\r\n        vsSource = \"attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n\r\n    let fsSource = this.mHeader;\r\n    for( let i=0; i\u003ccommonShaderCodes.length; i++ )\r\n    {\r\n        fsSource += commonShaderCodes[i]+'\\n';\r\n    }\r\n    this.mHeaderLength = fsSource.split(/\\r\\n|\\r|\\n/).length;\r\n    fsSource += shaderCode;\r\n\r\n    this.mSoundShaderCompiled = false;\r\n\r\n    return [vsSource, fsSource];\r\n}\r\n\r\nEffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )\r\n{\r\n    this.mSupportsVR = false;\r\n\r\n    let vsSource = null;\r\n    if( this.mIs20 )\r\n        vsSource = \"layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n    else\r\n        vsSource = \"attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n\r\n    let fsSource = this.mHeader;\r\n    for (let i = 0; i \u003c commonShaderCodes.length; i++)\r\n    {\r\n        fsSource += commonShaderCodes[i]+'\\n';\r\n    }\r\n    this.mHeaderLength = fsSource.split(/\\r\\n|\\r|\\n/).length;\r\n    fsSource += shaderCode;\r\n\r\n    return [vsSource, fsSource];\r\n\r\n\r\n    /*\r\n    let n1 = shaderCode.indexOf(\"mainVR(\");\r\n    let n2 = shaderCode.indexOf(\"mainVR (\");\r\n    let n3 = shaderCode.indexOf(\"mainVR  (\");\r\n    if( n1\u003e0 || n2\u003e0 || n3\u003e0 )\r\n    {\r\n        let vsSourceVR;\r\n        if( this.mIs20 )\r\n            vsSourceVR = \"layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n        else\r\n            vsSourceVR = \"attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n\r\n        let fsSourceVR = this.mHeader;\r\n        for (let i = 0; i \u003c commonShaderCodes.length; i++) {\r\n            fsSourceVR += commonShaderCodes[i];\r\n        }\r\n        fsSourceVR += shaderCode;\r\n        fsSourceVR += this.mImagePassFooterVR;\r\n\r\n        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);\r\n        if( res.mResult == false )\r\n        {\r\n            return res.mInfo;\r\n        }\r\n        if( this.mProgramVR != null )\r\n            this.mRenderer.DestroyShader( this.mProgramVR );\r\n\r\n        this.mSupportsVR = true;\r\n        this.mProgramVR = res;\r\n    }\r\n    */\r\n}\r\n\r\nEffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )\r\n{\r\n    let vsSource = null;\r\n    if( this.mIs20 )\r\n        vsSource = \"layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n    else\r\n        vsSource = \"attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n\r\n    let fsSource = this.mHeader;\r\n    for (let i = 0; i \u003c commonShaderCodes.length; i++)\r\n    {\r\n        fsSource += commonShaderCodes[i]+'\\n';\r\n    }\r\n\r\n    this.mHeaderLength = fsSource.split(/\\r\\n|\\r|\\n/).length;\r\n\r\n    fsSource += shaderCode;\r\n\r\n    return [vsSource, fsSource];\r\n}\r\n\r\nEffectPass.prototype.NewShader_Common = function (shaderCode )\r\n{\r\n    let vsSource = null;\r\n    if (this.mIs20)\r\n        vsSource = \"layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n    else\r\n        vsSource = \"attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n\r\n    let fsSource = this.mHeader + shaderCode;\r\n\r\n    return [vsSource, fsSource];\r\n}\r\n\r\nEffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)\r\n{\r\n    if( this.mRenderer===null ) return;\r\n\r\n    let vs_fs = null;\r\n\r\n         if( this.mType===\"sound\"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );\r\n    else if( this.mType===\"image\"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );\r\n    else if( this.mType===\"buffer\" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );\r\n    else if( this.mType===\"common\" ) vs_fs = this.NewShader_Common(  this.mSource,                   );\r\n    else if( this.mType===\"cubemap\") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );\r\n    else { console.log(\"ERROR 3: \\\"\" + this.mType + \"\\\"\"); return; }\r\n\r\n    let me = this;\r\n    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,\r\n        function (worked, info)\r\n        {\r\n            if (worked === true)\r\n            {\r\n                if (me.mType === \"sound\")\r\n                {\r\n                    me.mSoundShaderCompiled = true;\r\n                }\r\n\r\n                me.mCompilationTime = info.mTime;\r\n                me.mError = false;\r\n                me.mErrorStr = \"No Errors\";\r\n                if (me.mProgram !== null)\r\n                    me.mRenderer.DestroyShader(me.mProgram);\r\n                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);\r\n                me.mProgram = info;\r\n            }\r\n            else\r\n            {\r\n                me.mError = true;\r\n                me.mErrorStr = info.mErrorStr;\r\n            }\r\n            onResolve();\r\n        });\r\n}\r\n\r\nEffectPass.prototype.DestroyInput = function( id )\r\n{\r\n    if( this.mInputs[id]===null ) return;\r\n\r\n    if( this.mInputs[id].mInfo.mType===\"texture\" )\r\n    {\r\n        if( this.mInputs[id].globject !== null )\r\n            this.mRenderer.DestroyTexture(this.mInputs[id].globject);\r\n    }\r\n    if( this.mInputs[id].mInfo.mType===\"volume\" )\r\n    {\r\n        if( this.mInputs[id].globject !== null )\r\n            this.mRenderer.DestroyTexture(this.mInputs[id].globject);\r\n    }\r\n    else if( this.mInputs[id].mInfo.mType===\"webcam\" )\r\n    {\r\n        this.mInputs[id].video.pause();\r\n        this.mInputs[id].video.src = \"\";\r\n\r\n        if( this.mInputs[id].video.srcObject!==null )\r\n        {\r\n        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();\r\n        if( tracks ) tracks[0].stop();\r\n        }\r\n        this.mInputs[id].video = null;\r\n        if( this.mInputs[id].globject !== null )\r\n            this.mRenderer.DestroyTexture(this.mInputs[id].globject);\r\n    }\r\n    else if( this.mInputs[id].mInfo.mType===\"video\" )\r\n    {\r\n        this.mInputs[id].video.pause();\r\n        this.mInputs[id].video = null;\r\n        if( this.mInputs[id].globject !== null )\r\n            this.mRenderer.DestroyTexture(this.mInputs[id].globject);\r\n    }\r\n    else if( this.mInputs[id].mInfo.mType===\"music\" || this.mInputs[id].mInfo.mType===\"musicstream\")\r\n    {\r\n        this.mInputs[id].audio.pause();\r\n        this.mInputs[id].audio.mSound.mFreqData = null;\r\n        this.mInputs[id].audio.mSound.mWaveData = null;\r\n        this.mInputs[id].audio = null;\r\n        if( this.mInputs[id].globject !== null )\r\n            this.mRenderer.DestroyTexture(this.mInputs[id].globject);\r\n    }\r\n    else if( this.mInputs[id].mInfo.mType===\"cubemap\" )\r\n    {\r\n        if( this.mInputs[id].globject !== null )\r\n            this.mRenderer.DestroyTexture(this.mInputs[id].globject);\r\n    }\r\n    else if( this.mInputs[id].mInfo.mType===\"keyboard\" )\r\n    {\r\n        //if( this.mInputs[id].globject != null )\r\n          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);\r\n    }\r\n    else if( this.mInputs[id].mInfo.mType===\"mic\" )\r\n    {\r\n        this.mInputs[id].mic = null;\r\n        if( this.mInputs[id].globject !== null )\r\n            this.mRenderer.DestroyTexture(this.mInputs[id].globject);\r\n    }\r\n\r\n    this.mInputs[id] = null;\r\n}\r\n\r\nEffectPass.prototype.TooglePauseInput = function( wa, id )\r\n{\r\n    var me = this;\r\n    let inp = this.mInputs[id];\r\n\r\n    if( inp===null )\r\n    {\r\n    }\r\n    else if( inp.mInfo.mType===\"texture\" )\r\n    {\r\n    }\r\n    else if( inp.mInfo.mType===\"volume\" )\r\n    {\r\n    }\r\n    else if( inp.mInfo.mType===\"video\" )\r\n    {\r\n        if( inp.video.mPaused )\r\n        {\r\n            inp.video.play();\r\n            inp.video.mPaused = false;\r\n        }\r\n        else\r\n        {\r\n            inp.video.pause();\r\n            inp.video.mPaused = true;\r\n        }\r\n        return inp.video.mPaused;\r\n    }\r\n    else if( inp.mInfo.mType===\"music\" || inp.mInfo.mType===\"musicstream\")\r\n    {\r\n        wa.resume()\r\n        if( inp.audio.mPaused )\r\n        {\r\n            if( inp.loaded )\r\n            {\r\n                inp.audio.play();\r\n            }\r\n            inp.audio.mPaused = false;\r\n        }\r\n        else\r\n        {\r\n            inp.audio.pause();\r\n            inp.audio.mPaused = true;\r\n        }\r\n        return inp.audio.mPaused;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nEffectPass.prototype.StopInput = function( id )\r\n{\r\n    let inp = this.mInputs[id];\r\n\r\n    if( inp===null )\r\n    {\r\n    }\r\n    else if( inp.mInfo.mType===\"texture\" )\r\n    {\r\n    }\r\n    else if( inp.mInfo.mType===\"volume\" )\r\n    {\r\n    }\r\n    else if( inp.mInfo.mType===\"video\" )\r\n    {\r\n        if( inp.video.mPaused === false )\r\n        {\r\n            inp.video.pause();\r\n            inp.video.mPaused = true;\r\n        }\r\n        return inp.video.mPaused;\r\n    }\r\n    else if( inp.mInfo.mType===\"music\" || inp.mInfo.mType===\"musicstream\" )\r\n    {\r\n        if( inp.audio.mPaused === false )\r\n        {\r\n            inp.audio.pause();\r\n            inp.audio.mPaused = true;\r\n        }\r\n        return inp.audio.mPaused;\r\n    }\r\n    return null;\r\n}\r\n\r\nEffectPass.prototype.ResumeInput = function( id )\r\n{\r\n    let inp = this.mInputs[id];\r\n\r\n    if( inp===null )\r\n    {\r\n    }\r\n    else if( inp.mInfo.mType===\"texture\" )\r\n    {\r\n    }\r\n    else if( inp.mInfo.mType===\"volume\" )\r\n    {\r\n    }\r\n    else if( inp.mInfo.mType===\"video\" )\r\n    {\r\n        if( inp.video.mPaused )\r\n        {\r\n            inp.video.play();\r\n            inp.video.mPaused = false;\r\n        }\r\n        return inp.video.mPaused;\r\n    }\r\n    else if( inp.mInfo.mType===\"music\" || inp.mInfo.mType===\"musicstream\" )\r\n    {\r\n        if( inp.audio.mPaused )\r\n        {\r\n            inp.audio.play();\r\n            inp.audio.mPaused = false;\r\n        }\r\n        return inp.audio.mPaused;\r\n    }\r\n    return null;\r\n}\r\n\r\nEffectPass.prototype.RewindInput = function( wa, id )\r\n{\r\n    var me = this;\r\n    let inp = this.mInputs[id];\r\n\r\n    if( inp==null )\r\n    {\r\n    }\r\n    else if( inp.mInfo.mType===\"texture\" )\r\n    {\r\n    }\r\n    else if( inp.mInfo.mType===\"volume\" )\r\n    {\r\n    }\r\n    else if( inp.mInfo.mType===\"video\" )\r\n    {\r\n        if( inp.loaded )\r\n        {\r\n            inp.video.currentTime = 0;\r\n        }\r\n    }\r\n    else if( inp.mInfo.mType===\"music\" || inp.mInfo.mType===\"musicstream\")\r\n    {\r\n        wa.resume()\r\n        if( inp.loaded )\r\n        {\r\n            inp.audio.currentTime = 0;\r\n        }\r\n    }\r\n}\r\n\r\nEffectPass.prototype.MuteInput = function( wa, id )\r\n{\r\n    let inp = this.mInputs[id];\r\n    if( inp===null ) return;\r\n\r\n    if( inp.mInfo.mType===\"video\" )\r\n    {\r\n        inp.video.muted = true;\r\n        inp.video.mMuted = true;\r\n    }\r\n    else if( inp.mInfo.mType===\"music\" || inp.mInfo.mType===\"musicstream\")\r\n    {\r\n        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;\r\n        inp.audio.mMuted = true;\r\n    }\r\n}\r\n\r\nEffectPass.prototype.UnMuteInput = function( wa, id )\r\n{\r\n    let inp = this.mInputs[id];\r\n    if( inp===null ) return;\r\n\r\n    if( inp.mInfo.mType===\"video\" )\r\n    {\r\n        inp.video.muted = false;\r\n        inp.video.mMuted = false;\r\n    }\r\n    else if( inp.mInfo.mType===\"music\" || inp.mInfo.mType===\"musicstream\")\r\n    {\r\n        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;\r\n        inp.audio.mMuted = false;\r\n    }\r\n}\r\n\r\nEffectPass.prototype.ToggleMuteInput = function( wa, id )\r\n{\r\n    var me = this;\r\n    let inp = this.mInputs[id];\r\n    if( inp===null ) return null;\r\n\r\n    if( inp.mInfo.mType===\"video\" )\r\n    {\r\n        if( inp.video.mMuted ) this.UnMuteInput(wa,id);\r\n        else                   this.MuteInput(wa,id);\r\n        return inp.video.mMuted;\r\n    }\r\n    else if( inp.mInfo.mType===\"music\" || inp.mInfo.mType===\"musicstream\")\r\n    {\r\n        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);\r\n        else                   this.MuteInput(wa,id);\r\n        return inp.audio.mMuted;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nEffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )\r\n{\r\n   for (let i=0; i\u003cthis.mInputs.length; i++ )\r\n   {\r\n        let inp = this.mInputs[i];\r\n\r\n        if( inp===null )\r\n        {\r\n            if( forceUpdate )\r\n            {\r\n              if( this.mTextureCallbackFun!==null )\r\n                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"texture\" )\r\n        {\r\n            if( inp.loaded \u0026\u0026 forceUpdate )\r\n            {\r\n              if( this.mTextureCallbackFun!==null )\r\n                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"volume\" )\r\n        {\r\n            if( inp.loaded \u0026\u0026 forceUpdate )\r\n            {\r\n              if( this.mTextureCallbackFun!==null )\r\n                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"cubemap\" )\r\n        {\r\n            if( inp.loaded \u0026\u0026 forceUpdate )\r\n            {\r\n                if( this.mTextureCallbackFun!==null )\r\n                {\r\n                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;\r\n                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );\r\n                }\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"keyboard\" )\r\n        {\r\n            if( this.mTextureCallbackFun!==null )\r\n                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );\r\n        }\r\n        else if( inp.mInfo.mType===\"video\" )\r\n        {\r\n            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )\r\n            {\r\n                if( this.mTextureCallbackFun!==null )\r\n                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"music\" || inp.mInfo.mType===\"musicstream\" )\r\n        {\r\n              if( inp.loaded \u0026\u0026 inp.audio.mPaused === false \u0026\u0026 inp.audio.mForceMuted === false )\r\n              {\r\n                  if( wa !== null )\r\n                  {\r\n                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );\r\n                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );\r\n                  }\r\n\r\n                  if (this.mTextureCallbackFun!==null)\r\n                  {\r\n                           if (inp.mInfo.mType === \"music\")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);\r\n                      else if (inp.mInfo.mType === \"musicstream\") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);\r\n                  }\r\n              }\r\n              else if( inp.loaded===false )\r\n              {\r\n                  if (this.mTextureCallbackFun!==null)\r\n                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);\r\n              }\r\n        }\r\n        else if( inp.mInfo.mType===\"mic\" )\r\n        {\r\n              if( inp.loaded \u0026\u0026 inp.mForceMuted === false )\r\n              {\r\n                  if( wa !== null )\r\n                  {\r\n                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );\r\n                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );\r\n                  }\r\n                  if( this.mTextureCallbackFun!==null )\r\n                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );\r\n              }\r\n        }\r\n        else if( inp.mInfo.mType===\"buffer\" )\r\n        {\r\n            if( inp.loaded \u0026\u0026 forceUpdate )\r\n            {\r\n              if( this.mTextureCallbackFun!==null )\r\n                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nEffectPass.prototype.Sampler2Renderer = function (sampler)\r\n{\r\n    let filter = this.mRenderer.FILTER.NONE;\r\n    if (sampler.filter === \"linear\") filter = this.mRenderer.FILTER.LINEAR;\r\n    if (sampler.filter === \"mipmap\") filter = this.mRenderer.FILTER.MIPMAP;\r\n    let wrap = this.mRenderer.TEXWRP.REPEAT;\r\n    if (sampler.wrap === \"clamp\") wrap = this.mRenderer.TEXWRP.CLAMP;\r\n    let vflip = false;\r\n    if (sampler.vflip === \"true\") vflip = true;\r\n\r\n    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };\r\n}\r\n\r\nEffectPass.prototype.GetSamplerVFlip = function (id)\r\n{\r\n    let inp = this.mInputs[id];\r\n    return inp.mInfo.mSampler.vflip;\r\n}\r\n\r\nEffectPass.prototype.GetTranslatedShaderSource = function ()\r\n{\r\n    return this.mTranslatedSource;\r\n}\r\n\r\nEffectPass.prototype.SetSamplerVFlip = function (id, str) \r\n{\r\n    var me = this;\r\n    var renderer = this.mRenderer;\r\n    let inp = this.mInputs[id];\r\n\r\n    let filter = false;\r\n    if (str === \"true\") filter = true;\r\n\r\n    if (inp === null)\r\n    {\r\n    }\r\n    else if (inp.mInfo.mType === \"texture\")\r\n    {\r\n        if (inp.loaded)\r\n        {\r\n            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);\r\n            inp.mInfo.mSampler.vflip = str;\r\n        }\r\n    }\r\n    else if (inp.mInfo.mType === \"volume\")\r\n    {\r\n    }\r\n    else if (inp.mInfo.mType === \"video\")\r\n    {\r\n        if (inp.loaded) \r\n        {\r\n            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);\r\n            inp.mInfo.mSampler.vflip = str;\r\n        }\r\n    }\r\n    else if (inp.mInfo.mType === \"cubemap\")\r\n    {\r\n        if (inp.loaded) \r\n        {\r\n            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);\r\n            inp.mInfo.mSampler.vflip = str;\r\n        }\r\n    }\r\n    else if (inp.mInfo.mType === \"webcam\")\r\n    {\r\n        if (inp.loaded) \r\n        {\r\n            renderer.SetSamplerVFlip(inp.globject, filter, null);\r\n            inp.mInfo.mSampler.vflip = str;\r\n        }\r\n    }\r\n}\r\n\r\nEffectPass.prototype.GetAcceptsVFlip = function (id)\r\n{\r\n    let inp = this.mInputs[id];\r\n\r\n    if (inp === null) return false;\r\n    if (inp.mInfo.mType === \"texture\") return true;\r\n    if (inp.mInfo.mType === \"volume\") return false;\r\n    if (inp.mInfo.mType === \"video\")  return true;\r\n    if (inp.mInfo.mType === \"cubemap\") return true;\r\n    if (inp.mInfo.mType === \"webcam\")  return true;\r\n    if (inp.mInfo.mType === \"music\")  return false;\r\n    if (inp.mInfo.mType === \"musicstream\") return false;\r\n    if (inp.mInfo.mType === \"mic\")  return false;\r\n    if (inp.mInfo.mType === \"keyboard\")  return false;\r\n    if (inp.mInfo.mType === \"buffer\") return false;\r\n    return true;\r\n}\r\n\r\nEffectPass.prototype.GetSamplerFilter = function (id)\r\n{\r\n    let inp = this.mInputs[id];\r\n    if( inp===null) return;\r\n    return inp.mInfo.mSampler.filter;\r\n}\r\n\r\nEffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) \r\n{\r\n    var me = this;\r\n    var renderer = this.mRenderer;\r\n    let inp = this.mInputs[id];\r\n\r\n    let filter = renderer.FILTER.NONE;\r\n    if (str === \"linear\") filter = renderer.FILTER.LINEAR;\r\n    if (str === \"mipmap\") filter = renderer.FILTER.MIPMAP;\r\n\r\n    if (inp === null)\r\n    {\r\n    }\r\n    else if (inp.mInfo.mType === \"texture\")\r\n    {\r\n        if (inp.loaded)\r\n        {\r\n            renderer.SetSamplerFilter(inp.globject, filter, true);\r\n            inp.mInfo.mSampler.filter = str;\r\n        }\r\n    }\r\n    else if (inp.mInfo.mType === \"volume\")\r\n    {\r\n        if (inp.loaded)\r\n        {\r\n            renderer.SetSamplerFilter(inp.globject, filter, true);\r\n            inp.mInfo.mSampler.filter = str;\r\n        }\r\n    }\r\n    else if (inp.mInfo.mType === \"video\")\r\n    {\r\n        if (inp.loaded) \r\n        {\r\n            renderer.SetSamplerFilter(inp.globject, filter, true);\r\n            inp.mInfo.mSampler.filter = str;\r\n        }\r\n    }\r\n    else if (inp.mInfo.mType === \"cubemap\")\r\n    {\r\n        if (inp.loaded) \r\n        {\r\n            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)\r\n            {\r\n                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);\r\n                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);\r\n                inp.mInfo.mSampler.filter = str;\r\n            }\r\n            else\r\n            {\r\n                renderer.SetSamplerFilter(inp.globject, filter, true);\r\n                inp.mInfo.mSampler.filter = str;\r\n            }\r\n        }\r\n    }\r\n    else if (inp.mInfo.mType === \"webcam\")\r\n    {\r\n        if (inp.loaded) \r\n        {\r\n            renderer.SetSamplerFilter(inp.globject, filter, true);\r\n            inp.mInfo.mSampler.filter = str;\r\n        }\r\n    }\r\n    else if (inp.mInfo.mType === \"buffer\")\r\n    {\r\n        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);\r\n        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);\r\n        inp.mInfo.mSampler.filter = str;\r\n    }\r\n    else if (inp.mInfo.mType === \"keyboard\")\r\n    {\r\n        inp.mInfo.mSampler.filter = str;\r\n    }\r\n}\r\n\r\nEffectPass.prototype.GetAcceptsMipmapping = function (id)\r\n{\r\n    let inp = this.mInputs[id];\r\n\r\n    if (inp === null) return false;\r\n    if (inp.mInfo.mType === \"texture\") return true;\r\n    if (inp.mInfo.mType === \"volume\") return true;\r\n    if (inp.mInfo.mType === \"video\")  return this.mIs20;\r\n    if (inp.mInfo.mType === \"cubemap\") return true;\r\n    if (inp.mInfo.mType === \"webcam\")  return this.mIs20;\r\n    if (inp.mInfo.mType === \"music\")  return false;\r\n    if (inp.mInfo.mType === \"musicstream\") return false;\r\n    if (inp.mInfo.mType === \"mic\")  return false;\r\n    if (inp.mInfo.mType === \"keyboard\")  return false;\r\n    if (inp.mInfo.mType === \"buffer\") return this.mIs20;\r\n    return false;\r\n}\r\n\r\nEffectPass.prototype.GetAcceptsLinear = function (id)\r\n{\r\n    let inp = this.mInputs[id];\r\n\r\n    if (inp === null) return false;\r\n    if (inp.mInfo.mType === \"texture\") return true;\r\n    if (inp.mInfo.mType === \"volume\") return true;\r\n    if (inp.mInfo.mType === \"video\")  return true;\r\n    if (inp.mInfo.mType === \"cubemap\") return true;\r\n    if (inp.mInfo.mType === \"webcam\")  return true;\r\n    if (inp.mInfo.mType === \"music\")  return true;\r\n    if (inp.mInfo.mType === \"musicstream\") return true;\r\n    if (inp.mInfo.mType === \"mic\")  return true;\r\n    if (inp.mInfo.mType === \"keyboard\")  return false;\r\n    if (inp.mInfo.mType === \"buffer\") return true;\r\n    return false;\r\n}\r\n\r\nEffectPass.prototype.GetAcceptsWrapRepeat = function (id)\r\n{\r\n    let inp = this.mInputs[id];\r\n\r\n    if (inp === null) return false;\r\n    if (inp.mInfo.mType === \"texture\") return true;\r\n    if (inp.mInfo.mType === \"volume\") return true;\r\n    if (inp.mInfo.mType === \"video\")  return this.mIs20;\r\n    if (inp.mInfo.mType === \"cubemap\") return false;\r\n    if (inp.mInfo.mType === \"webcam\")  return this.mIs20;\r\n    if (inp.mInfo.mType === \"music\")  return false;\r\n    if (inp.mInfo.mType === \"musicstream\") return false;\r\n    if (inp.mInfo.mType === \"mic\")  return false;\r\n    if (inp.mInfo.mType === \"keyboard\")  return false;\r\n    if (inp.mInfo.mType === \"buffer\") return this.mIs20;\r\n    return false;\r\n}\r\n\r\nEffectPass.prototype.GetSamplerWrap = function (id)\r\n{\r\n    return this.mInputs[id].mInfo.mSampler.wrap;\r\n}\r\n\r\nEffectPass.prototype.SetSamplerWrap = function (id, str, buffers)\r\n{\r\n    var me = this;\r\n    var renderer = this.mRenderer;\r\n    let inp = this.mInputs[id];\r\n\r\n    let restr = renderer.TEXWRP.REPEAT;\r\n    if (str === \"clamp\") restr = renderer.TEXWRP.CLAMP;\r\n\r\n    if (inp === null) \r\n    {\r\n    }\r\n    else if (inp.mInfo.mType === \"texture\")\r\n    {\r\n        if (inp.loaded) \r\n        {\r\n            renderer.SetSamplerWrap(inp.globject, restr);\r\n            inp.mInfo.mSampler.wrap = str;\r\n        }\r\n    }\r\n    else if (inp.mInfo.mType === \"volume\")\r\n    {\r\n        if (inp.loaded) \r\n        {\r\n            renderer.SetSamplerWrap(inp.globject, restr);\r\n            inp.mInfo.mSampler.wrap = str;\r\n        }\r\n    }\r\n    else if (inp.mInfo.mType === \"video\") \r\n    {\r\n        if (inp.loaded) \r\n        {\r\n            renderer.SetSamplerWrap(inp.globject, restr);\r\n            inp.mInfo.mSampler.wrap = str;\r\n        }\r\n    }\r\n    else if (inp.mInfo.mType === \"cubemap\") \r\n    {\r\n        if (inp.loaded)\r\n        {\r\n            renderer.SetSamplerWrap(inp.globject, restr);\r\n            inp.mInfo.mSampler.wrap = str;\r\n        }\r\n    }\r\n    else if (inp.mInfo.mType === \"webcam\") \r\n    {\r\n        if (inp.loaded) \r\n        {\r\n            renderer.SetSamplerWrap(inp.globject, restr);\r\n            inp.mInfo.mSampler.wrap = str;\r\n        }\r\n    }\r\n    else if (inp.mInfo.mType === \"buffer\")\r\n    {\r\n        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);\r\n        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);\r\n        inp.mInfo.mSampler.wrap = str;\r\n    }\r\n}\r\n\r\n\r\nEffectPass.prototype.GetTexture = function( slot )\r\n{\r\n    let inp = this.mInputs[slot];\r\n    if( inp===null ) return null;\r\n    return inp.mInfo;\r\n}\r\n\r\nEffectPass.prototype.SetOutputs = function( slot, id )\r\n{\r\n    this.mOutputs[slot] = id;\r\n}\r\n\r\nEffectPass.prototype.SetOutputsByBufferID = function( slot, id )\r\n{\r\n    if( this.mType===\"buffer\" )\r\n    {\r\n        this.mOutputs[slot] = bufferID_to_assetID( id );\r\n\r\n        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );\r\n    }\r\n    else if( this.mType===\"cubemap\" )\r\n    {\r\n        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );\r\n        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );\r\n    }\r\n}\r\n\r\nEffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )\r\n{\r\n    var me = this;\r\n    var renderer = this.mRenderer;\r\n\r\n    if( renderer===null ) return;\r\n\r\n    let texture = null;\r\n\r\n    if( url===null || url.mType===null )\r\n    {\r\n        if( me.mTextureCallbackFun!==null )\r\n            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );\r\n        me.DestroyInput( slot );\r\n        me.mInputs[slot] = null;\r\n        me.MakeHeader();\r\n        return { mFailed:false, mNeedsShaderCompile:false };\r\n    }\r\n    else if( url.mType===\"texture\" )\r\n    {\r\n        texture = {};\r\n        texture.mInfo = url;\r\n        texture.globject = null;\r\n        texture.loaded = false;\r\n        texture.image = new Image();\r\n        texture.image.crossOrigin = '';\r\n        texture.image.onload = function()\r\n        {\r\n            let rti = me.Sampler2Renderer(url.mSampler);\r\n\r\n            // O.M.G. FIX THIS\r\n            let channels = renderer.TEXFMT.C4I8;\r\n            if (url.mID === \"Xdf3zn\" || url.mID === \"4sf3Rn\" || url.mID === \"4dXGzn\" || url.mID === \"4sf3Rr\")\r\n                channels = renderer.TEXFMT.C1I8;\r\n            \r\n            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);\r\n\r\n            texture.loaded = true;\r\n            if( me.mTextureCallbackFun!==null )\r\n                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );\r\n        }\r\n        texture.image.src = url.mSrc;\r\n\r\n\r\n        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (\r\n                                                                (this.mInputs[slot].mInfo.mType!==\"texture\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"webcam\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"mic\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"music\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"musicstream\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"keyboard\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"video\")) };\r\n        this.DestroyInput( slot );\r\n        this.mInputs[slot] = texture;\r\n        this.MakeHeader();\r\n        return returnValue;\r\n    }\r\n    else if( url.mType===\"volume\" )\r\n    {\r\n        texture = {};\r\n        texture.mInfo = url;\r\n        texture.globject = null;\r\n        texture.loaded = false;\r\n        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };\r\n        texture.mPreview = new Image();\r\n        texture.mPreview.crossOrigin = '';\r\n\r\n\t    var xmlHttp = new XMLHttpRequest();\r\n        if( xmlHttp===null ) return { mFailed:true };\r\n\r\n        xmlHttp.open('GET', url.mSrc, true);\r\n        xmlHttp.responseType = \"arraybuffer\";\r\n        xmlHttp.onerror = function()\r\n        {\r\n            console.log( \"Error 1 loading Volume\" );\r\n        }\r\n        xmlHttp.onload = function()\r\n        {\r\n            let data = xmlHttp.response;\r\n            if (!data ) { console.log( \"Error 2 loading Volume\" ); return; }\r\n\r\n            let file = piFile(data);\r\n\r\n            let signature = file.ReadUInt32();\r\n            texture.mImage.mXres = file.ReadUInt32();\r\n            texture.mImage.mYres = file.ReadUInt32();\r\n            texture.mImage.mZres = file.ReadUInt32();\r\n            let binNumChannels = file.ReadUInt8();\r\n            let binLayout = file.ReadUInt8();\r\n            let binFormat = file.ReadUInt16();\r\n            let format = renderer.TEXFMT.C1I8;\r\n                 if( binNumChannels===1 \u0026\u0026 binFormat===0 )  format = renderer.TEXFMT.C1I8;\r\n            else if( binNumChannels===2 \u0026\u0026 binFormat===0 )  format = renderer.TEXFMT.C2I8;\r\n            else if( binNumChannels===3 \u0026\u0026 binFormat===0 )  format = renderer.TEXFMT.C3I8;\r\n            else if( binNumChannels===4 \u0026\u0026 binFormat===0 )  format = renderer.TEXFMT.C4I8;\r\n            else if( binNumChannels===1 \u0026\u0026 binFormat===10 ) format = renderer.TEXFMT.C1F32;\r\n            else if( binNumChannels===2 \u0026\u0026 binFormat===10 ) format = renderer.TEXFMT.C2F32;\r\n            else if( binNumChannels===3 \u0026\u0026 binFormat===10 ) format = renderer.TEXFMT.C3F32;\r\n            else if( binNumChannels===4 \u0026\u0026 binFormat===10 ) format = renderer.TEXFMT.C4F32;\r\n            else return;\r\n\r\n            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)\r\n\r\n            let rti = me.Sampler2Renderer(url.mSampler);\r\n\r\n            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);\r\n\r\n            if( texture.globject===null )\r\n            {\r\n                console.log( \"Error 4: loading Volume\" ); \r\n                return { mFailed:true };\r\n            }\r\n\r\n            if (me.mTextureCallbackFun !== null)\r\n            {\r\n                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );\r\n            }\r\n\r\n            texture.loaded = true;\r\n\r\n            // load icon for it\r\n            texture.mPreview.onload = function()\r\n            {\r\n                if( me.mTextureCallbackFun!==null )\r\n                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );\r\n            }\r\n            texture.mPreview.src = url.mPreviewSrc;\r\n        }\r\n        xmlHttp.send(\"\");\r\n\r\n\r\n        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (\r\n                                                                (this.mInputs[slot].mInfo.mType!==\"volume\")) };\r\n        this.DestroyInput( slot );\r\n        this.mInputs[slot] = texture;\r\n        this.MakeHeader();\r\n        return returnValue;\r\n    }\r\n    else if( url.mType===\"cubemap\" )\r\n    {\r\n        texture = {};\r\n        texture.mInfo = url;\r\n        texture.globject = null;\r\n        texture.loaded = false;\r\n\r\n        let rti = me.Sampler2Renderer(url.mSampler);\r\n\r\n        if( assetID_to_cubemapBuferID(url.mID)!==-1 )\r\n        {\r\n            texture.mImage = new Image();\r\n            texture.mImage.onload = function()\r\n            {\r\n                texture.loaded = true;\r\n                if( me.mTextureCallbackFun!==null )\r\n                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );\r\n            }\r\n            texture.mImage.src = \"/media/previz/cubemap00.png\";\r\n\r\n            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );\r\n\r\n        }\r\n        else\r\n        {\r\n            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];\r\n\r\n            let numLoaded = 0;\r\n            for (var i=0; i\u003c6; i++ )\r\n            {\r\n                texture.image[i].mId = i;\r\n                texture.image[i].crossOrigin = '';\r\n                texture.image[i].onload = function()\r\n                {\r\n                    var id = this.mId;\r\n                    numLoaded++;\r\n                    if( numLoaded===6 )\r\n                    {\r\n                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);\r\n                        texture.loaded = true;\r\n                        if (me.mTextureCallbackFun !== null)\r\n                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);\r\n                    }\r\n                }\r\n\r\n                if( i === 0) \r\n                {\r\n                    texture.image[i].src = url.mSrc;\r\n                } \r\n                else \r\n                {\r\n                    let n = url.mSrc.lastIndexOf(\".\");\r\n                    texture.image[i].src = url.mSrc.substring(0, n) + \"_\" + i + url.mSrc.substring(n, url.mSrc.length);\r\n                }\r\n            }\r\n        }\r\n\r\n        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (\r\n                                                                (this.mInputs[slot].mInfo.mType!==\"cubemap\")) };\r\n\r\n        this.DestroyInput( slot );\r\n        this.mInputs[slot] = texture;\r\n        this.MakeHeader();\r\n        return returnValue;\r\n    }\r\n    else if( url.mType===\"webcam\" )\r\n    {\r\n        texture = {};\r\n        texture.mInfo = url;\r\n        texture.globject = null;\r\n        texture.loaded = false;\r\n\r\n        texture.video = document.createElement('video');\r\n    \ttexture.video.width = 320;\r\n    \ttexture.video.height = 240;\r\n    \ttexture.video.autoplay = true;\r\n    \ttexture.video.loop = true;\r\n        texture.mForceMuted = this.mForceMuted;\r\n        texture.mImage = null;\r\n\r\n        let rti = me.Sampler2Renderer(url.mSampler);\r\n\r\n        var loadImageInsteadOfWebCam = function()\r\n        {\r\n            texture.mImage = new Image();\r\n            texture.mImage.onload = function()\r\n            {\r\n                texture.loaded = true;\r\n                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);\r\n                if( me.mTextureCallbackFun!==null )\r\n                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );\r\n            }\r\n            texture.mImage.src = \"/media/previz/webcam.png\";\r\n        }\r\n        \r\n        loadImageInsteadOfWebCam();\r\n\r\n        if( typeof navigator.getUserMedia !== \"undefined\"  \u0026\u0026 texture.mForceMuted===false )\r\n        {\r\n            texture.video.addEventListener(\"canplay\", function (e)\r\n            {\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n                    texture.mImage = null;\r\n                    if( texture.globject != null )\r\n                        renderer.DestroyTexture( texture.globject );\r\n\t\t\t\t\ttexture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);\r\n\t\t\t\t\ttexture.loaded = true;\r\n                }\r\n                catch(e)\r\n                {\r\n                    loadImageInsteadOfWebCam();\r\n\t                alert( 'Your browser can not transfer webcam data to the GPU.');\r\n                }\r\n            } );\r\n\r\n            navigator.mediaDevices.getUserMedia( \r\n                                { \"video\": { width: 1280, height: 720 }, \"audio\": false } )\r\n                                .then( function(stream)\r\n                                       {\r\n                                            texture.video.srcObject = stream;\r\n    \t                               } )\r\n                                .catch( function(error)\r\n                                        {\r\n                                            loadImageInsteadOfWebCam();\r\n    \t\t                                alert( 'Unable to capture WebCam. Please reload the page.' );\r\n    \t                                } );\r\n        }\r\n        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (\r\n                                                                (this.mInputs[slot].mInfo.mType!==\"texture\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"webcam\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"mic\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"music\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"musicstream\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"keyboard\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"video\")) };\r\n        this.DestroyInput( slot );\r\n        this.mInputs[slot] = texture;\r\n        this.MakeHeader();\r\n        return returnValue;\r\n    }\r\n    else if( url.mType===\"mic\" )\r\n    {\r\n        texture = {};\r\n        texture.mInfo = url;\r\n        texture.globject = null;\r\n        texture.loaded = false;\r\n        texture.mForceMuted = this.mForceMuted;\r\n        texture.mAnalyser = null;\r\n        let num = 512;\r\n        texture.mFreqData = new Uint8Array( num );\r\n        texture.mWaveData = new Uint8Array( num );\r\n\r\n        if( wa === null || typeof navigator.getUserMedia === \"undefined\" )\r\n        {\r\n            if( !texture.mForceMuted ) alert( \"Shadertoy: Web Audio not implement in this browser\" );\r\n            texture.mForceMuted = true; \r\n        }\r\n\r\n        if( texture.mForceMuted )\r\n        {\r\n            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)\r\n            texture.loaded = true;\r\n        }\r\n        else\r\n        {\r\n        navigator.getUserMedia( { \"audio\": true },\r\n                                function(stream)\r\n                                {\r\n                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)\r\n                                  texture.mic = wa.createMediaStreamSource(stream);\r\n                                  texture.mAnalyser = wa.createAnalyser();\r\n                                  texture.mic.connect( texture.mAnalyser );\r\n                                  texture.loaded = true;\r\n    \t                        },\r\n                                function(error)\r\n                                {\r\n    \t\t                        alert( 'Unable open Mic. Please reload the page.' );\r\n    \t                        } );\r\n        }\r\n        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (\r\n                                                                (this.mInputs[slot].mInfo.mType!==\"texture\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"webcam\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"mic\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"music\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"musicstream\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"keyboard\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"video\")) };\r\n        this.DestroyInput( slot );\r\n        this.mInputs[slot] = texture;\r\n        this.MakeHeader();\r\n        return returnValue;\r\n    }\r\n    else if( url.mType===\"video\" )\r\n    {\r\n    \ttexture = {};\r\n        texture.mInfo = url;\r\n        texture.globject = null;\r\n        texture.loaded = false;\r\n        texture.video = document.createElement('video');\r\n    \ttexture.video.loop = true;\r\n        texture.video.preload = \"auto\";\r\n        texture.video.mPaused = this.mForcePaused;\r\n        texture.video.mMuted = true;//this.mForceMuted;\r\n    \ttexture.video.muted  = true;//this.mForceMuted;\r\n        if( this.mForceMuted===true )\r\n            texture.video.volume = 0;\r\n    \ttexture.video.autoplay = false;\r\n        texture.video.hasFalled = false;\r\n        \r\n        let rti = me.Sampler2Renderer(url.mSampler);\r\n\r\n        texture.video.addEventListener(\"canplay\", function (e)\r\n        {\r\n            texture.video.play().then( function()\r\n                                       {\r\n                                           texture.video.mPaused = false;\r\n\r\n                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);\r\n                                           texture.loaded = true;\r\n            \r\n                                           if( me.mTextureCallbackFun!=null )\r\n                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );\r\n                                        } )\r\n                               .catch( function(error)\r\n                                       {\r\n                                           console.log( error );\r\n                                       }\r\n                                );\r\n        } );\r\n\r\n        texture.video.addEventListener( \"error\", function(e)\r\n        {\r\n               if( texture.video.hasFalled===true ) { alert(\"Error: cannot load video\" ); return; }\r\n               let str = texture.video.src;\r\n               str = str.substr(0,str.lastIndexOf('.') ) + \".mp4\";\r\n               texture.video.src = str;\r\n               texture.video.hasFalled = true;\r\n        } );\r\n\r\n        texture.video.src = url.mSrc;\r\n\r\n        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (\r\n                                                                (this.mInputs[slot].mInfo.mType!==\"texture\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"webcam\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"mic\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"music\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"musicstream\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"keyboard\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"video\")) };\r\n        this.DestroyInput( slot );\r\n        this.mInputs[slot] = texture;\r\n        this.MakeHeader();\r\n        return returnValue;\r\n    }\r\n    else if( url.mType===\"music\" || url.mType===\"musicstream\" )\r\n    {\r\n    \ttexture = {};\r\n        texture.mInfo = url;\r\n        texture.globject = null;\r\n        texture.loaded = false;\r\n        texture.audio = document.createElement('audio');\r\n    \ttexture.audio.loop = true;\r\n        texture.audio.mMuted = this.mForceMuted;\r\n        texture.audio.mForceMuted = this.mForceMuted;\r\n        texture.audio.muted = this.mForceMuted;\r\n        if( this.mForceMuted===true )\r\n            texture.audio.volume = 0;\r\n        texture.audio.autoplay = false;\r\n        texture.audio.hasFalled = false;\r\n        texture.audio.mPaused = false;\r\n        texture.audio.mSound = {};\r\n\r\n        if( this.mForceMuted===false )\r\n        {\r\n            if(url.mType===\"musicstream\" \u0026\u0026 SC === null)\r\n            {\r\n                alert( \"Shadertoy: Soundcloud could not be reached\" );\r\n                texture.audio.mForceMuted = true;\r\n            }\r\n            }\r\n\r\n        if( wa === null \u0026\u0026 this.mForceMuted===false )\r\n        {\r\n            alert( \"Shadertoy: Web Audio not implement in this browser\" );\r\n            texture.audio.mForceMuted = true;\r\n        }\r\n\r\n        if( texture.audio.mForceMuted )\r\n        {\r\n            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);\r\n            let num = 512;\r\n            texture.audio.mSound.mFreqData = new Uint8Array( num );\r\n            texture.audio.mSound.mWaveData = new Uint8Array( num );\r\n            texture.loaded = true;\r\n        }\r\n\r\n        texture.audio.addEventListener( \"canplay\", function()\r\n        {\r\n            if( texture===null || texture.audio===null ) return;\r\n            if( this.mForceMuted  ) return;\r\n            if( texture.loaded === true ) return;\r\n\r\n            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)\r\n\r\n            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );\r\n            texture.audio.mSound.mAnalyser = wa.createAnalyser();\r\n            texture.audio.mSound.mGain     = wa.createGain();\r\n\r\n            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );\r\n            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );\r\n            texture.audio.mSound.mGain.connect(me.mGainNode);\r\n\r\n            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );\r\n            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );\r\n\r\n            if( texture.audio.mPaused )\r\n            {\r\n                texture.audio.pause();\r\n            }\r\n            else\r\n            {\r\n                texture.audio.play().then( function() {} ).catch( function(e){console.log(\"error \" + e);} );\r\n            }\r\n            texture.loaded = true;\r\n        } );\r\n\r\n        texture.audio.addEventListener( \"error\", function(e)\r\n        {\r\n               if( this.mForceMuted  ) return;\r\n\r\n               if( texture.audio.hasFalled===true ) { return; }\r\n               let str = texture.audio.src;\r\n               str = str.substr(0,str.lastIndexOf('.') ) + \".ogg\";\r\n               texture.audio.src = str;\r\n               texture.audio.hasFalled = true;\r\n        } );\r\n\r\n        if( !texture.audio.mForceMuted )\r\n        {\r\n            if(url.mType===\"musicstream\")\r\n            {\r\n                SC.resolve(url.mSrc, \r\n                    function(song) \r\n                    {\r\n                        if( song.streamable===true )\r\n                        {\r\n                            texture.audio.crossOrigin = 'anonymous';\r\n                            texture.audio.src = song.stream_url;\r\n                            texture.audio.soundcloudInfo = song;\r\n                        }\r\n                        else\r\n                        {\r\n                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );\r\n                        }\r\n                    },\r\n                    function(error)\r\n                    {\r\n                        if (me.mTextureCallbackFun!==null)\r\n                        {\r\n                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);\r\n                        }\r\n                    } );\r\n            } \r\n            else\r\n            {\r\n                texture.audio.src = url.mSrc;\r\n            }\r\n        }\r\n\r\n        if (me.mTextureCallbackFun!==null)\r\n        {\r\n            if (url.mType === \"music\")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);\r\n            else if (url.mType === \"musicstream\") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);\r\n        }\r\n\r\n        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (\r\n                                                                (this.mInputs[slot].mInfo.mType!==\"texture\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"webcam\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"mic\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"music\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"musicstream\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"keyboard\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"video\")) };\r\n        this.DestroyInput( slot );\r\n        this.mInputs[slot] = texture;\r\n        this.MakeHeader();\r\n        return returnValue;\r\n    }\r\n    else if( url.mType===\"keyboard\" )\r\n    {\r\n    \ttexture = {};\r\n        texture.mInfo = url;\r\n        texture.globject = null;\r\n        texture.loaded = true;\r\n\r\n        texture.keyboard = {};\r\n\r\n        if( me.mTextureCallbackFun!==null )\r\n            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );\r\n\r\n        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (\r\n                                                                (this.mInputs[slot].mInfo.mType!=\"texture\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!=\"webcam\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!=\"mic\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!=\"music\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!=\"musicstream\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!=\"keyboard\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!=\"video\")) };\r\n        this.DestroyInput( slot );\r\n        this.mInputs[slot] = texture;\r\n        this.MakeHeader();\r\n        return returnValue;\r\n    }\r\n    else if( url.mType===\"buffer\" )\r\n    {\r\n        texture = {};\r\n        texture.mInfo = url;\r\n\r\n        texture.image = new Image();\r\n        texture.image.onload = function()\r\n        {\r\n            if( me.mTextureCallbackFun!==null )\r\n                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );\r\n        }\r\n        texture.image.src = url.mSrc;\r\n        texture.id = assetID_to_bufferID( url.mID );\r\n        texture.loaded = true;\r\n\r\n        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (\r\n                                                                (this.mInputs[slot].mInfo.mType!==\"texture\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"webcam\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"mic\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"music\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"musicstream\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"keyboard\") \u0026\u0026 \r\n                                                                (this.mInputs[slot].mInfo.mType!==\"video\")) };\r\n\r\n        this.DestroyInput( slot );\r\n        this.mInputs[slot] = texture;\r\n\r\n        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );\r\n\r\n        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);\r\n        this.SetSamplerVFlip(slot, url.mSampler.vflip);\r\n        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);\r\n\r\n        this.MakeHeader();\r\n        return returnValue;\r\n    }\r\n    else\r\n    {\r\n        alert( \"input type error\" );\r\n        return { mFailed: true };\r\n    }\r\n\r\n    return { mFailed: true };\r\n}\r\n\r\nEffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )\r\n{\r\n    let times = [ 0.0, 0.0, 0.0, 0.0 ];\r\n\r\n    let dates = [ d.getFullYear(), // the year (four digits)\r\n                  d.getMonth(),\t   // the month (from 0-11)\r\n                  d.getDate(),     // the day of the month (from 1-31)\r\n                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];\r\n\r\n    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];\r\n\r\n    //------------------------\r\n    \r\n    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];\r\n    let texIsLoaded = [0, 0, 0, 0 ];\r\n    let texID = [ null, null, null, null];\r\n\r\n    for (let i=0; i\u003cthis.mInputs.length; i++ )\r\n    {\r\n        let inp = this.mInputs[i];\r\n\r\n        if( inp===null )\r\n        {\r\n        }\r\n        else if( inp.mInfo.mType===\"texture\" )\r\n        {\r\n            if( inp.loaded===true  )\r\n            {\r\n                texID[i] = inp.globject;\r\n                texIsLoaded[i] = 1;\r\n                resos[3*i+0] = inp.image.width;\r\n                resos[3*i+1] = inp.image.height;\r\n                resos[3*i+2] = 1;\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"volume\" )\r\n        {\r\n            if( inp.loaded===true  )\r\n            {\r\n                texID[i] = inp.globject;\r\n                texIsLoaded[i] = 1;\r\n                resos[3*i+0] = inp.mImage.mXres;\r\n                resos[3*i+1] = inp.mImage.mYres;\r\n                resos[3*i+2] = inp.mImage.mZres;\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"keyboard\" )\r\n        {\r\n            texID[i] = keyboard.mTexture;\r\n            texIsLoaded[i] = 1;\r\n            resos[3*i+0] = 256;\r\n            resos[3*i+1] = 3;\r\n            resos[3*i+2] = 1;\r\n        }\r\n        else if( inp.mInfo.mType===\"cubemap\" )\r\n        {\r\n            if (inp.loaded === true)\r\n            {\r\n                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);\r\n                if( id!==-1 )\r\n                {\r\n                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];\r\n                    resos[3*i+0] = cubeBuffers[id].mResolution[0];\r\n                    resos[3*i+1] = cubeBuffers[id].mResolution[1];\r\n                    resos[3*i+2] = 1;\r\n                    texIsLoaded[i] = 1;\r\n\r\n                    // hack. in webgl2.0 we have samplers, so we don't need this crap here\r\n                    let filter = this.mRenderer.FILTER.NONE;\r\n                         if (inp.mInfo.mSampler.filter === \"linear\") filter = this.mRenderer.FILTER.LINEAR;\r\n                    else if (inp.mInfo.mSampler.filter === \"mipmap\") filter = this.mRenderer.FILTER.MIPMAP;\r\n                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);\r\n                }\r\n                else\r\n                {\r\n                    texID[i] = inp.globject;\r\n                    texIsLoaded[i] = 1;\r\n                }\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"webcam\" )\r\n        {\r\n            if( inp.loaded===true )\r\n            {\r\n                if( inp.mImage !== null )\r\n                {\r\n                    if( this.mTextureCallbackFun!==null )\r\n                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );\r\n\r\n                    texID[i] = inp.globject;\r\n                    texIsLoaded[i] = 1;\r\n                    resos[3*i+0] = inp.mImage.width;\r\n                    resos[3*i+1] = inp.mImage.height;\r\n                    resos[3*i+2] = 1;\r\n                }\r\n                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )\r\n                {\r\n\r\n                    if( this.mTextureCallbackFun!==null )\r\n                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );\r\n\r\n                    texID[i] = inp.globject;\r\n                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);\r\n                    if( inp.mInfo.mSampler.filter === \"mipmap\" )\r\n                        this.mRenderer.CreateMipmaps(inp.globject);\r\n                    resos[3*i+0] = inp.video.videoWidth;\r\n                    resos[3*i+1] = inp.video.videoHeight;\r\n                    resos[3*i+2] = 1;\r\n                    texIsLoaded[i] = 1;\r\n                }\r\n            }\r\n            else \r\n            {\r\n                texID[i] = null;\r\n                texIsLoaded[i] = 0;\r\n                resos[3*i+0] = inp.video.width;\r\n                resos[3*i+1] = inp.video.height;\r\n                resos[3*i+2] = 1;\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"video\" )\r\n        {\r\n            if( inp.video.mPaused === false )\r\n            {\r\n                if( this.mTextureCallbackFun!==null )\r\n                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );\r\n            }\r\n\r\n            if( inp.loaded===true )\r\n            { \r\n                times[i] = inp.video.currentTime;\r\n                texID[i] = inp.globject;\r\n                texIsLoaded[i] = 1;\r\n\r\n      \t        if( inp.video.mPaused === false )\r\n      \t        {\r\n      \t            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);\r\n                    if( inp.mInfo.mSampler.filter === \"mipmap\" )\r\n                        this.mRenderer.CreateMipmaps(inp.globject);\r\n                }\r\n                resos[3*i+0] = inp.video.videoWidth;\r\n                resos[3*i+1] = inp.video.videoHeight;\r\n                resos[3*i+2] = 1;\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"music\" || inp.mInfo.mType===\"musicstream\" )\r\n        {\r\n            if( inp.audio.mPaused === false \u0026\u0026 inp.audio.mForceMuted === false \u0026\u0026 inp.loaded===true )\r\n            {\r\n                if( wa !== null )\r\n                {\r\n                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );\r\n                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );\r\n                }\r\n\r\n                if( this.mTextureCallbackFun!==null )\r\n                {\r\n                         if( inp.mInfo.mType===\"music\")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);\r\n                    else if( inp.mInfo.mType===\"musicstream\") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);\r\n                }\r\n            }\r\n\r\n            if( inp.loaded===true )\r\n            {\r\n                times[i] = inp.audio.currentTime;\r\n                texID[i] = inp.globject;\r\n                texIsLoaded[i] = 1;\r\n\r\n                if( inp.audio.mForceMuted === true )\r\n                {\r\n                    times[i] = 10.0 + time;\r\n                    let num = inp.audio.mSound.mFreqData.length;\r\n                    for (let j=0; j\u003cnum; j++ )\r\n                    {\r\n                        let x = j / num;\r\n                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );\r\n\r\n                        if( j\u003c3 )\r\n                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);\r\n\r\n                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;\r\n                    }\r\n\r\n                  //let num = inp.audio.mSound.mFreqData.length;\r\n                    for (let j=0; j\u003cnum; j++ )\r\n                    {\r\n                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );\r\n                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;\r\n                    }\r\n\r\n                }\r\n\r\n      \t        if( inp.audio.mPaused === false )\r\n                {\r\n      \t            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);\r\n      \t            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);\r\n      \t            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);\r\n                }\r\n\r\n                resos[3*i+0] = 512;\r\n                resos[3*i+1] = 2;\r\n                resos[3*i+2] = 1;\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"mic\" )\r\n        {\r\n            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )\r\n            {\r\n                    times[i] = 10.0 + time;\r\n                    let num = inp.mFreqData.length;\r\n                    for( let j=0; j\u003cnum; j++ )\r\n                    {\r\n                        let x = j / num;\r\n                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );\r\n\r\n                        if( j\u003c3 )\r\n                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);\r\n\r\n                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;\r\n                    }\r\n\r\n                    for( let j=0; j\u003cnum; j++ )\r\n                    {\r\n                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );\r\n                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;\r\n                    }\r\n            }\r\n            else\r\n            {\r\n                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );\r\n                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );\r\n            }\r\n\r\n            if( this.mTextureCallbackFun!==null )\r\n                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );\r\n\r\n            if( inp.loaded===true )\r\n            {\r\n                texID[i] = inp.globject;\r\n                texIsLoaded[i] = 1;\r\n                let waveLen = Math.min( inp.mWaveData.length, 512 );\r\n                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);\r\n                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);\r\n                resos[3*i+0] = 512;\r\n                resos[3*i+1] = 2;\r\n                resos[3*i+2] = 1;\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"buffer\" )\r\n        {\r\n            let id = inp.id;\r\n            if( inp.loaded===true  )\r\n            {\r\n                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];\r\n                texIsLoaded[i] = 1;\r\n                resos[3*i+0] = xres;\r\n                resos[3*i+1] = yres;\r\n                resos[3*i+2] = 1;\r\n                // hack. in webgl2.0 we have samplers, so we don't need this crap here\r\n                let filter = this.mRenderer.FILTER.NONE;\r\n                     if (inp.mInfo.mSampler.filter === \"linear\") filter = this.mRenderer.FILTER.LINEAR;\r\n                else if (inp.mInfo.mSampler.filter === \"mipmap\") filter = this.mRenderer.FILTER.MIPMAP;\r\n                this.mRenderer.SetSamplerFilter( texID[i], filter, false);\r\n            }\r\n\r\n            if( this.mTextureCallbackFun!==null )\r\n            {\r\n                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );\r\n            }\r\n        }\r\n    }\r\n\r\n    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );\r\n\r\n    //-----------------------------------\r\n\r\n    let prog = this.mProgram;\r\n\r\n    //if( vrData!=null \u0026\u0026 this.mSupportsVR ) prog = this.mProgramVR;\r\n\r\n    this.mRenderer.AttachShader(prog);\r\n\r\n    this.mRenderer.SetShaderConstant1F(  \"iTime\", time);\r\n    this.mRenderer.SetShaderConstant3F(  \"iResolution\", xres, yres, 1.0);\r\n    this.mRenderer.SetShaderConstant4FV( \"iMouse\", mouse);\r\n    this.mRenderer.SetShaderConstant1FV( \"iChannelTime\", times );              // OBSOLETE\r\n    this.mRenderer.SetShaderConstant4FV( \"iDate\", dates );\r\n    this.mRenderer.SetShaderConstant3FV( \"iChannelResolution\", resos );        // OBSOLETE\r\n    this.mRenderer.SetShaderConstant1F(  \"iSampleRate\", this.mSampleRate);\r\n    this.mRenderer.SetShaderTextureUnit( \"iChannel0\", 0 );\r\n    this.mRenderer.SetShaderTextureUnit( \"iChannel1\", 1 );\r\n    this.mRenderer.SetShaderTextureUnit( \"iChannel2\", 2 );\r\n    this.mRenderer.SetShaderTextureUnit( \"iChannel3\", 3 );\r\n    this.mRenderer.SetShaderConstant1I(  \"iFrame\", this.mFrame );\r\n    this.mRenderer.SetShaderConstant1F(  \"iTimeDelta\", dtime);\r\n    this.mRenderer.SetShaderConstant1F(\"iFrameRate\", fps);\r\n\r\n    this.mRenderer.SetShaderConstant1F(  \"iCh0.time\", times[0] );\r\n    this.mRenderer.SetShaderConstant1F(  \"iCh1.time\", times[1] );\r\n    this.mRenderer.SetShaderConstant1F(  \"iCh2.time\", times[2] );\r\n    this.mRenderer.SetShaderConstant1F(  \"iCh3.time\", times[3] );\r\n    this.mRenderer.SetShaderConstant3F(  \"iCh0.size\", resos[0], resos[ 1], resos[ 2] );\r\n    this.mRenderer.SetShaderConstant3F(  \"iCh1.size\", resos[3], resos[ 4], resos[ 5] );\r\n    this.mRenderer.SetShaderConstant3F(  \"iCh2.size\", resos[6], resos[ 7], resos[ 8] );\r\n    this.mRenderer.SetShaderConstant3F(  \"iCh3.size\", resos[9], resos[10], resos[11] );\r\n    this.mRenderer.SetShaderConstant1I(  \"iCh0.loaded\", texIsLoaded[0] );\r\n    this.mRenderer.SetShaderConstant1I(  \"iCh1.loaded\", texIsLoaded[1] );\r\n    this.mRenderer.SetShaderConstant1I(  \"iCh2.loaded\", texIsLoaded[2] );\r\n    this.mRenderer.SetShaderConstant1I(  \"iCh3.loaded\", texIsLoaded[3] );\r\n\r\n    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, \"pos\");\r\n\r\n    if( (vrData !== null) \u0026\u0026 this.mSupportsVR )\r\n    {\r\n        for (let i=0; i\u003c2; i++ )\r\n        {\r\n            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;\r\n\r\n            let vp = [i * xres / 2, 0, xres / 2, yres];\r\n\r\n            this.mRenderer.SetViewport(vp);\r\n\r\n            let fov = ei.mProjection;\r\n            let corA = [ -fov[2], -fov[1], -1.0 ];\r\n            let corB = [  fov[3], -fov[1], -1.0 ];\r\n            let corC = [  fov[3],  fov[0], -1.0 ];\r\n            let corD = [ -fov[2],  fov[0], -1.0 ];\r\n            let apex = [ 0.0, 0.0, 0.0 ];\r\n\r\n            let ma = invertFast( ei.mCamera );\r\n            corA = matMulpoint( ma, corA ); \r\n            corB = matMulpoint( ma, corB ); \r\n            corC = matMulpoint( ma, corC ); \r\n            corD = matMulpoint( ma, corD ); \r\n            apex = matMulpoint( ma, apex ); \r\n\r\n            let corners = [ corA[0], corA[1], corA[2], \r\n                            corB[0], corB[1], corB[2], \r\n                            corC[0], corC[1], corC[2], \r\n                            corD[0], corD[1], corD[2],\r\n                            apex[0], apex[1], apex[2]];\r\n\r\n            this.mRenderer.SetShaderConstant3FV(\"unCorners\", corners);\r\n            this.mRenderer.SetShaderConstant4FV(\"unViewport\", vp);\r\n\r\n            this.mRenderer.DrawUnitQuad_XY(l1);\r\n        }\r\n    }\r\n    else \r\n    {\r\n        this.mRenderer.SetViewport([0, 0, xres, yres]);\r\n        this.mRenderer.DrawFullScreenTriangle_XY( l1 );\r\n    }\r\n\r\n    this.mRenderer.DettachTextures();\r\n}\r\n\r\nEffectPass.prototype.iRenderSound = function(d, callback )\r\n{\r\n    let dates = [ d.getFullYear(), // the year (four digits)\r\n                  d.getMonth(),\t   // the month (from 0-11)\r\n                  d.getDate(),     // the day of the month (from 1-31)\r\n                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];\r\n\r\n    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];\r\n\r\n    this.mRenderer.SetRenderTarget(this.mRenderFBO);\r\n\r\n    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);\r\n    this.mRenderer.AttachShader(this.mProgram);\r\n    this.mRenderer.SetBlend( false );\r\n\r\n    let texID = [null, null, null, null];\r\n    for (let i = 0; i \u003c this.mInputs.length; i++)\r\n    {\r\n        let inp = this.mInputs[i];\r\n\r\n        if( inp===null )\r\n        {\r\n        }\r\n        else if( inp.mInfo.mType===\"texture\" )\r\n        {\r\n            if( inp.loaded===true  )\r\n            {\r\n                texID[i] = inp.globject;\r\n                resos[3*i+0] = inp.image.width;\r\n                resos[3*i+1] = inp.image.height;\r\n                resos[3*i+2] = 1;\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"volume\" )\r\n        {\r\n            if( inp.loaded===true  )\r\n            {\r\n                texID[i] = inp.globject;\r\n                resos[3*i+0] = inp.mImage.mXres;\r\n                resos[3*i+1] = inp.mImage.mYres;\r\n                resos[3*i+2] = inp.mImage.mZres;\r\n            }\r\n        }\r\n    }\r\n\r\n    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);\r\n\r\n    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, \"iTimeOffset\");\r\n    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, \"iSampleOffset\");\r\n    this.mRenderer.SetShaderConstant4FV(\"iDate\", dates);\r\n    this.mRenderer.SetShaderConstant3FV(\"iChannelResolution\", resos);\r\n    this.mRenderer.SetShaderConstant1F(\"iSampleRate\", this.mSampleRate);\r\n    this.mRenderer.SetShaderTextureUnit(\"iChannel0\", 0);\r\n    this.mRenderer.SetShaderTextureUnit(\"iChannel1\", 1);\r\n    this.mRenderer.SetShaderTextureUnit(\"iChannel2\", 2);\r\n    this.mRenderer.SetShaderTextureUnit(\"iChannel3\", 3);\r\n\r\n    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, \"pos\");\r\n\r\n    //--------------------------------\r\n    let numSamples = this.mTmpBufferSamples;\r\n    let numBlocks = this.mPlaySamples / numSamples;\r\n    for (let j=0; j\u003cnumBlocks; j++ )\r\n    {\r\n        let off = j*numSamples;\r\n        \r\n        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);\r\n        this.mRenderer.SetShaderConstant1I_Pos(l3, off );\r\n        this.mRenderer.DrawUnitQuad_XY(l1);\r\n\r\n        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);\r\n\r\n        callback( off, this.mData, numSamples );\r\n    }\r\n\r\n    this.mRenderer.DetachShader();\r\n    this.mRenderer.DettachTextures();\r\n    this.mRenderer.SetRenderTarget(null);\r\n}\r\n\r\nEffectPass.prototype.Paint_Sound = function( wa, d )\r\n{\r\n    let bufL = this.mBuffer.getChannelData(0); // Float32Array\r\n    let bufR = this.mBuffer.getChannelData(1); // Float32Array\r\n\r\n    this.iRenderSound( d, function(off, data, numSamples)\r\n                         {\r\n                            for( let i=0; i\u003cnumSamples; i++ )\r\n                            {\r\n                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;\r\n                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;\r\n                            }\r\n                         }\r\n                     );\r\n}\r\n\r\nEffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )\r\n{\r\n    let times = [ 0.0, 0.0, 0.0, 0.0 ];\r\n\r\n    let dates = [ d.getFullYear(), // the year (four digits)\r\n                  d.getMonth(),\t   // the month (from 0-11)\r\n                  d.getDate(),     // the day of the month (from 1-31)\r\n                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];\r\n\r\n    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];\r\n\r\n    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];\r\n\r\n    //------------------------\r\n    \r\n    let texID = [ null, null, null, null];\r\n\r\n    for( let i=0; i\u003cthis.mInputs.length; i++ )\r\n    {\r\n        let inp = this.mInputs[i];\r\n\r\n        if( inp===null )\r\n        {\r\n        }\r\n        else if( inp.mInfo.mType===\"texture\" )\r\n        {\r\n            if( inp.loaded===true  )\r\n            {\r\n                texID[i] = inp.globject;\r\n                resos[3*i+0] = inp.image.width;\r\n                resos[3*i+1] = inp.image.height;\r\n                resos[3*i+2] = 1;\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"volume\" )\r\n        {\r\n            if( inp.loaded===true  )\r\n            {\r\n                texID[i] = inp.globject;\r\n                resos[3*i+0] = inp.mImage.mXres;\r\n                resos[3*i+1] = inp.mImage.mYres;\r\n                resos[3*i+2] = inp.mImage.mZres;\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"keyboard\" )\r\n        {\r\n            texID[i] = keyboard.mTexture;\r\n        }\r\n        else if( inp.mInfo.mType==\"cubemap\" )\r\n        {\r\n            if (inp.loaded === true)\r\n            {\r\n                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);\r\n                if( id!==-1 )\r\n                {\r\n                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];\r\n                    resos[3*i+0] = cubeBuffers[id].mResolution[0];\r\n                    resos[3*i+1] = cubeBuffers[id].mResolution[1];\r\n                    resos[3*i+2] = 1;\r\n    \r\n                    // hack. in webgl2.0 we have samplers, so we don't need this crap here\r\n                    let filter = this.mRenderer.FILTER.NONE;\r\n                         if (inp.mInfo.mSampler.filter === \"linear\") filter = this.mRenderer.FILTER.LINEAR;\r\n                    else if (inp.mInfo.mSampler.filter === \"mipmap\") filter = this.mRenderer.FILTER.MIPMAP;\r\n                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);\r\n                }\r\n                else\r\n                {\r\n                    texID[i] = inp.globject;\r\n                }\r\n            }\r\n\r\n        }\r\n        else if( inp.mInfo.mType===\"webcam\" )\r\n        {\r\n            if( inp.loaded===true )\r\n            {\r\n                if( inp.mImage !== null )\r\n                {\r\n                    texID[i] = inp.globject;\r\n                    resos[3*i+0] = inp.mImage.width;\r\n                    resos[3*i+1] = inp.mImage.height;\r\n                    resos[3*i+2] = 1;\r\n                }\r\n                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )\r\n                {\r\n                    texID[i] = inp.globject;\r\n                    resos[3*i+0] = inp.video.videoWidth;\r\n                    resos[3*i+1] = inp.video.videoHeight;\r\n                    resos[3*i+2] = 1;\r\n                }\r\n            }\r\n            else \r\n            {\r\n                texID[i] = null;\r\n                resos[3*i+0] = inp.video.width;\r\n                resos[3*i+1] = inp.video.height;\r\n                resos[3*i+2] = 1;\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"video\" )\r\n        {\r\n           if( inp.loaded===true )\r\n           { \r\n                times[i] = inp.video.currentTime;\r\n                texID[i] = inp.globject;\r\n                resos[3*i+0] = inp.video.videoWidth;\r\n                resos[3*i+1] = inp.video.videoHeight;\r\n                resos[3*i+2] = 1;\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"music\" || inp.mInfo.mType===\"musicstream\" )\r\n        {\r\n            if( inp.loaded===true )\r\n            {\r\n                times[i] = inp.audio.currentTime;\r\n                texID[i] = inp.globject;\r\n\r\n                if( inp.audio.mForceMuted === true )\r\n                {\r\n                    times[i] = 10.0 + time;\r\n                }\r\n\r\n                resos[3*i+0] = 512;\r\n                resos[3*i+1] = 2;\r\n                resos[3*i+2] = 1;\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"mic\" )\r\n        {\r\n            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )\r\n            {\r\n                times[i] = 10.0 + time;\r\n            }\r\n\r\n            if( inp.loaded===true )\r\n            {\r\n                texID[i] = inp.globject;\r\n                resos[3*i+0] = 512;\r\n                resos[3*i+1] = 2;\r\n                resos[3*i+2] = 1;\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"buffer\" )\r\n        {\r\n            if( inp.loaded===true  )\r\n            {\r\n                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];\r\n                resos[3*i+0] = buffers[inp.id].mResolution[0];\r\n                resos[3*i+1] = buffers[inp.id].mResolution[1];\r\n                resos[3*i+2] = 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );\r\n\r\n    //-----------------------------------\r\n\r\n    this.mRenderer.AttachShader(this.mProgram);\r\n\r\n    this.mRenderer.SetShaderConstant1F(  \"iTime\", time);\r\n    this.mRenderer.SetShaderConstant3F(  \"iResolution\", xres, yres, 1.0);\r\n    this.mRenderer.SetShaderConstant4FV( \"iMouse\", mouse);\r\n    this.mRenderer.SetShaderConstant1FV( \"iChannelTime\", times );              // OBSOLETE\r\n    this.mRenderer.SetShaderConstant4FV( \"iDate\", dates );\r\n    this.mRenderer.SetShaderConstant3FV( \"iChannelResolution\", resos );        // OBSOLETE\r\n    this.mRenderer.SetShaderConstant1F(  \"iSampleRate\", this.mSampleRate);\r\n    this.mRenderer.SetShaderTextureUnit( \"iChannel0\", 0 );\r\n    this.mRenderer.SetShaderTextureUnit( \"iChannel1\", 1 );\r\n    this.mRenderer.SetShaderTextureUnit( \"iChannel2\", 2 );\r\n    this.mRenderer.SetShaderTextureUnit( \"iChannel3\", 3 );\r\n    this.mRenderer.SetShaderConstant1I(  \"iFrame\", this.mFrame );\r\n    this.mRenderer.SetShaderConstant1F(  \"iTimeDelta\", dtime);\r\n    this.mRenderer.SetShaderConstant1F(  \"iFrameRate\", fps );\r\n\r\n    this.mRenderer.SetShaderConstant1F(  \"iChannel[0].time\",       times[0] );\r\n    this.mRenderer.SetShaderConstant1F(  \"iChannel[1].time\",       times[1] );\r\n    this.mRenderer.SetShaderConstant1F(  \"iChannel[2].time\",       times[2] );\r\n    this.mRenderer.SetShaderConstant1F(  \"iChannel[3].time\",       times[3] );\r\n    this.mRenderer.SetShaderConstant3F(  \"iChannel[0].resolution\", resos[0], resos[ 1], resos[ 2] );\r\n    this.mRenderer.SetShaderConstant3F(  \"iChannel[1].resolution\", resos[3], resos[ 4], resos[ 5] );\r\n    this.mRenderer.SetShaderConstant3F(  \"iChannel[2].resolution\", resos[6], resos[ 7], resos[ 8] );\r\n    this.mRenderer.SetShaderConstant3F(  \"iChannel[3].resolution\", resos[9], resos[10], resos[11] );\r\n}\r\n\r\nEffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )\r\n{\r\n    for (let i=0; i\u003cthis.mInputs.length; i++ )\r\n    {\r\n        let inp = this.mInputs[i];\r\n\r\n        if( inp===null )\r\n        {\r\n        }\r\n        else if( inp.mInfo.mType===\"texture\" )\r\n        {\r\n        }\r\n        else if( inp.mInfo.mType===\"volume\" )\r\n        {\r\n        }\r\n        else if( inp.mInfo.mType===\"keyboard\" )\r\n        {\r\n        }\r\n        else if( inp.mInfo.mType===\"cubemap\" )\r\n        {\r\n        }\r\n        else if( inp.mInfo.mType===\"webcam\" )\r\n        {\r\n            if( inp.loaded===true )\r\n            {\r\n                if( inp.mImage !== null )\r\n                {\r\n                    if( this.mTextureCallbackFun!==null )\r\n                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );\r\n                }\r\n                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )\r\n                {\r\n                    if( this.mTextureCallbackFun!==null )\r\n                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );\r\n\r\n                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);\r\n                    if( inp.mInfo.mSampler.filter === \"mipmap\" )\r\n                        this.mRenderer.CreateMipmaps(inp.globject);\r\n                }\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"video\" )\r\n        {\r\n            if( inp.video.mPaused === false )\r\n            {\r\n                if( this.mTextureCallbackFun!==null )\r\n                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );\r\n            }\r\n\r\n            if( inp.loaded===true )\r\n            { \r\n      \t        if( inp.video.mPaused === false )\r\n      \t        {\r\n      \t            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);\r\n                    if( inp.mInfo.mSampler.filter === \"mipmap\" )\r\n                        this.mRenderer.CreateMipmaps(inp.globject);\r\n                }\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"music\" || inp.mInfo.mType===\"musicstream\" )\r\n        {\r\n            if( inp.audio.mPaused === false \u0026\u0026 inp.audio.mForceMuted === false \u0026\u0026 inp.loaded===true )\r\n            {\r\n                if( wa !== null )\r\n                {\r\n                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );\r\n                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );\r\n                }\r\n\r\n                if( this.mTextureCallbackFun!==null )\r\n                {\r\n                         if( inp.mInfo.mType===\"music\")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);\r\n                    else if( inp.mInfo.mType===\"musicstream\") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);\r\n                }\r\n            }\r\n\r\n            if( inp.loaded===true )\r\n            {\r\n                if( inp.audio.mForceMuted === true )\r\n                {\r\n                    let num = inp.audio.mSound.mFreqData.length;\r\n                    for (let j=0; j\u003cnum; j++ )\r\n                    {\r\n                        let x = j / num;\r\n                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );\r\n\r\n                        if( j\u003c3 )\r\n                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);\r\n\r\n                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;\r\n                    }\r\n\r\n                  //let num = inp.audio.mSound.mFreqData.length;\r\n                    for (let j=0; j\u003cnum; j++ )\r\n                    {\r\n                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );\r\n                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;\r\n                    }\r\n\r\n                }\r\n\r\n      \t        if( inp.audio.mPaused === false )\r\n                {\r\n      \t            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);\r\n      \t            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);\r\n      \t            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);\r\n                }\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"mic\" )\r\n        {\r\n            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )\r\n            {\r\n                    let num = inp.mFreqData.length;\r\n                    for( let j=0; j\u003cnum; j++ )\r\n                    {\r\n                        let x = j / num;\r\n                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );\r\n\r\n                        if( j\u003c3 )\r\n                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);\r\n\r\n                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;\r\n                    }\r\n\r\n                    for( let j=0; j\u003cnum; j++ )\r\n                    {\r\n                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );\r\n                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;\r\n                    }\r\n            }\r\n            else\r\n            {\r\n                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );\r\n                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );\r\n            }\r\n\r\n            if( this.mTextureCallbackFun!==null )\r\n                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );\r\n\r\n            if( inp.loaded===true )\r\n            {\r\n                let waveLen = Math.min( inp.mWaveData.length, 512 );\r\n                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);\r\n                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);\r\n            }\r\n        }\r\n        else if( inp.mInfo.mType===\"buffer\" )\r\n        {\r\n            if( inp.loaded===true  )\r\n            {\r\n                let id = inp.id;\r\n                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];\r\n\r\n                // hack. in webgl2.0 we have samplers, so we don't need this crap here\r\n                let filter = this.mRenderer.FILTER.NONE;\r\n                     if (inp.mInfo.mSampler.filter === \"linear\") filter = this.mRenderer.FILTER.LINEAR;\r\n                else if (inp.mInfo.mSampler.filter === \"mipmap\") filter = this.mRenderer.FILTER.MIPMAP;\r\n                this.mRenderer.SetSamplerFilter( texID, filter, false);\r\n            }\r\n\r\n            if( this.mTextureCallbackFun!==null )\r\n            {\r\n\t\t\t\tlet id = inp.id;\r\n                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nEffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )\r\n{\r\n    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );\r\n    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );\r\n\r\n    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, \"pos\");\r\n\r\n    let vp = [0, 0, xres, yres];\r\n\r\n    this.mRenderer.SetViewport(vp);\r\n\r\n    let corA = [-1.0, -1.0, -1.0];\r\n    let corB = [ 1.0, -1.0, -1.0];\r\n    let corC = [ 1.0,  1.0, -1.0];\r\n    let corD = [-1.0,  1.0, -1.0];\r\n    let apex = [ 0.0,  0.0,  0.0];\r\n\r\n         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }\r\n    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }\r\n    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }\r\n    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }\r\n    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }\r\n    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }\r\n\r\n    let corners = [ corA[0], corA[1], corA[2], \r\n                    corB[0], corB[1], corB[2], \r\n                    corC[0], corC[1], corC[2], \r\n                    corD[0], corD[1], corD[2],\r\n                    apex[0], apex[1], apex[2]];\r\n\r\n    this.mRenderer.SetShaderConstant3FV(\"unCorners\", corners);\r\n    this.mRenderer.SetShaderConstant4FV(\"unViewport\", vp);\r\n\r\n    this.mRenderer.DrawUnitQuad_XY(l1);\r\n\r\n    this.mRenderer.DettachTextures();\r\n}\r\n\r\nEffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )\r\n{\r\n    if( this.mType===\"sound\" )\r\n    {\r\n        if (this.mSoundShaderCompiled === true)\r\n        {\r\n            // make sure all textures are loaded\r\n            for (let i=0; i\u003cthis.mInputs.length; i++ )\r\n            {\r\n                let inp = this.mInputs[i];\r\n                if (inp === null) continue;\r\n\r\n                if (inp.mInfo.mType === \"texture\" \u0026\u0026 !inp.loaded) return;\r\n                if (inp.mInfo.mType === \"cubemap\" \u0026\u0026 !inp.loaded) return;\r\n            }\r\n\r\n            this.Paint_Sound(wa, da);\r\n            this.mSoundShaderCompiled = false;\r\n        }\r\n        if (this.mFrame === 0)\r\n        {\r\n            if (this.mPlaying===true)\r\n            {\r\n                this.mPlayNode.disconnect();\r\n                this.mPlayNode.stop();\r\n                this.mPlayNode = null;\r\n            }\r\n            this.mPlaying = true;\r\n\r\n            this.mPlayNode = wa.createBufferSource();\r\n            this.mPlayNode.buffer = this.mBuffer;\r\n            this.mPlayNode.connect(this.mGainNode);\r\n            this.mPlayNode.start(0);\r\n        }\r\n        this.mFrame++;\r\n    }\r\n    else if( this.mType===\"image\" )\r\n    {\r\n        this.mRenderer.SetRenderTarget( null );\r\n        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );\r\n        this.mFrame++;\r\n    }\r\n    else if( this.mType===\"common\" )\r\n    {\r\n    }\r\n    else if( this.mType===\"buffer\" )\r\n    {\r\n        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );\r\n\r\n        let buffer = buffers[bufferID];\r\n\r\n        let dstID = 1 - buffer.mLastRenderDone;\r\n\r\n        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );\r\n        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );\r\n\r\n        // compute mipmaps if needd\r\n        if( bufferNeedsMimaps )\r\n        {\r\n            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);\r\n        }\r\n\r\n        // make thumbnail\r\n        //if( this.mTextureCallbackFun != null )\r\n        /*\r\n        {\r\n            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );\r\n            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];\r\n            this.mRenderer.SetBlend(false);\r\n            this.mRenderer.SetViewport(v);\r\n            this.mRenderer.AttachShader(this.mProgramCopy);\r\n            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, \"pos\");\r\n            this.mRenderer.SetShaderConstant4FV(\"v\", v);\r\n            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);\r\n            this.mRenderer.DrawUnitQuad_XY(l1);\r\n            this.mRenderer.DettachTextures();\r\n            this.mRenderer.DetachShader();\r\n            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );\r\n            this.mRenderer.SetRenderTarget(null);\r\n        }\r\n        */\r\n        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;\r\n        this.mFrame++;\r\n    }\r\n    else if( this.mType===\"cubemap\" )\r\n    {\r\n        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );\r\n\r\n        let buffer = cubeBuffers[bufferID];\r\n\r\n        xres = buffer.mResolution[0];\r\n        yres = buffer.mResolution[1];\r\n        let dstID = 1 - buffer.mLastRenderDone;\r\n        for( let face=0; face\u003c6; face++ )\r\n        {\r\n            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );\r\n            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );\r\n        }\r\n        this.mRenderer.SetRenderTargetCubeMap( null, 0 );\r\n\r\n        // compute mipmaps if needd\r\n        if( bufferNeedsMimaps )\r\n        {\r\n            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);\r\n        }\r\n        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;\r\n\r\n        this.mFrame++;\r\n    }\r\n}\r\n\r\nEffectPass.prototype.StopOutput_Sound = function( wa )\r\n{\r\n    if( this.mPlayNode===null ) return;\r\n    this.mPlayNode.disconnect();\r\n}\r\n\r\nEffectPass.prototype.ResumeOutput_Sound = function( wa )\r\n{\r\n    if( this.mPlayNode===null ) return;\r\n\r\n    wa.resume()\r\n    this.mPlayNode.connect( this.mGainNode );\r\n}\r\n\r\nEffectPass.prototype.StopOutput_Image = function( wa )\r\n{\r\n}\r\n\r\nEffectPass.prototype.ResumeOutput_Image = function( wa )\r\n{\r\n}\r\n\r\nEffectPass.prototype.StopOutput = function( wa )\r\n{\r\n    for (let j=0; j\u003cthis.mInputs.length; j++ )\r\n        this.StopInput(j);\r\n\r\n    if( this.mType===\"sound\" )\r\n         this.StopOutput_Sound( wa );\r\n    else\r\n         this.StopOutput_Image( wa );\r\n}\r\n\r\nEffectPass.prototype.ResumeOutput = function( wa )\r\n{\r\n    for (let j=0; j\u003cthis.mInputs.length; j++ )\r\n        this.ResumeInput(j);\r\n\r\n    if( this.mType===\"sound\" )\r\n         this.ResumeOutput_Sound( wa );\r\n    else\r\n         this.ResumeOutput_Image( wa );\r\n}\r\n\r\nEffectPass.prototype.GetCompilationTime = function()\r\n{\r\n    return this.mCompilationTime;\r\n}\r\n\r\n//============================================================================================================\r\nfunction Screenshots()\r\n{\r\n    // private\r\n    let mTexture = null;\r\n    let mTarget = null;\r\n    let mXres = 0;\r\n    let mYres = 0;\r\n    let mCubemapToEquirectProgram;\r\n    let mRenderer = null;\r\n\r\n    // public\r\n    var me = {};\r\n\r\n    me.Initialize = function(renderer)\r\n    {\r\n        mRenderer = renderer;\r\n        let caps = mRenderer.GetCaps();\r\n        let is20 = caps.mIsGL20;\r\n\r\n        let vsSourceC, fsSourceC;\r\n        if( is20 )\r\n        {\r\n            vsSourceC = \"layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n            fsSourceC = \"uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }\";\r\n        }\r\n        else\r\n        {\r\n            vsSourceC = \"attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n            fsSourceC = \"uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }\";\r\n        }\r\n\r\n        let compileShader = function (worked, info)\r\n        {\r\n            if (worked === false)\r\n            {\r\n                console.log(\"Failed to compile cubemap resample shader (\" + errorType + \"): \" + log);\r\n            }\r\n            else\r\n            {\r\n                mCubemapToEquirectProgram = info;\r\n            }\r\n        }\r\n        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);\r\n\r\n        return true;\r\n    };\r\n\r\n    me.Allocate = function( xres, yres )\r\n    {\r\n        if( xres\u003emXres || yres\u003emYres )\r\n        {\r\n            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);\r\n            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);\r\n\r\n            if( mXres!==0 )\r\n            {\r\n                mRenderer.DestroyTexture(mTexture);\r\n                mRenderer.DestroyRenderTarget(mTarget);\r\n            }\r\n\r\n            mTexture = texture;\r\n            mTarget = target;\r\n            mXres = xres;\r\n            mYres = yres;\r\n        }\r\n    };\r\n\r\n    me.GetProgram = function()\r\n    {\r\n        return mCubemapToEquirectProgram;\r\n    };\r\n    me.GetTarget = function()\r\n    {\r\n        return mTarget;\r\n    };\r\n\r\n    return me;\r\n};\r\n\r\n//============================================================================================================\r\n\r\nfunction Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )\r\n{\r\n    let xres = canvas.width;\r\n    let yres = canvas.height;\r\n\r\n    let me = this;\r\n    this.mCanvas = canvas;\r\n    this.mCreated = false;\r\n    this.mRenderer = null;\r\n    this.mAudioContext = ac;\r\n    this.mGLContext = null;\r\n    this.mWebVR = vr;\r\n    this.mRenderingStereo = false;\r\n    this.mXres = xres;\r\n    this.mYres = yres;\r\n    this.mForceMuted = forceMuted;\r\n    if( ac===null ) this.mForceMuted = true;\r\n    this.mForcePaused = forcePaused;\r\n    this.mGainNode = null;\r\n    this.mPasses = [];\r\n    this.mFrame = 0;\r\n    this.mTextureCallbackFun = callback;\r\n    this.mTextureCallbackObj = obj;\r\n    this.mMaxBuffers = 4;\r\n    this.mMaxCubeBuffers = 1;\r\n    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)\r\n    this.mBuffers = [];\r\n    this.mCubeBuffers = [];\r\n    this.mScreenshotSytem = null;\r\n    this.mCompilationTime = 0;\r\n    this.mIsLowEnd = piIsMobile();\r\n\r\n    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots\r\n    if (this.mGLContext === null)\r\n    {\r\n        return;\r\n    }\r\n\r\n    canvas.addEventListener(\"webglcontextlost\", function (event)\r\n        {\r\n            event.preventDefault();\r\n            crashCallback();\r\n        }, false);\r\n\r\n    this.mRenderer = piRenderer();\r\n    if (!this.mRenderer.Initialize(this.mGLContext))\r\n        return;\r\n\r\n    this.mScreenshotSytem = Screenshots();\r\n    if (!this.mScreenshotSytem.Initialize(this.mRenderer))\r\n        return;\r\n\r\n    var caps = this.mRenderer.GetCaps();\r\n    this.mIs20 = caps.mIsGL20;\r\n    this.mShaderTextureLOD = caps.mShaderTextureLOD;\r\n    //-------------\r\n    if( ac!==null )\r\n    {   \r\n        this.mGainNode = ac.createGain();\r\n        if( !forceMuted )\r\n        {\r\n            this.mGainNode.connect( ac.destination);\r\n        }\r\n        if (this.mForceMuted )\r\n            this.mGainNode.gain.value = 0.0;\r\n        else\r\n            this.mGainNode.gain.value = 1.0;\r\n    }\r\n\r\n    //-------------\r\n    let vsSourceC, fsSourceC;\r\n    if( this.mIs20 )\r\n    {\r\n        vsSourceC = \"layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n        fsSourceC = \"uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }\";\r\n    }\r\n    else\r\n    {\r\n        vsSourceC = \"attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n        fsSourceC = \"uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }\";\r\n    }\r\n\r\n    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)\r\n        {\r\n            if (worked === false) console.log(\"Failed to compile shader to copy buffers : \" + info.mErrorStr);\r\n            else me.mProgramCopy = info;\r\n        });\r\n\r\n    let vsSourceD, fsSourceD;\r\n    if( this.mIs20 )\r\n    {\r\n        vsSourceD = \"layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n        fsSourceD = \"uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }\";\r\n    }\r\n    else\r\n    {\r\n        vsSourceD = \"attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }\";\r\n        fsSourceD = \"uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }\";\r\n    }\r\n\r\n    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)\r\n        {\r\n            if (worked === false) console.log(\"Failed to compile shader to downscale buffers : \" + info.mErrorStr);\r\n            else me.mProgramDownscale = info;\r\n        });\r\n\r\n\r\n    // set all buffers and cubemaps to null\r\n    for( let i=0; i\u003cthis.mMaxBuffers; i++ )\r\n    {\r\n        this.mBuffers[i] = { mTexture: [null, null], \r\n                             mTarget:  [null, null], \r\n                             mResolution: [0, 0],\r\n                             mLastRenderDone: 0,\r\n                             mThumbnailRenderTarget: null,\r\n                             mThumbnailTexture: null,\r\n                             mThumbnailBuffer:  null,\r\n                             mThumbnailRes: [0, 0] };\r\n    }\r\n\r\n    for( let i=0; i\u003cthis.mMaxCubeBuffers; i++ )\r\n    {\r\n        this.mCubeBuffers[i] = { mTexture: [null, null], \r\n                                mTarget:  [null, null], \r\n                                mResolution: [0, 0],\r\n                                mLastRenderDone: 0,\r\n                                mThumbnailRenderTarget: null,\r\n                                mThumbnailTexture: null,\r\n                                mThumbnailBuffer:  null,\r\n                                mThumbnailRes: [0, 0] };\r\n    }\r\n\r\n    //-------\r\n\r\n    let keyboardData = new Uint8Array( 256*3 );\r\n    for (let j=0; j\u003c(256*3); j++ ) { keyboardData[j] = 0; }\r\n    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);\r\n    let keyboardImage = new Image();\r\n    if( callback!==null )\r\n        keyboardImage.src = \"/img/keyboard.png\"; // don't load PNG if no UI \r\n    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };\r\n\r\n    let iResize = function( xres, yres )\r\n    {\r\n        me.mCanvas.width = xres;\r\n        me.mCanvas.height = yres;\r\n        me.mXres = xres;\r\n        me.mYres = yres;\r\n        me.ResizeBuffers(xres, yres);\r\n        resizeCallback(xres, yres);\r\n    };\r\n\r\n    let bestAttemptFallback = function()\r\n    {\r\n        let devicePixelRatio = window.devicePixelRatio || 1;\r\n        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;\r\n        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;\r\n        iResize(xres, yres);\r\n    };\r\n\r\n    if(!window.ResizeObserver)\r\n    {\r\n        console.log(\"WARNING: This browser doesn't support ResizeObserver.\");\r\n        bestAttemptFallback();\r\n        window.addEventListener(\"resize\", bestAttemptFallback);\r\n    }\r\n    else\r\n    {\r\n        this.mRO = new ResizeObserver( function(entries, observer)\r\n        {\r\n            var entry = entries[0];\r\n            if (!entry['devicePixelContentBoxSize'])\r\n            {\r\n                observer.unobserve(me.mCanvas);\r\n                console.log(\"WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)\");\r\n                bestAttemptFallback();\r\n                window.addEventListener(\"resize\", bestAttemptFallback);\r\n            }\r\n            else\r\n            {\r\n                let box = entry.devicePixelContentBoxSize[0];\r\n                let xres = box.inlineSize;\r\n                let yres = box.blockSize;\r\n                iResize(xres, yres);\r\n            }\r\n        });\r\n        try\r\n        {\r\n            this.mRO.observe(this.mCanvas, { box: [\"device-pixel-content-box\"] });\r\n            //this.mRO.observe(this.mCanvas);\r\n        }\r\n        catch (e)\r\n        {\r\n            console.log(\"WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)\");\r\n            bestAttemptFallback();\r\n            window.addEventListener(\"resize\", bestAttemptFallback);\r\n        }\r\n    }\r\n\r\n    this.mCreated = true;\r\n}\r\n\r\nEffect.prototype.ResizeCubemapBuffer = function(i, xres, yres )\r\n{\r\n    let oldXres = this.mCubeBuffers[i].mResolution[0];\r\n    let oldYres = this.mCubeBuffers[i].mResolution[1];\r\n\r\n    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )\r\n    {\r\n        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,\r\n            xres, yres,\r\n            this.mRenderer.TEXFMT.C4F16,\r\n            this.mRenderer.FILTER.LINEAR,\r\n            this.mRenderer.TEXWRP.CLAMP, \r\n            null);\r\n        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);\r\n\r\n        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,\r\n            xres, yres,\r\n            this.mRenderer.TEXFMT.C4F16,\r\n            this.mRenderer.FILTER.LINEAR,\r\n            this.mRenderer.TEXWRP.CLAMP, \r\n            null);\r\n\r\n        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);\r\n\r\n        // Store new buffers\r\n        this.mCubeBuffers[i].mTexture = [texture1,texture2], \r\n        this.mCubeBuffers[i].mTarget =  [target1, target2 ], \r\n        this.mCubeBuffers[i].mLastRenderDone = 0;\r\n        this.mCubeBuffers[i].mResolution[0] = xres;\r\n        this.mCubeBuffers[i].mResolution[1] = yres;\r\n    }\r\n}\r\n\r\nEffect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )\r\n{\r\n    if( skipIfNotExists \u0026\u0026 this.mBuffers[i].mTexture[0]===null ) return;\r\n\r\n    let oldXres = this.mBuffers[i].mResolution[0];\r\n    let oldYres = this.mBuffers[i].mResolution[1];\r\n\r\n    if( oldXres !== xres || oldYres !== yres )\r\n    {\r\n        let needCopy = (this.mBuffers[i].mTexture[0]!==null);\r\n\r\n        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,\r\n            xres, yres,\r\n            this.mRenderer.TEXFMT.C4F32,\r\n            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,\r\n            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, \r\n            null);\r\n\r\n        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,\r\n            xres, yres,\r\n            this.mRenderer.TEXFMT.C4F32,\r\n            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,\r\n            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, \r\n            null);\r\n\r\n        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);\r\n        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);\r\n\r\n        if( needCopy )\r\n        {\r\n            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];\r\n            this.mRenderer.SetBlend(false);\r\n            this.mRenderer.SetViewport(v);\r\n            this.mRenderer.AttachShader(this.mProgramCopy);\r\n            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, \"pos\");\r\n            let vOld = [0, 0, oldXres, oldYres];\r\n            this.mRenderer.SetShaderConstant4FV(\"v\", vOld);\r\n\r\n            // Copy old buffers 1 to new buffer\r\n            this.mRenderer.SetRenderTarget(target1);\r\n            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);\r\n            this.mRenderer.DrawUnitQuad_XY(l1);\r\n\r\n            // Copy old buffers 2 to new buffer\r\n            this.mRenderer.SetRenderTarget(target2);\r\n            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);\r\n            this.mRenderer.DrawUnitQuad_XY(l1);\r\n\r\n            // Deallocate old memory\r\n            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);\r\n            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);\r\n            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);\r\n            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);\r\n            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);\r\n        }\r\n\r\n        // Store new buffers\r\n        this.mBuffers[i].mTexture = [texture1,texture2], \r\n        this.mBuffers[i].mTarget =  [target1, target2 ], \r\n        this.mBuffers[i].mLastRenderDone = 0;\r\n        this.mBuffers[i].mResolution[0] = xres;\r\n        this.mBuffers[i].mResolution[1] = yres;\r\n    }\r\n}\r\n\r\nEffect.prototype.saveScreenshot = function(passid)\r\n{\r\n    let pass = this.mPasses[passid];\r\n\r\n    if( pass.mType === \"buffer\" )\r\n    {\r\n        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );\r\n\r\n        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];\r\n\r\n        let numComponents = 3;\r\n        let width = texture.mTex0.mXres;\r\n        let height = texture.mTex0.mYres;\r\n        let type = \"Float\"; // Other options Float, Half, Uint\r\n        let bytes = new Float32Array(width * height * 4 );//numComponents);\r\n        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );\r\n        let blob = piExportToEXR(width, height, numComponents, type, bytes);\r\n\r\n        // Offer download automatically to the user\r\n        piTriggerDownload(\"image.exr\", blob);\r\n    }\r\n    else if( pass.mType === \"cubemap\" )\r\n    {\r\n        let xres = 4096;\r\n        let yres = 2048;\r\n        this.mScreenshotSytem.Allocate( xres, yres );\r\n\r\n        let cubeBuffer = this.mCubeBuffers[0];\r\n\r\n        let target = this.mScreenshotSytem.GetTarget();\r\n        this.mRenderer.SetRenderTarget( target );\r\n\r\n        let program = this.mScreenshotSytem.GetProgram();\r\n\r\n        this.mRenderer.AttachShader(program);\r\n        let l1 = this.mRenderer.GetAttribLocation(program, \"pos\");\r\n        this.mRenderer.SetViewport( [0, 0, xres, yres] );\r\n        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);\r\n        this.mRenderer.DrawUnitQuad_XY(l1);\r\n        this.mRenderer.DettachTextures();\r\n        this.mRenderer.SetRenderTarget( null );\r\n\r\n        let data = new Float32Array(xres*yres*4);\r\n        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );\r\n\r\n        let blob = piExportToEXR(xres, yres, 3, \"Float\", data );\r\n        piTriggerDownload(\"image.exr\", blob);\r\n    }\r\n    else if( pass.mType === \"sound\" )\r\n    {\r\n        let offset = 0;\r\n        const bits = 16;\r\n        const numChannels = 2;\r\n        let words = new Int16Array(60*pass.mSampleRate*numChannels );\r\n\r\n        pass.iRenderSound( new Date(), function(off, data, numSamples)\r\n                                         {\r\n                                            for( let i=0; i\u003cnumSamples; i++ )\r\n                                            {\r\n                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;\r\n                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;\r\n                                            }\r\n                                         }\r\n                                     );\r\n\r\n        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);\r\n\r\n        piTriggerDownload(\"sound.wav\", blob);\r\n    }    \r\n}\r\n\r\nEffect.prototype.ResizeBuffers = function(xres, yres)\r\n{\r\n    for (let i=0; i\u003cthis.mMaxBuffers; i++ )\r\n    {\r\n        this.ResizeBuffer(i, xres, yres, true);\r\n    }\r\n}\r\n\r\nEffect.prototype.IsEnabledVR = function ()\r\n{\r\n    if (this.mRenderingStereo) return true;\r\n    return false;\r\n}\r\n\r\nEffect.prototype.EnableVR = function()\r\n{\r\n    if( !this.mWebVR.IsSupported() ) return;\r\n    if( this.mRenderingStereo ) return;\r\n\r\n    this.mRenderingStereo = true;\r\n    this.mWebVR.Enable();\r\n}\r\n\r\nEffect.prototype.DisableVR = function()\r\n{\r\n    if( !this.mWebVR.IsSupported() ) return;\r\n    if( !this.mRenderingStereo ) return;\r\n\r\n    this.mRenderingStereo = false;\r\n    this.mWebVR.Disable();\r\n}\r\n\r\nEffect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }\r\nEffect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }\r\nEffect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }\r\nEffect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }\r\nEffect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }\r\nEffect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }\r\nEffect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }\r\nEffect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }\r\nEffect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }\r\nEffect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }\r\nEffect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }\r\nEffect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }\r\nEffect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }\r\nEffect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }\r\nEffect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }\r\n\r\nEffect.prototype.GetHeaderSize = function (passid)\r\n{\r\n    return this.mPasses[passid].mHeaderLength + \r\n           this.mRenderer.GetShaderHeaderLines(1);\r\n}\r\n\r\nEffect.prototype.ToggleVolume = function()\r\n{\r\n    this.mForceMuted = !this.mForceMuted;\r\n\r\n    // outp\r\n    if (this.mForceMuted)\r\n        this.mGainNode.gain.value = 0.0;\r\n    else\r\n        this.mGainNode.gain.value = 1.0;\r\n\r\n    // inp\r\n    let num = this.mPasses.length;\r\n    for( let j=0; j\u003cnum; j++ )\r\n    {\r\n        for( let i=0; i\u003cthis.mPasses[j].mInputs.length; i++ )\r\n        {\r\n            if( this.mForceMuted )\r\n                this.mPasses[j].MuteInput( this.mAudioContext, i );\r\n            else\r\n                this.mPasses[j].UnMuteInput( this.mAudioContext, i );\r\n        }\r\n    }\r\n\r\n    return this.mForceMuted;\r\n}\r\n\r\nEffect.prototype.SetKeyDown = function( passid, k )\r\n{\r\n    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;\r\n\r\n    this.mKeyboard.mData[ k + 0*256 ] = 255;\r\n    this.mKeyboard.mData[ k + 1*256 ] = 255;\r\n    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];\r\n    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );\r\n\r\n    let num = this.mPasses.length;\r\n    for (let j=0; j\u003cnum; j++ )\r\n    {\r\n        for (let i=0; i\u003cthis.mPasses[j].mInputs.length; i++ )\r\n        {\r\n            let inp = this.mPasses[j].mInputs[i];\r\n            if( inp!==null \u0026\u0026 inp.mInfo.mType===\"keyboard\" )\r\n            {\r\n                if( this.mTextureCallbackFun!==null )\r\n                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nEffect.prototype.SetKeyUp = function( passid, k )\r\n{\r\n    this.mKeyboard.mData[ k + 0*256 ] = 0;\r\n    this.mKeyboard.mData[ k + 1*256 ] = 0;\r\n    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );\r\n\r\n    let num = this.mPasses.length;\r\n    for (let j=0; j\u003cnum; j++ )\r\n    {\r\n        for (let i=0; i\u003cthis.mPasses[j].mInputs.length; i++ )\r\n        {\r\n            let inp = this.mPasses[j].mInputs[i];\r\n            if( inp!==null \u0026\u0026 inp.mInfo.mType===\"keyboard\" )\r\n            {\r\n                if( this.mTextureCallbackFun!==null )\r\n                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nEffect.prototype.StopOutputs = function()\r\n{\r\n    let wa = this.mAudioContext;\r\n\r\n    let num = this.mPasses.length;\r\n    for (let i=0; i\u003cnum; i++ )\r\n    {\r\n        this.mPasses[i].StopOutput( wa );\r\n    }\r\n}\r\n\r\nEffect.prototype.ResumeOutputs = function()\r\n{\r\n    let wa = this.mAudioContext;\r\n\r\n    let num = this.mPasses.length;\r\n    for (let i=0; i\u003cnum; i++ )\r\n    {\r\n        this.mPasses[i].ResumeOutput( wa );\r\n    }\r\n}\r\n\r\nEffect.prototype.PauseInput = function( passid, id )\r\n{\r\n    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );\r\n}\r\n\r\nEffect.prototype.ToggleMuteInput = function( passid, id )\r\n{\r\n    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );\r\n}\r\n\r\nEffect.prototype.RewindInput = function( passid, id )\r\n{\r\n    this.mPasses[passid].RewindInput( this.mAudioContext, id );\r\n}\r\n\r\nEffect.prototype.UpdateInputs = function( passid, forceUpdate )\r\n{\r\n   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );\r\n}\r\n\r\nEffect.prototype.ResetTime = function()\r\n{\r\n    this.mFrame = 0;\r\n    this.mAudioContext.resume()\r\n\r\n    let num = this.mPasses.length;\r\n    for( let i=0; i\u003cnum; i++ )\r\n    {\r\n        this.mPasses[i].mFrame = 0;\r\n        for( let j=0; j\u003cthis.mPasses[i].mInputs.length; j++ )\r\n            this.mPasses[i].RewindInput(this.mAudioContext, j)\r\n    }\r\n}\r\n\r\nEffect.prototype.RequestAnimationFrame = function (id)\r\n{\r\n    if (this.mRenderingStereo \u0026\u0026 this.mWebVR.IsPresenting())\r\n    {\r\n        this.mWebVR.RequestAnimationFrame(id);\r\n    }\r\n    else\r\n    {\r\n        requestAnimFrame(id);\r\n    }\r\n}\r\n\r\nEffect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)\r\n{\r\n    let wa = this.mAudioContext;\r\n    let da = new Date();\r\n    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();\r\n    let xres = this.mXres / 1;\r\n    let yres = this.mYres / 1;\r\n\r\n    if( this.mFrame===0 )\r\n    {\r\n        for( let i=0; i\u003cthis.mMaxBuffers; i++ )\r\n        {\r\n            if( this.mBuffers[i].mTexture[0]!==null )\r\n            {\r\n                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );\r\n                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );\r\n                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );\r\n                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );\r\n\t\t\t\t\r\n\t\t\t\tthis.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );\r\n\t\t\t\tthis.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );\r\n            }\r\n        }\r\n        for( let i=0; i\u003cthis.mMaxCubeBuffers; i++ )\r\n        {\r\n            if( this.mCubeBuffers[i].mTexture[0]!==null )\r\n            {\r\n                for( let face=0; face\u003c6; face++ )\r\n                {\r\n                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );\r\n                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );\r\n                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );\r\n                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );\r\n\t\t\t\t\tthis.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );\r\n\t\t\t\t    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    let num = this.mPasses.length;\r\n\r\n    // render sound first\r\n    for( let i=0; i\u003cnum; i++ )\r\n    {\r\n        if( this.mPasses[i].mType !== \"sound\" ) continue;\r\n        if( this.mPasses[i].mProgram===null ) continue;\r\n        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );\r\n    }\r\n\r\n    // render buffers second\r\n    for( let i=0; i\u003cnum; i++ )\r\n    {\r\n        if( this.mPasses[i].mType !== \"buffer\" ) continue;\r\n        if( this.mPasses[i].mProgram===null ) continue;\r\n        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );\r\n\r\n        // check if any downstream pass needs mipmaps when reading from this buffer\r\n        let needMipMaps = false;\r\n        for (let j=0; j\u003cnum; j++ )\r\n        {\r\n            for (let k=0; k\u003cthis.mPasses[j].mInputs.length; k++ )\r\n            {\r\n                let inp = this.mPasses[j].mInputs[k];\r\n                if( inp!==null \u0026\u0026 inp.mInfo.mType===\"buffer\" \u0026\u0026 inp.id === bufferID \u0026\u0026 inp.mInfo.mSampler.filter === \"mipmap\")\r\n                {\r\n                    needMipMaps = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );\r\n    }\r\n\r\n    // render cubemap buffers second\r\n    for( let i=0; i\u003cnum; i++ )\r\n    {\r\n        if( this.mPasses[i].mType !== \"cubemap\" ) continue;\r\n        if( this.mPasses[i].mProgram===null ) continue;\r\n        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );\r\n\r\n        // check if any downstream pass needs mipmaps when reading from this buffer\r\n        let needMipMaps = false;\r\n\r\n        for (let j=0; j\u003cnum; j++ )\r\n        {\r\n            for (let k=0; k\u003cthis.mPasses[j].mInputs.length; k++ )\r\n            {\r\n                let inp = this.mPasses[j].mInputs[k];\r\n                if( inp!==null \u0026\u0026 inp.mInfo.mType===\"cubemap\" )\r\n                {\r\n                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 \u0026\u0026 inp.mInfo.mSampler.filter === \"mipmap\" )\r\n                    {\r\n                        needMipMaps = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );\r\n    }\r\n\r\n    // render image last\r\n    for( let i=0; i\u003cnum; i++ )\r\n    {\r\n        if( this.mPasses[i].mType !== \"image\" ) continue;\r\n        if( this.mPasses[i].mProgram===null ) continue;\r\n        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );\r\n    }   \r\n\r\n    // erase keypresses\r\n    for (let k=0; k\u003c256; k++ )\r\n    {\r\n       this.mKeyboard.mData[ k + 1*256 ] = 0;\r\n    }\r\n    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );\r\n\r\n    if( this.mRenderingStereo ) this.mWebVR.Finish();\r\n\r\n    this.mFrame++;\r\n}\r\n\r\nEffect.prototype.NewShader = function( passid, preventCache, onResolve )\r\n{\r\n    let commonSourceCodes = [];\r\n    for (let i=0; i\u003cthis.mPasses.length; i++ )\r\n    {\r\n        if( this.mPasses[i].mType===\"common\")\r\n        {\r\n            commonSourceCodes.push(this.mPasses[i].mSource);\r\n        }\r\n    }\r\n\r\n    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );\r\n}\r\n\r\nEffect.prototype.GetNumPasses = function()\r\n{\r\n    return this.mPasses.length;\r\n}\r\n\r\nEffect.prototype.GetNumOfType = function(passtype)\r\n{\r\n    let id = 0;\r\n    for (let j=0; j\u003cthis.mPasses.length; j++ )\r\n    {\r\n        if( this.mPasses[j].mType===passtype )\r\n        {\r\n            id++;\r\n        }\r\n    }\r\n    return id;\r\n}\r\n\r\nEffect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }\r\nEffect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }\r\nEffect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }\r\nEffect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }\r\nEffect.prototype.GetError = function (id) { return this.mPasses[id].mError; }\r\nEffect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }\r\nEffect.prototype.GetErrorGlobal = function()\r\n{\r\n    for (let i = 0; i \u003c this.mPasses.length; i++)\r\n    {\r\n        if (this.mPasses[i].mError)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nEffect.prototype.Load = function (jobj )\r\n{\r\n    if (jobj.ver !== \"0.1\")\r\n    {\r\n        console.log(\"Wrong Format\");\r\n        return false;\r\n    }\r\n\r\n    let numPasses = jobj.renderpass.length;\r\n\r\n    if( numPasses\u003c1 || numPasses\u003ethis.mMaxPasses )\r\n    {\r\n        console.log(\"Corrupted Shader - \" + numPasses);\r\n        return false;\r\n    }\r\n\r\n    this.mPasses = [];\r\n    for (let j = 0; j \u003c numPasses; j++)\r\n    {\r\n        let rpass = jobj.renderpass[j];\r\n\r\n        // skip sound passes if in thumbnail mode\r\n        if( this.mForceMuted \u0026\u0026 rpass.type === \"sound\" ) continue;\r\n\r\n        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,\r\n                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,\r\n                                   this.mProgramDownscale, j, this);\r\n\r\n        wpass.Create(rpass.type, this.mAudioContext);\r\n\r\n        let numInputs = rpass.inputs.length;\r\n\r\n        for (let i = 0; i \u003c 4; i++)\r\n        {\r\n            wpass.NewTexture(this.mAudioContext, i, null, null, null);\r\n        }\r\n        for (let i = 0; i \u003c numInputs; i++)\r\n        {\r\n            let lid  = rpass.inputs[i].channel;\r\n            let styp = rpass.inputs[i].type;\r\n            let sid  = rpass.inputs[i].id;\r\n            let ssrc = rpass.inputs[i].filepath;\r\n            let psrc = rpass.inputs[i].previewfilepath;\r\n            let samp = rpass.inputs[i].sampler;\r\n\r\n            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);\r\n        }\r\n\r\n        for (let i = 0; i \u003c 4; i++)\r\n        {\r\n            wpass.SetOutputs(i, null);\r\n        }\r\n\r\n        let numOutputs = rpass.outputs.length;\r\n        for (let i = 0; i \u003c numOutputs; i++)\r\n        {\r\n            let outputID = rpass.outputs[i].id;\r\n            let outputCH = rpass.outputs[i].channel;\r\n            wpass.SetOutputs(outputCH, outputID);\r\n        }\r\n\r\n        // create some hardcoded names. This should come from the DB\r\n        let rpassName = \"\";\r\n        if (rpass.type === \"common\" ) rpassName = \"Common\";\r\n        if (rpass.type === \"sound\"  ) rpassName = \"Sound\";\r\n        if (rpass.type === \"image\"  ) rpassName = \"Image\";\r\n        if (rpass.type === \"buffer\") rpassName = \"Buffer \" + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));\r\n        if (rpass.type === \"cubemap\") rpassName = \"Cube A\";// \" + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));\r\n        wpass.SetName(rpassName);\r\n        wpass.SetCode(rpass.code);\r\n\r\n        this.mPasses.push(wpass);\r\n    }\r\n    return true;\r\n}\r\n\r\nEffect.prototype.CompileSome = function ( passes, preventCache, onResolve )\r\n{\r\n    let me = this;\r\n\r\n    let to = getRealTime();\r\n    let allPromisses = [];\r\n    for (let j = 0; j \u003c passes.length; j++)\r\n    {\r\n        allPromisses.push(new Promise(function (resolve, reject)\r\n        {\r\n            me.NewShader(passes[j], preventCache, function () { resolve(1); });\r\n        }));\r\n    }\r\n\r\n    // aggregated callback when all passes have been compiled\r\n    Promise.all(allPromisses).then(function (values)\r\n    {\r\n        let totalError = false;\r\n        for (let j = 0; j \u003c me.mPasses.length; j++)\r\n        {\r\n            if (me.mPasses[j].mError)\r\n            {\r\n                totalError = true;\r\n                break;\r\n            }\r\n        }\r\n        me.mCompilationTime = getRealTime() - to;\r\n        onResolve(!totalError);\r\n    }).catch(console.log);\r\n}\r\n\r\nEffect.prototype.Compile = function (preventCache, onResolve )\r\n{\r\n    let me = this;\r\n\r\n    let to = getRealTime();\r\n    let allPromisses = [];\r\n    let numPasses = this.mPasses.length;\r\n    for (let j = 0; j \u003c numPasses; j++)\r\n    {\r\n        allPromisses.push(new Promise(function (resolve, reject)\r\n        {\r\n            me.NewShader(j, preventCache, function () { resolve(1); });\r\n        }));\r\n    }\r\n\r\n    // aggregated callback when all passes have been compiled\r\n    Promise.all(allPromisses).then(function (values)\r\n    {\r\n        let totalError = false;\r\n        for (let j = 0; j \u003c numPasses; j++)\r\n        {\r\n            if (me.mPasses[j].mError)\r\n            {\r\n                totalError = true;\r\n                break;\r\n            }\r\n        }\r\n        me.mCompilationTime = getRealTime() - to;\r\n        onResolve(!totalError);\r\n    }).catch(console.log);\r\n}\r\n\r\nEffect.prototype.GetCompilationTime = function( id )\r\n{\r\n    return this.mPasses[id].GetCompilationTime()/1000.0;\r\n}\r\nEffect.prototype.GetTotalCompilationTime = function()\r\n{\r\n    return this.mCompilationTime/1000.0;\r\n}\r\n\r\nEffect.prototype.DestroyPass = function( id )\r\n{\r\n   this.mPasses[id].Destroy( this.mAudioContext );\r\n   this.mPasses.splice(id, 1);\r\n}\r\n\r\nEffect.prototype.AddPass = function( passType, passName, onResolve )\r\n{\r\n    let shaderStr = null;\r\n\r\n    if( passType===\"sound\"   ) shaderStr = \"vec2 mainSound( int samp, float time )\\n{\\n    // A 440 Hz wave that attenuates quickly overt time\\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\\n}\";\r\n    if( passType===\"buffer\"  ) shaderStr = \"void mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n    fragColor = vec4(0.0,0.0,1.0,1.0);\\n}\";\r\n    if( passType===\"common\"  ) shaderStr = \"vec4 someFunction( vec4 a, float b )\\n{\\n    return a+b;\\n}\";\r\n    if( passType===\"cubemap\" ) shaderStr = \"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\\n{\\n    // Ray direction as color\\n    vec3 col = 0.5 + 0.5*rayDir;\\n\\n    // Output to cubemap\\n    fragColor = vec4(col,1.0);\\n}\";\r\n\r\n    let id = this.GetNumPasses();\r\n    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,\r\n                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, \r\n                                       this.mProgramDownscale, id, this );\r\n\r\n    this.mPasses[id].Create( passType, this.mAudioContext );\r\n    this.mPasses[id].SetName( passName );\r\n    this.mPasses[id].SetCode( shaderStr );\r\n    this.NewShader(id, false, function ()\r\n    {\r\n        onResolve();\r\n    });\r\n\r\n    return { mId : id, mShader : shaderStr };\r\n}\r\n\r\n// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers\r\nEffect.prototype.IsBufferPassUsed = function( bufferID )\r\n{\r\n    for (let j=0; j\u003cthis.mPasses.length; j++ )\r\n    {\r\n        if( this.mPasses[j].mType !== \"buffer\" ) continue;\r\n        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nEffect.prototype.Save = function()\r\n{\r\n    var result = {};\r\n\r\n    result.ver = \"0.1\";\r\n\r\n    result.renderpass = [];\r\n\r\n    let numPasses = this.mPasses.length;\r\n    for (let j=0; j\u003cnumPasses; j++ )\r\n    {\r\n        result.renderpass[j] = {};\r\n\r\n        result.renderpass[j].outputs = new Array();\r\n        for (let i = 0; i\u003c4; i++ )\r\n        {\r\n            let outputID = this.mPasses[j].mOutputs[i];\r\n            if( outputID===null ) continue;\r\n            result.renderpass[j].outputs.push( { channel: i, id: outputID } );\r\n        }\r\n        result.renderpass[j].inputs = new Array();\r\n        for (let i = 0; i\u003c4; i++ )\r\n        {\r\n            if( this.mPasses[j].mInputs[i]===null ) continue;\r\n            result.renderpass[j].inputs.push( {channel: i,\r\n                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,\r\n                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,\r\n                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,\r\n                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });\r\n        }\r\n\r\n        result.renderpass[j].code = this.mPasses[j].mSource;\r\n        result.renderpass[j].name = this.mPasses[j].mName\r\n        result.renderpass[j].description = \"\";\r\n        result.renderpass[j].type = this.mPasses[j].mType;\r\n    }\r\n\r\n    result.flags = this.calcFlags();\r\n\r\n    return result;\r\n}\r\n\r\nEffect.prototype.calcFlags = function ()\r\n{\r\n    let flagVR = false;\r\n    let flagWebcam = false;\r\n    let flagSoundInput = false;\r\n    let flagSoundOutput = false;\r\n    let flagKeyboard = false;\r\n    let flagMultipass = false;\r\n    let flagMusicStream = false;\r\n\r\n    let numPasses = this.mPasses.length;\r\n    for (let j = 0; j \u003c numPasses; j++)\r\n    {\r\n        let pass = this.mPasses[j];\r\n\r\n        if (pass.mType === \"sound\") flagSoundOutput = true;\r\n        if (pass.mType === \"buffer\") flagMultipass = true;\r\n\r\n        for (let i = 0; i \u003c 4; i++)\r\n        {\r\n            if (pass.mInputs[i] === null) continue;\r\n\r\n            if (pass.mInputs[i].mInfo.mType === \"webcam\") flagWebcam = true;\r\n            else if (pass.mInputs[i].mInfo.mType === \"keyboard\") flagKeyboard = true;\r\n            else if (pass.mInputs[i].mInfo.mType === \"mic\") flagSoundInput = true;\r\n            else if (pass.mInputs[i].mInfo.mType === \"musicstream\") flagMusicStream = true;\r\n        }\r\n\r\n        let n1 = pass.mSource.indexOf(\"mainVR(\");\r\n        let n2 = pass.mSource.indexOf(\"mainVR (\");\r\n        if (n1 \u003e 0 || n2 \u003e 0) flagVR = true;\r\n    }\r\n\r\n    return {\r\n        mFlagVR: flagVR,\r\n        mFlagWebcam: flagWebcam,\r\n        mFlagSoundInput: flagSoundInput,\r\n        mFlagSoundOutput: flagSoundOutput,\r\n        mFlagKeyboard: flagKeyboard,\r\n        mFlagMultipass: flagMultipass,\r\n        mFlagMusicStream: flagMusicStream\r\n    };\r\n}\u003c/script\u003e\r\n    \u003cscript\u003e\"use strict\"\r\n\r\nfunction buildInputsUI( me )\r\n{\r\n    me.mMarks = null;\r\n    \r\n    for( let i=0; i\u003c4; i++ )\r\n    {\r\n        var par = document.getElementById( \"texture\" + i );\r\n        var can = document.getElementById( \"myUnitCanvas\" + i);\r\n        var bar = document.getElementById( \"inputSelectorControls\" + i);\r\n\r\n          par.onmouseover = function(ev)\r\n          {\r\n              let ele = piGetSourceElement( ev );\r\n              let pattern = \"iChannel\" + i;\r\n\r\n              me.mMarks = new Array();\r\n              var cm = me.mCodeEditor;\r\n              const num = cm.lineCount();\r\n              for( let j=0; j\u003cnum; j++ )\r\n              {\r\n                  var str = cm.getLine( j );\r\n                  var res = str.indexOf( pattern );\r\n                  if( res\u003c0 ) continue;\r\n                  cm.addLineClass( j, \"background\", \"cm-highlight\");\r\n                  me.mMarks.push( j );\r\n              }\r\n          }\r\n\r\n          par.onmouseout = function(ev)\r\n          {\r\n                let cm = me.mCodeEditor;\r\n                if( me.mMarks===null ) return;\r\n                let num = me.mMarks.length;\r\n                for( let j=0; j\u003cnum; j++ )\r\n                {\r\n                    var l = me.mMarks.pop();\r\n                    cm.removeLineClass( l, \"background\", \"cm-highlight\");\r\n                }\r\n                me.mMarks = null;\r\n          }\r\n\r\n          var ww = can.offsetWidth;\r\n          var hh = can.offsetHeight;\r\n          can.width = ww;\r\n          can.height = hh;\r\n\r\n          can.onclick = function (ev)\r\n          {\r\n              var passType = me.mEffect.GetPassType( me.mActiveDoc );\r\n              overlay( i, passType );\r\n          }\r\n\r\n        var dei = document.getElementById( \"myDeleteInput\" + i);\r\n        dei.id=\"myNoInput\" + i;\r\n        dei.onclick = function(ev) { me.SetTexture(i, { mType: null, mID: -1, mSrc: null, mSampler: {} }); }\r\n\r\n        var z = document.createElement( \"img\" );\r\n        z.src=\"/img/themes/\" + gThemeName + \"/pause.png\";\r\n        z.title=\"pause/resume\";\r\n        z.id=\"myPauseButton\" + i;\r\n        z.className = \"uiButtonNew\";\r\n        z.style.visibility = 'hidden';\r\n        z.onclick = function(ev) { var ele = piGetSourceElement(ev); var r = me.PauseInput( i ); if( r===true ) ele.src=\"/img/themes/\" + gThemeName + \"/play.png\"; else ele.src=\"/img/themes/\" + gThemeName + \"/pause.png\"; }\r\n        bar.appendChild( z );\r\n\r\n        z = document.createElement( \"img\" );\r\n        z.src=\"/img/themes/\" + gThemeName + \"/rewind.png\";\r\n        z.title=\"rewind\";\r\n        z.id=\"myRewindButton\" + i;\r\n        z.className = \"uiButtonNew\";\r\n        z.style.visibility = 'hidden';\r\n        z.onclick = function(ev) { var ele = piGetSourceElement(ev); var r = me.RewindInput( i ); }\r\n        bar.appendChild( z );\r\n\r\n        z = document.createElement( \"img\" );\r\n        z.src=\"/img/themes/\" + gThemeName + \"/speakerOff.png\";\r\n        z.title=\"mute\";\r\n        z.id=\"myMuteButton\" + i;\r\n        z.className = \"uiButtonNew\";\r\n        z.style.visibility = 'hidden';\r\n        z.onclick = function(ev) { var ele = piGetSourceElement(ev); var r = me.ToggleMuteInput( i ); if( r===true ) ele.src=\"/img/themes/\" + gThemeName + \"/speakerOff.png\"; else ele.src=\"/img/themes/\" + gThemeName + \"/speakerOn.png\";}\r\n        bar.appendChild( z );\r\n\r\n        z = document.createElement(\"img\");\r\n        z.src = \"/img/themes/\" + gThemeName + \"/options.png\";\r\n        z.title = \"sampler options\";\r\n        z.id = \"mySamplingButton\" + i;\r\n        z.className = \"uiButtonNew\";\r\n\r\n        z.onclick = function (ev) \r\n        { \r\n            var ele = piGetSourceElement(ev);\r\n            var sam = document.getElementById(\"mySampler\"+i);\r\n            if( sam.className===\"inputSampler visible\")\r\n            {\r\n                sam.className = \"inputSampler hidden\";\r\n            }\r\n            else\r\n            {\r\n                var eleSamplerFilter = document.getElementById( \"mySamplerFilter\"+i);\r\n                var eleSamplerWrap   = document.getElementById( \"mySamplerWrap\"+i);\r\n                var eleSamplerVFlip  = document.getElementById( \"mySamplerVFlip\"+i);\r\n                var eleSamplerVFlipLabel = document.getElementById( \"mySamplerVFlipLabel\"+i);\r\n\r\n                eleSamplerFilter.value = me.GetSamplerFilter(i);\r\n                eleSamplerWrap.value   = me.GetSamplerWrap(i);\r\n                eleSamplerVFlip.checked = (me.GetSamplerVFlip(i)==\"true\");\r\n\r\n                // see if this input accepts mipmapping\r\n                var al = me.GetAcceptsLinear(i);\r\n                eleSamplerFilter.options[1].style.display = (al==true)?'inherit':'none';\r\n                var am = me.GetAcceptsMipmapping(i);\r\n                eleSamplerFilter.options[2].style.display = (am==true)?'inherit':'none';\r\n                var ar = me.GetAcceptsWrapRepeat(i);\r\n                eleSamplerWrap.options[1].style.display = (ar==true)?'inherit':'none';\r\n                var av = me.GetAcceptsVFlip(i);\r\n                eleSamplerVFlip.style.display = (av==true)?'inherit':'none';\r\n                eleSamplerVFlipLabel.style.display = (av==true)?'inherit':'none';\r\n\r\n                sam.className = \"inputSampler visible\";\r\n            }\r\n        }\r\n\r\n        bar.appendChild(z);\r\n    }\r\n}\r\n\r\nfunction ShaderToy( parentElement, editorParent, passParent )\r\n{\r\n    if( parentElement===null ) return;\r\n    if( editorParent===null ) return;\r\n    if( passParent===null ) return;\r\n\r\n    var me = this;\r\n\r\n    this.mPassParent = passParent\r\n    this.mNeedsSave = false;\r\n    this.mAreThereAnyErrors = false;\r\n    this.mAudioContext = null;\r\n    this.mCreated = false;\r\n    this.mHttpReq = null;\r\n    this.mEffect = null;\r\n    this.mTo = null;\r\n    this.mTOffset = 0;\r\n    this.mCanvas = null;\r\n    this.mFPS = piCreateFPSCounter();\r\n    this.mIsPaused = false;\r\n    this.mForceFrame = false;\r\n    this.mInfo = null;\r\n    this.mCharCounter = document.getElementById(\"numCharacters\");\r\n    this.mCharCounterTotal = document.getElementById(\"numCharactersTotal\");\r\n    this.mEleCompilerTime = document.getElementById(\"compilationTime\");\r\n    this.mPass = [];\r\n    this.mActiveDoc = 0;\r\n    this.mIsEditorFullScreen = false;\r\n    this.mFontSize = 0;\r\n    this.mVR = null;\r\n    this.mState = 0;\r\n\r\n    buildInputsUI( this );\r\n\r\n    this.mCanvas = document.getElementById(\"demogl\");\r\n    this.mCanvas.tabIndex = \"0\"; // make it react to keyboard\r\n    this.mCanvas.width = this.mCanvas.offsetWidth;\r\n    this.mCanvas.height = this.mCanvas.offsetHeight;\r\n    this.iSetResolution(this.mCanvas.width, this.mCanvas.height);\r\n\r\n    // ---------------------------------------\r\n\r\n    this.mHttpReq = new XMLHttpRequest();\r\n    this.mTo = getRealTime();\r\n    this.mTf = 0;\r\n    this.mRestarted = true;\r\n    this.mFPS.Reset( this.mTo );\r\n    this.mMouseIsDown = false;\r\n\tthis.mMouseSignalDown = false;\r\n    this.mMouseOriX = 0;\r\n    this.mMouseOriY = 0;\r\n    this.mMousePosX = 0;\r\n    this.mMousePosY = 0;\r\n    this.mIsRendering = false;\r\n\r\n    // --- audio context ---------------------\r\n\r\n    this.mAudioContext = piCreateAudioContext();\r\n\r\n    if( this.mAudioContext===null )\r\n    {\r\n         //alert( \"no audio!\" );\r\n    }\r\n\r\n    // --- vr susbsystem ---------------------\r\n/*\r\n    this.mVR = new WebVR( function(b) \r\n                          {\r\n                               var ele = document.getElementById(\"myVR\");\r\n                               if( b )\r\n                                   ele.style.background=\"url('/img/themes/\" + gThemeName + \"/vrOn.png')\";\r\n                               else\r\n                                   ele.style.background=\"url('/img/themes/\" + gThemeName + \"/vrOff.png')\";\r\n                          },\r\n                          this.mCanvas );\r\n*/\r\n    // --- soundcloud context ---------------------\r\n    this.mSoundcloudImage = new Image();\r\n    this.mSoundcloudImage.src = \"/img/themes/\" + gThemeName + \"/soundcloud.png\";\r\n\r\n    window.onfocus = function()\r\n    {\r\n        if( !this.mIsPaused )\r\n        {\r\n            me.mTOffset = me.mTf;\r\n            me.mTo = getRealTime();\r\n            me.mRestarted = true;\r\n        }\r\n    };\r\n\r\n    var refreshCharsAndFlags = function()\r\n    {\r\n         me.setChars();\r\n         //me.setFlags();\r\n         setTimeout( refreshCharsAndFlags, 1500 );\r\n    }\r\n    // ---------------\r\n\r\n    this.mErrors = new Array();\r\n\r\n    var ekeys = null;\r\n    if( navigator.platform.match(\"Mac\") )\r\n    {\r\n        ekeys = { \"Ctrl-S\":    function(instance) { doSaveShader(); } ,\r\n                  \"Cmd-S\":     function(instance) { doSaveShader(); } ,\r\n                  \"Alt-Enter\": function(instance) { me.SetShaderFromEditor(false,true); },\r\n                  \"Cmd-Enter\": function(instance) { me.SetShaderFromEditor(false,true); },\r\n                  \"Alt--\":     function(instance) { me.decreaseFontSize(); },\r\n                  \"Cmd--\":     function(instance) { me.decreaseFontSize(); },\r\n                  \"Alt-=\":     function(instance) { me.increaseFontSize(); },\r\n                  \"Cmd-=\":     function(instance) { me.increaseFontSize(); },\r\n                  \"Cmd-Right\": function(instance) { me.ChangeTabRight(); },\r\n                  \"Cmd-Left\":  function(instance) { me.ChangeTabLeft(); },\r\n                  \"Cmd-Down\":  function(instance) { me.resetTime(false); },\r\n                  \"Alt-Down\":  function(instance) { me.resetTime(false); },\r\n                  \"Alt-Up\":    function(instance) { me.pauseTime(false); },\r\n                  \"Cmd-Up\":    function(instance) { me.pauseTime(false); },\r\n                  \"Shift-Tab\": \"indentLess\",\r\n                  \"Tab\":       \"indentMore\"\r\n                  };\r\n    }\r\n    else\r\n    {\r\n        ekeys = { \"Ctrl-S\":    function(instance) { doSaveShader(); } ,\r\n                  \"Alt-Enter\": function(instance) { me.SetShaderFromEditor(false,true); },\r\n                  \"Alt--\":     function(instance) { me.decreaseFontSize(); },\r\n                  \"Alt-=\":     function(instance) { me.increaseFontSize(); },\r\n                  \"Alt-Right\": function(instance) { me.ChangeTabRight(); },\r\n                  \"Alt-Left\":  function(instance) { me.ChangeTabLeft(); },\r\n                  \"Alt-Down\":  function(instance) { me.resetTime(false); },\r\n                  \"Alt-Up\":    function(instance) { me.pauseTime(false); },\r\n                  \"Shift-Tab\": \"indentLess\",\r\n                  \"Tab\":       \"indentMore\"\r\n                  };\r\n    }\r\n\r\n    this.mCodeEditor = CodeMirror( editorParent,\r\n                                   {\r\n                                       lineNumbers: true,\r\n                                       matchBrackets: true,\r\n                                       indentWithTabs: false,\r\n                                       tabSize: 4,\r\n                                       indentUnit: 4,\r\n                                       mode: \"text/x-glsl\",\r\n                                       smartIndent: false,\r\n                                       electricChars: false,\r\n                                       foldGutter: true,\r\n                                       gutters: [\"CodeMirror-linenumbers\", \"CodeMirror-foldgutter\"],\r\n                                       extraKeys: ekeys\r\n        });\r\n    //this.mCodeEditor.setOption(\"readOnly\", true);\r\n\r\n    this.mCodeEditor.on( \"change\",         function(instance,ev) { me.mNeedsSave = true; me.mPass[me.mActiveDoc].mDirty=true; me.mPass[me.mActiveDoc].mCharCountDirty = true; } );\r\n\r\n    //--------------\r\n\r\n    refreshCharsAndFlags(this);\r\n    //this.setCompilationTime();\r\n    this.mEleCompilerTime.textContent = \"\";\r\n\r\n    document.getElementById(\"uiFontSelector\").addEventListener('click', function (ev) {\r\n        me.setFontSize(this.selectedIndex, true);\r\n    });\r\n\r\n\r\n    this.mCanvas.onmousedown = function(ev)\r\n    {\r\n        var rect = me.mCanvas.getBoundingClientRect();\r\n        me.mMouseOriX = Math.floor((ev.clientX-rect.left)/(rect.right-rect.left)*me.mCanvas.width);\r\n        me.mMouseOriY = Math.floor(me.mCanvas.height - (ev.clientY-rect.top)/(rect.bottom-rect.top)*me.mCanvas.height);\r\n        me.mMousePosX = me.mMouseOriX;\r\n        me.mMousePosY = me.mMouseOriY;\r\n        me.mMouseIsDown = true;\r\n\t\tme.mMouseSignalDown = true;\r\n        if( me.mIsPaused ) me.mForceFrame = true;\r\n//        return false; // prevent mouse pointer change\r\n    }\r\n    this.mCanvas.onmousemove = function(ev)\r\n    {\r\n        if( me.mMouseIsDown )\r\n        {\r\n            var rect = me.mCanvas.getBoundingClientRect();\r\n            me.mMousePosX = Math.floor((ev.clientX-rect.left)/(rect.right-rect.left)*me.mCanvas.width);\r\n            me.mMousePosY = Math.floor(me.mCanvas.height - (ev.clientY-rect.top)/(rect.bottom-rect.top)*me.mCanvas.height);\r\n            if( me.mIsPaused ) me.mForceFrame = true;\r\n        }\r\n    }\r\n    this.mCanvas.onmouseup = function(ev)\r\n    {\r\n        me.mMouseIsDown = false;\r\n        if( me.mIsPaused ) me.mForceFrame = true;\r\n    }\r\n\r\n    this.mCanvas.addEventListener(\"keydown\",function(ev)\r\n    {\r\n        me.mEffect.SetKeyDown( me.mActiveDoc, ev.keyCode );\r\n        if( me.mIsPaused ) me.mForceFrame = true;\r\n        ev.preventDefault();\r\n    },false);\r\n\r\n    this.mCanvas.addEventListener(\"keyup\",function(ev)\r\n    {\r\n        if ((ev.keyCode == 82) \u0026\u0026 ev.altKey)\r\n        {\r\n            let r = document.getElementById(\"myRecord\");\r\n            r.click();\r\n        }\r\n        \r\n        me.mEffect.SetKeyUp( me.mActiveDoc, ev.keyCode );\r\n        if( me.mIsPaused ) me.mForceFrame = true;\r\n        ev.preventDefault();\r\n    },false);\r\n\r\n    document.getElementById(\"myResetButton\").addEventListener('click',  function( ev )\r\n    {\r\n        me.resetTime(true);\r\n    } );\r\n    document.getElementById(\"myPauseButton\").addEventListener('click',  function() \r\n    {\r\n        me.pauseTime(true);\r\n    } );\r\n\r\n    document.getElementById(\"myVolume\").addEventListener('click',  function(ev)\r\n    {\r\n        var res = me.mEffect.ToggleVolume();\r\n        if( res )\r\n            this.style.background=\"url('/img/themes/\" + gThemeName + \"/speakerOff.png')\";\r\n        else\r\n            this.style.background=\"url('/img/themes/\" + gThemeName + \"/speakerOn.png')\";\r\n    } );\r\n/*\r\n    document.getElementById(\"myVR\").addEventListener('click',  function(ev)\r\n    {\r\n        var vr = me.mVR.IsSupported();\r\n        if( !vr )\r\n        {\r\n            alert( \"WebVR API is not supported in this browser\" );\r\n        }\r\n        else\r\n        {\r\n            if (me.mEffect.IsEnabledVR())\r\n                me.mEffect.DisableVR();\r\n            else\r\n                me.mEffect.EnableVR();\r\n        }\r\n    } );\r\n*/\r\n    var mFullScreenExitHandler= function ()\r\n                                { \r\n                                    if( piIsFullScreen() ) \r\n                                    { \r\n                                    } \r\n                                    else \r\n                                    { \r\n                                        //if( me.mVR.IsSupported() )\r\n                                        {\r\n                                            //me.mEffect.DisableVR();\r\n                                        }\r\n                                    } \r\n                                };\r\n    this.mCanvas.addEventListener('webkitfullscreenchange', mFullScreenExitHandler, false);\r\n    this.mCanvas.addEventListener('mozfullscreenchange', mFullScreenExitHandler, false);\r\n    this.mCanvas.addEventListener('fullscreenchange', mFullScreenExitHandler, false);\r\n    this.mCanvas.addEventListener('MSFullscreenChange', mFullScreenExitHandler, false);\r\n\r\n    document.getElementById(\"myFullScreen\").addEventListener('click',  function( ev )\r\n    {\r\n        piRequestFullScreen( me.mCanvas );\r\n        me.mCanvas.focus(); // put mouse/keyboard focus on canvas\r\n    } );\r\n\r\n    //-------------------------\r\n\r\n    let resizeCB = function (xres, yres)\r\n    {\r\n        me.mForceFrame = true;\r\n        me.iSetResolution(xres, yres);\r\n    };\r\n\r\n    let crashCB = function ()\r\n    {\r\n        me.mIsPaused = true;\r\n        alert('Shadertoy: ooops, your WebGL implementation has crashed!');\r\n    };\r\n\r\n    this.mEffect = new Effect(this.mVR, this.mAudioContext, this.mCanvas, this.RefreshTexturThumbail, this, false, false, resizeCB, crashCB);\r\n    if( !this.mEffect.mCreated )\r\n    {\r\n        let ele = document.getElementById(\"noWebGL\");\r\n        ele.style.visibility = \"visible\";\r\n        this.mCanvas.style.visibility = \"hidden\";\r\n\r\n        let img = document.getElementById(\"noWebGL_ShaderImage\");\r\n        let url = \"/media/shaders/\" + gShaderID + \".jpg\";\r\n        img.onerror = function (ev) { };\r\n        img.src = url;\r\n\r\n        this.mIsPaused = true;\r\n        this.mForceFrame = false;\r\n        this.mCreated = false;\r\n        return;\r\n    }\r\n    \r\n    // --- mediaRecorder ---------------------\r\n\r\n    this.mMediaRecorder = null;\r\n\r\n    document.getElementById(\"myRecord\").onclick = function(ev)\r\n    {\r\n        if (me.mMediaRecorder === null)\r\n        {\r\n            me.mMediaRecorder = piCreateMediaRecorder(\r\n                function (b)\r\n                {\r\n                    var ele = document.getElementById(\"myRecord\");\r\n                    if (b)\r\n                        ele.style.background = \"url('/img/themes/\" + gThemeName + \"/recordOn.png')\";\r\n                    else\r\n                        ele.style.background = \"url('/img/themes/\" + gThemeName + \"/recordOff.png')\";\r\n                }\r\n                , me.mCanvas);\r\n        }\r\n        if( me.mMediaRecorder === null )\r\n        {\r\n            let ele = document.getElementById(\"myRecord\");\r\n            ele.style.background = \"url('/img/themes/\" + gThemeName + \"/recordDisabled.png')\";\r\n            alert('MediaRecord API is not supported in this browser');\r\n            return;\r\n        }\r\n\r\n        if (me.mMediaRecorder.state === \"inactive\") \r\n        {\r\n            me.mMediaRecorder.start();\r\n        } \r\n        else \r\n        {\r\n            me.mMediaRecorder.stop();\r\n        }\r\n    }\r\n\r\n    this.mCreated = true;\r\n}\r\n\r\nShaderToy.prototype.saveScreenshot = function()\r\n{\r\n    this.mEffect.saveScreenshot( this.mActiveDoc);\r\n}\r\n\r\nShaderToy.prototype.setFontSize = function( id, fromUI )\r\n{\r\n    if (id \u003c 0) id = 0;\r\n    if (id \u003e 5) id = 5;\r\n    if (id === this.mFontSize) return;\r\n\r\n    this.mFontSize = id;\r\n    var edi = document.getElementById(\"editor\");\r\n    edi.style.fontSize = '' + (1.0 + 0.25*id ).toFixed(2) + 'em';\r\n\r\n    this.mCodeEditor.refresh();\r\n\r\n    if (fromUI)\r\n    {\r\n        var httpReq = new XMLHttpRequest();\r\n        //httpReq.onload = function () { var jsn = httpReq.response; };\r\n        httpReq.open(\"POST\", \"/shadertoy\", true);\r\n        httpReq.responseType = \"json\";\r\n        httpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n        httpReq.send(\"upo=1\u0026sfs=\" + id);\r\n    }\r\n    else\r\n    {\r\n        var ele = document.getElementById(\"uiFontSelector\");\r\n        ele.selectedIndex = id;\r\n    }\r\n}\r\n\r\nShaderToy.prototype.decreaseFontSize = function()\r\n{\r\n    this.setFontSize( this.mFontSize-1, true );\r\n    var ele = document.getElementById(\"uiFontSelector\");\r\n    ele.selectedIndex = this.mFontSize;\r\n}\r\nShaderToy.prototype.increaseFontSize = function()\r\n{\r\n    this.setFontSize( this.mFontSize+1, true );\r\n    var ele = document.getElementById(\"uiFontSelector\");\r\n    ele.selectedIndex = this.mFontSize;\r\n}\r\nShaderToy.prototype.GetNeedSave = function()\r\n{\r\n    return this.mNeedsSave;\r\n}\r\nShaderToy.prototype.SetNeedSave = function(v)\r\n{\r\n    this.mNeedsSave = v;\r\n}\r\n\r\nShaderToy.prototype.startRendering = function()\r\n{\r\n    this.mIsRendering = true;\r\n    var me = this;\r\n\r\n    function renderLoop2()\r\n    {\r\n        me.mEffect.RequestAnimationFrame(renderLoop2);\r\n\r\n        if( me.mIsPaused \u0026\u0026 !me.mForceFrame )\r\n        {\r\n            me.mEffect.UpdateInputs( me.mActiveDoc, false );\r\n            return;\r\n        }\r\n        me.mForceFrame = false;\r\n\r\n        var time = getRealTime();\r\n\r\n        var ltime = 0.0;\r\n        var dtime = 0.0;\r\n        if( me.mIsPaused ) \r\n        {\r\n            ltime = me.mTf;\r\n            dtime = 1000.0 / 60.0;\r\n        }\r\n        else\r\n        {\r\n            ltime = me.mTOffset + time - me.mTo;\r\n            if( me.mRestarted )\r\n                dtime = 1000.0/60.0;\r\n            else\r\n                dtime = ltime - me.mTf; \r\n            me.mTf = ltime;\r\n        }\r\n        me.mRestarted = false;\r\n\r\n        var newFPS = me.mFPS.Count( time );\r\n\r\n\t\tlet mouseOriX = Math.abs( me.mMouseOriX );\r\n\t\tlet mouseOriY = Math.abs( me.mMouseOriY );\r\n\t\tif( !me.mMouseIsDown )     mouseOriX = -mouseOriX;\r\n\t\tif( !me.mMouseSignalDown ) mouseOriY = -mouseOriY;\r\n        me.mMouseSignalDown = false;\r\n\r\n        me.mEffect.Paint(ltime/1000.0, dtime/1000.0, me.mFPS.GetFPS(), mouseOriX, mouseOriY, me.mMousePosX, me.mMousePosY, me.mIsPaused );\r\n\r\n        document.getElementById(\"myTime\").textContent = (ltime/1000.0).toFixed(2);\r\n        if( me.mIsPaused )\r\n        {\r\n        }\r\n        else\r\n        {\r\n            if( newFPS )\r\n            {\r\n                document.getElementById(\"myFramerate\").textContent = me.mFPS.GetFPS().toFixed(1) + \" fps\";\r\n            }\r\n        }\r\n    }\r\n\r\n    renderLoop2();\r\n}\r\n\r\nShaderToy.prototype.iSetResolution = function (xres, yres)\r\n{\r\n    document.getElementById(\"myResolution\").textContent =  \"\" + xres.toString() + \" x \"  + yres.toString();\r\n}\r\n\r\nShaderToy.prototype.pauseTime = function(doFocusCanvas)\r\n{\r\n    if( !this.mIsPaused )\r\n    {\r\n        document.getElementById(\"myPauseButton\").style.background=\"url('/img/themes/\" + gThemeName + \"/play.png')\";\r\n        this.mIsPaused = true;\r\n        this.mEffect.StopOutputs();\r\n    }\r\n    else\r\n    {\r\n        document.getElementById(\"myPauseButton\").style.background=\"url('/img/themes/\" + gThemeName + \"/pause.png')\";\r\n        this.mTOffset = this.mTf;\r\n        this.mTo = getRealTime();\r\n        this.mIsPaused = false;\r\n        this.mRestarted = true;\r\n        this.mEffect.ResumeOutputs();\r\n        if( doFocusCanvas )\r\n            this.mCanvas.focus();\r\n    }\r\n}\r\n\r\nShaderToy.prototype.resetTime = function(doFocusOnCanvas)\r\n{\r\n    this.mTOffset = 0;\r\n    this.mTo = getRealTime();\r\n    this.mTf = 0;\r\n    this.mRestarted = true;\r\n    this.mFpsTo = this.mTo;\r\n    this.mFpsFrame = 0;\r\n    this.mForceFrame = true;\r\n    this.mEffect.ResetTime();\r\n    if( doFocusOnCanvas )\r\n        this.mCanvas.focus();\r\n}\r\n\r\nShaderToy.prototype.SetErrors = function( isError, errorStr, fromScript )\r\n{\r\n    while( this.mErrors.length \u003e 0 )\r\n    {\r\n        var mark = this.mErrors.pop();\r\n        this.mCodeEditor.removeLineWidget( mark );\r\n    }\r\n\r\n    if( !isError )\r\n    {\r\n        this.mForceFrame = true;\r\n    }\r\n    else\r\n    {\r\n        var lineOffset = this.mEffect.GetHeaderSize( this.mActiveDoc );\r\n\r\n        var lines = errorStr.split(/\\r\\n|\\r|\\n/);\r\n\r\n        var maxLines = this.mCodeEditor.lineCount();\r\n\r\n        for( let i=0; i\u003clines.length; i++ )\r\n        {\r\n            let parts = lines[i].split(\":\");\r\n            if( parts.length===5 || parts.length===6 )\r\n            {\r\n                let lineAsInt = parseInt( parts[2] );\r\n\r\n                if( isNaN(lineAsInt) ) // for non-webgl errors\r\n                {\r\n                  let msg = document.createElement(\"div\");\r\n                  msg.appendChild( document.createTextNode( \"Unknown Error: \" + lines[i] ));\r\n                  msg.className = \"errorMessage\";\r\n                  let mark = this.mCodeEditor.addLineWidget( 0, msg, {coverGutter: false, noHScroll: true} );\r\n                  this.mErrors.push( mark );\r\n                }\r\n                else\r\n                {\r\n                  let lineNumber = lineAsInt - lineOffset;\r\n\r\n                  let msg = document.createElement(\"div\");\r\n                  msg.appendChild(document.createTextNode( parts[3] + \" : \" + parts[4] ));\r\n                  msg.className = \"errorMessage\";\r\n\r\n                  if( lineNumber\u003emaxLines ) lineNumber = maxLines;\r\n\r\n                  let mark = this.mCodeEditor.addLineWidget( lineNumber, msg, {coverGutter: false, noHScroll: true} );\r\n                  this.mErrors.push( mark );\r\n                }\r\n            }\r\n            else if( lines[i] !== null \u0026\u0026 lines[i]!==\"\" \u0026\u0026 lines[i].length\u003e1 \u0026\u0026 parts[0]!==\"Warning\")\r\n            {\r\n                let txt = \"\";\r\n                if( parts.length===4 )\r\n                    txt = parts[2] + \" : \" + parts[3];\r\n                else\r\n                    txt = \"Unknown error: \" + lines[i];\r\n\r\n                let msg = document.createElement(\"div\");\r\n                msg.appendChild(document.createTextNode( txt ));\r\n                msg.className = \"errorMessage\";\r\n                let mark = this.mCodeEditor.addLineWidget( 0, msg, {coverGutter: false, noHScroll: true, above: true} );\r\n                this.mErrors.push( mark );\r\n            }\r\n         }\r\n    }\r\n}\r\n\r\nShaderToy.prototype.AllowPublishing = function()\r\n{\r\n    if (this.mAreThereAnyErrors) return false;\r\n    return true;\r\n}\r\n\r\nShaderToy.prototype.GetTotalCompilationTime = function ()\r\n{\r\n    return this.mEffect.GetTotalCompilationTime();\r\n}\r\n\r\nShaderToy.prototype.SetErrorsGlobal = function (areThereAnyErrors, fromScript)\r\n{\r\n    this.mAreThereAnyErrors = areThereAnyErrors;\r\n    let eleWrapper = document.getElementById('editor');\r\n\r\n    if( areThereAnyErrors===false )\r\n    {\r\n        this.mForceFrame = true;\r\n        if( fromScript===false )\r\n        {\r\n            eleWrapper.classList.add(\"errorNo\");\r\n            setTimeout(function () { eleWrapper.classList.remove( \"errorNo\" ); }, 500 );\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if (fromScript === false)\r\n        {\r\n            eleWrapper.classList.add(\"errorYes\");\r\n            setTimeout(function () { eleWrapper.classList.remove(\"errorYes\"); }, 500);\r\n        }\r\n    }\r\n}\r\n\r\nShaderToy.prototype.SetTexture = function( slot, url )\r\n{\r\n    this.mNeedsSave = true;\r\n    var res = this.mEffect.NewTexture( this.mActiveDoc, slot, url );\r\n    if( res.mFailed===false )\r\n    {\r\n        this.mPass[this.mActiveDoc].mDirty = res.mNeedsShaderCompile;\r\n    }\r\n}\r\nShaderToy.prototype.PauseInput = function (id) { return this.mEffect.PauseInput(this.mActiveDoc, id); }\r\nShaderToy.prototype.ToggleMuteInput = function (id) { return this.mEffect.ToggleMuteInput(this.mActiveDoc, id); }\r\nShaderToy.prototype.RewindInput = function (id) { this.mEffect.RewindInput(this.mActiveDoc, id); }\r\nShaderToy.prototype.GetTexture = function( slot ) { return this.mEffect.GetTexture( this.mActiveDoc, slot ); }\r\nShaderToy.prototype.GetAcceptsLinear = function (slot) { return this.mEffect.GetAcceptsLinear(this.mActiveDoc, slot); }\r\nShaderToy.prototype.GetAcceptsMipmapping = function (slot) { return this.mEffect.GetAcceptsMipmapping(this.mActiveDoc, slot); }\r\nShaderToy.prototype.GetAcceptsWrapRepeat = function (slot) { return this.mEffect.GetAcceptsWrapRepeat(this.mActiveDoc, slot); }\r\nShaderToy.prototype.GetAcceptsVFlip = function (slot) { return this.mEffect.GetAcceptsVFlip(this.mActiveDoc, slot); }\r\nShaderToy.prototype.SetSamplerFilter = function (slot, str) { this.mEffect.SetSamplerFilter(this.mActiveDoc, slot, str);  this.mForceFrame = true; }\r\nShaderToy.prototype.GetSamplerFilter = function (slot) { return this.mEffect.GetSamplerFilter(this.mActiveDoc, slot); }\r\nShaderToy.prototype.SetSamplerWrap = function (slot, str) { this.mEffect.SetSamplerWrap(this.mActiveDoc, slot, str); this.mForceFrame = true; }\r\nShaderToy.prototype.GetSamplerWrap = function (slot) { return this.mEffect.GetSamplerWrap(this.mActiveDoc, slot); }\r\nShaderToy.prototype.SetSamplerVFlip = function (slot, str) { this.mEffect.SetSamplerVFlip(this.mActiveDoc, slot, str); this.mForceFrame = true; }\r\nShaderToy.prototype.GetSamplerVFlip = function (slot) { return this.mEffect.GetSamplerVFlip(this.mActiveDoc, slot); }\r\n\r\nShaderToy.prototype.ShowTranslatedSource = function()\r\n{\r\n    let str = this.mEffect.GetTranslatedShaderSource(this.mActiveDoc);\r\n    let ve = document.getElementById(\"centerScreen\" );\r\n    doAlert( piGetCoords(ve), {mX:640,mY:512}, \"Translated Shader Code\", \"\u003cpre\u003e\"+str+\"\u003c/pre\u003e\", false, null );\r\n}\r\n\r\nShaderToy.prototype.UIStartCompiling = function (affectsUI)\r\n{\r\n    this.mState = 2;\r\n    this.mEleCompilerTime.textContent = \"Compiling...\";\r\n    if (affectsUI)\r\n    {\r\n        this.setActionsState(false);\r\n    }\r\n}\r\n\r\nShaderToy.prototype.UIEndCompiling = function (affectsUI)\r\n{\r\n    if( affectsUI ) this.setActionsState(true);\r\n\r\n    let anyErrors = this.mEffect.GetErrorGlobal();\r\n    this.setCompilationTime();\r\n    this.setSaveOptions(anyErrors);\r\n\r\n    for (let i = 0; i \u003c this.mEffect.GetNumPasses(); i++)\r\n    {\r\n        let eleLab = document.getElementById(\"tab\" + i);\r\n        if (this.mEffect.GetError(i) )\r\n            eleLab.classList.add(\"errorYes\");\r\n        else\r\n            eleLab.classList.remove(\"errorYes\");\r\n    }\r\n\r\n    this.SetErrors(this.mEffect.GetError(this.mActiveDoc),\r\n                   this.mEffect.GetErrorStr(this.mActiveDoc), false);\r\n    this.SetErrorsGlobal(anyErrors, false);\r\n    this.setChars();\r\n    this.setFlags();\r\n\r\n    if (!anyErrors)\r\n    {\r\n        if (!this.mIsRendering)\r\n        {\r\n            this.startRendering();\r\n            this.resetTime();\r\n        }\r\n        this.mForceFrame = true;\r\n    }\r\n\r\n    this.mState = 1;\r\n}\r\n\r\nShaderToy.prototype.setActionsState = function (areEnabled)\r\n{\r\n    let eleSave = document.getElementById(\"saveButton\");\r\n    let eleComp = document.getElementById(\"compileButton\");\r\n\r\n    if (eleSave !== null)\r\n        eleSave.disabled = !areEnabled;\r\n    eleComp.disabled = !areEnabled;\r\n}\r\n\r\nShaderToy.prototype.SetShaderFromEditor = function( forceall, affectsUI )\r\n{\r\n    if (this.mState!==1) return;\r\n\r\n    let num = this.mEffect.GetNumPasses();\r\n    for (let i = 0; i \u003c num; i++)\r\n    {\r\n        if (this.mEffect.GetPassType(i) === \"common\" \u0026\u0026 this.mPass[i].mDirty)\r\n        {\r\n            forceall = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    this.UIStartCompiling(affectsUI);\r\n    window.setTimeout(function ()\r\n    {\r\n        let passes = [];\r\n        for( let i=0; i\u003cnum; i++ )\r\n        {\r\n            if( this.mPass[i].mDirty || forceall )\r\n            {\r\n                let shaderCode = this.mPass[i].mDocs.getValue();\r\n                this.mEffect.SetCode(i, shaderCode);\r\n                this.mPass[i].mDirty = false;\r\n                this.mPass[i].mCharCount = minify(shaderCode).length;\r\n                this.mPass[i].mCharCountDirty = false;\r\n                passes.push( i );\r\n            }\r\n        }\r\n\r\n        let me = this;\r\n        this.mEffect.CompileSome(passes, true, function (worked)\r\n        {\r\n            me.UIEndCompiling(affectsUI)\r\n        });\r\n    }.bind(this), 10);\r\n}\r\n\r\n\r\n// guiID: { null, texture, cubemap, video, music, mic, keyb, webcam, musicstream, buffer }\r\nShaderToy.prototype.RefreshTexturThumbail = function( myself, slot, img, forceFrame, guiID, renderID, time, passID )\r\n{\r\n  if (passID !== myself.mActiveDoc) return;\r\n\r\n  var canvas = document.getElementById('myUnitCanvas'+slot);\r\n  var i0 = document.getElementById('myPauseButton' + slot);\r\n  var i1 = document.getElementById('myRewindButton' + slot);\r\n  var i2 = document.getElementById('myMuteButton' + slot);\r\n  var i3 = document.getElementById('mySamplingButton' + slot);\r\n  var i4 = document.getElementById('myNoInput' + slot);\r\n\r\n  if (guiID === 0  )\r\n  {\r\n      i3.style.visibility = \"hidden\";\r\n      i4.style.visibility = \"hidden\";\r\n  }\r\n  else\r\n  {\r\n      i3.style.visibility = \"visible\";\r\n      i4.style.visibility = \"visible\";\r\n  }\r\n\r\n  if (guiID === 0 || guiID === 1 || guiID===2 || guiID===5 || guiID===6 || guiID===9  )\r\n  {\r\n      i0.style.visibility = \"hidden\";\r\n      i1.style.visibility = \"hidden\";\r\n      i2.style.visibility = \"hidden\";\r\n  }\r\n  else\r\n  {\r\n      i0.style.visibility = \"visible\";\r\n      i1.style.visibility = \"visible\";\r\n      i2.style.visibility = \"visible\";\r\n  }\r\n\r\n  var w = canvas.width;\r\n  var h = canvas.height;\r\n\r\n  var ctx = canvas.getContext('2d');\r\n\r\n  if (guiID === 0)\r\n  {\r\n      ctx.fillStyle = \"#000000\";\r\n      ctx.fillRect(0, 0, w, h);\r\n  }\r\n  else if (guiID === 1)\r\n  {\r\n      ctx.fillStyle = \"#000000\";\r\n      if (renderID===0 )\r\n          ctx.fillRect(0, 0, w, h+4);\r\n      else \r\n      {\r\n        ctx.fillRect(0, 0, w, h);  \r\n        ctx.drawImage(img, 0, 0, w, h);\r\n      }\r\n  }\r\n  else if (guiID === 2) \r\n  {\r\n      ctx.fillStyle = \"#000000\";\r\n      if (renderID===0 )\r\n          ctx.fillRect(0, 0, w, h+4);\r\n      else\r\n          ctx.drawImage(img, 0, 0, w, h);\r\n  }\r\n  else if (guiID === 3) \r\n  {\r\n      ctx.fillStyle = \"#000000\";\r\n      if (renderID===0 )\r\n          ctx.fillRect(0, 0, w, h+4);\r\n      else\r\n          ctx.drawImage(img, 0, 0, w, h);\r\n  }\r\n  else if (guiID === 4 || guiID === 5 || guiID === 8)\r\n  {\r\n\r\n      if (renderID === 0)\r\n      {\r\n          ctx.fillStyle = \"#000000\";\r\n          ctx.fillRect(0, 0, w, h+4);\r\n\r\n          ctx.strokeStyle = \"#808080\";\r\n          ctx.lineWidth = 1;\r\n          ctx.beginPath();\r\n          let num = w / 2;\r\n          for (let i = 0; i \u003c num; i++)\r\n          {\r\n              let y = Math.sin(64.0 * 6.2831 * i / num + time) * Math.sin(2.0 * 6.2831 * i / num + time);\r\n              let ix = w * i / num;\r\n              let iy = h * (0.5 + 0.4 * y);\r\n              if (i === 0) ctx.moveTo(ix, iy);\r\n              else ctx.lineTo(ix, iy);\r\n          }\r\n          ctx.stroke();\r\n\r\n          let str = \"Audio not loaded\";\r\n          ctx.font = \"normal bold 20px Arial\";\r\n          ctx.lineWidth = 4;\r\n          ctx.strokeStyle = \"#000000\";\r\n          ctx.strokeText(str, 14, h / 2);\r\n          ctx.fillStyle = \"#ff0000\";\r\n          ctx.fillText(str, 14, h / 2);\r\n\r\n          document.getElementById(\"myPauseButton\" + slot).src = \"/img/themes/\" + gThemeName + \"/pause.png\";\r\n      }\r\n      else \r\n      {\r\n          var voff = 0;\r\n\r\n          ctx.fillStyle = \"#000000\";\r\n          ctx.fillRect(0, 0, w, h);\r\n          ctx.fillStyle = \"#ffffff\";\r\n\r\n          var numfft = img.wave.length;\r\n          numfft /= 2;\r\n          if (numfft \u003e 512) numfft = 512;\r\n          let num = 32;\r\n          var numb = (numfft / num) | 0;\r\n          var s = ((w - 8 * 2) / num);\r\n          var k = 0;\r\n          for (let i = 0; i \u003c num; i++)\r\n          {\r\n              let f = 0.0;\r\n              for (let j = 0; j \u003c numb; j++)\r\n              {\r\n                  f += img.wave[k++];\r\n              }\r\n              f /= numb;\r\n              f /= 255.0;\r\n\r\n              let fr = f;\r\n              let fg = 4.0 * f * (1.0 - f);\r\n              let fb = 1.0 - f;\r\n\r\n              let rr = (255.0 * fr) | 0;\r\n              let gg = (255.0 * fg) | 0;\r\n              let bb = (255.0 * fb) | 0;\r\n\r\n              let decColor = 0x1000000 + bb + 0x100 * gg + 0x10000 * rr;\r\n              ctx.fillStyle = '#' + decColor.toString(16).substr(1);\r\n\r\n              let a = Math.max(2, f * (h - 2 * 20));\r\n              ctx.fillRect(8 + i * s, h - voff - a, 3 * s / 4, a);\r\n          }\r\n\r\n          // If it is a music stream then we want to show extra information\r\n          if (guiID===8)\r\n          {\r\n              let str = img.info.user.username + \" - \" + img.info.title;\r\n              let x = w - 10.0 * (time % 45.0);\r\n              ctx.font = \"normal normal 12px Arial\";\r\n              ctx.strokeStyle = \"#000000\";\r\n              ctx.lineWidth = 4;\r\n              ctx.strokeText(str,x,32);\r\n              ctx.fillStyle = \"#ffffff\";\r\n              ctx.fillText(str,x,32);\r\n              ctx.drawImage(myself.mSoundcloudImage, 45, 0);\r\n          }\r\n      }\r\n  }\r\n  else if (guiID === 6) //kyeboard\r\n  {\r\n    var thereskey = false;\r\n    ctx.fillStyle = \"#ffffff\";\r\n    for( let i=0; i\u003c256; i++ )\r\n    {\r\n        let x = (w*i/256) | 0;\r\n        if( img.mData[i]\u003e0 )\r\n        {\r\n            thereskey = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    ctx.drawImage( img.mImage, 0, 0, w, h );\r\n\r\n    if( thereskey )\r\n    {\r\n        ctx.fillStyle = \"#ff8040\";\r\n        ctx.globalAlpha = 0.4;\r\n        ctx.fillRect(0,0,w,h);\r\n        ctx.globalAlpha = 1.0;\r\n    }\r\n  }\r\n  else if (guiID === 7) \r\n  {\r\n      ctx.fillStyle = \"#000000\";\r\n      if (renderID === 0)\r\n          ctx.fillRect(0, 0, w, h);\r\n      else\r\n          ctx.drawImage(img, 0, 0, w, h);\r\n  }\r\n  else if (guiID === 9)\r\n  {\r\n      if (renderID === 0)\r\n      {\r\n          ctx.fillStyle = \"#808080\";\r\n          ctx.fillRect(0, 0, w, h);\r\n      }\r\n      else\r\n      {\r\n          ctx.drawImage(img.texture, 0, 0, w, h);\r\n          if( img.data !== null )\r\n          {\r\n                ctx.putImageData( img.data, 0, 0,  0, 0, w, h ); \r\n          }\r\n      }\r\n  }\r\n\r\n  if (time \u003e 0.0)\r\n  {\r\n      let str = time.toFixed(2) + \"s\";\r\n      ctx.font=\"normal normal 10px Arial\";\r\n      ctx.strokeStyle = \"#000000\";\r\n      ctx.lineWidth = 4;\r\n      ctx.strokeText(str,4,12);\r\n      ctx.fillStyle = \"#ffffff\";\r\n      ctx.fillText(str,4,12);\r\n  }\r\n\r\n  myself.mForceFrame = forceFrame;\r\n}\r\n\r\nShaderToy.prototype.setChars = function()\r\n{\r\n    if( this.mPass.length===1 )\r\n    {\r\n        if( this.mPass[0].mCharCountDirty )\r\n        {\r\n            this.mPass[0].mCharCount = minify( this.mCodeEditor.getValue() ).length;\r\n            this.mPass[0].mCharCountDirty = false;\r\n        }\r\n        this.mCharCounter.textContent = this.mPass[0].mCharCount + \" chars\";\r\n        this.mCharCounterTotal.textContent = \"\";\r\n    }\r\n    else\r\n    {\r\n        let currentPassCount = 0;\r\n        let globalCount = 0;\r\n        for( let i=0; i\u003cthis.mPass.length; i++ )\r\n        {\r\n            if( this.mPass[i].mCharCountDirty )\r\n            {\r\n                this.mPass[i].mCharCount = minify( this.mPass[i].mDocs.getValue() ).length;\r\n                this.mPass[i].mCharCountDirty = false;\r\n            }\r\n            if( i===this.mActiveDoc ) currentPassCount = this.mPass[i].mCharCount;\r\n            globalCount += this.mPass[i].mCharCount;\r\n        }\r\n        this.mCharCounter.textContent = currentPassCount;\r\n        this.mCharCounterTotal.textContent = \" / \" + globalCount + \" chars\";\r\n    }\r\n}\r\n\r\nShaderToy.prototype.setSaveOptions = function(areThereErrors)\r\n{\r\n    let elePubished = document.getElementById('published');\r\n    if (elePubished === null) return;\r\n\r\n    //let compileTime = this.mEffect.GetTotalCompilationTime();\r\n    let disableOptions = areThereErrors;// || (compileTime \u003e kMaxCompileTime);\r\n    elePubished.options[0].disabled = disableOptions;\r\n    elePubished.options[1].disabled = disableOptions;\r\n    if (disableOptions)\r\n    {\r\n        let str = \"You can only publish shaders that compile\";// in less that \" + Math.floor(kMaxCompileTime) + \" seconds\";\r\n        elePubished.options[0].title = str;\r\n        elePubished.options[1].title = str;\r\n    }\r\n    else\r\n    {\r\n        elePubished.options[0].title = \"\";\r\n        elePubished.options[1].title = \"\";\r\n    }\r\n}\r\n\r\nShaderToy.prototype.setCompilationTime = function()\r\n{\r\n    /*\r\n    if( this.mPass.length===1 )\r\n    {\r\n        let ti = this.mEffect.GetCompilationTime(0);\r\n        this.mEleCompilerTime.textContent = \"Compiled in \" + ti.toFixed(1) + \" secs\";\r\n    }\r\n    else\r\n    {\r\n        let lti = this.mEffect.GetCompilationTime(this.mActiveDoc);\r\n        let gti = this.mEffect.GetTotalCompilationTime();\r\n        this.mEleCompilerTime.textContent = \"Compiled in \" + lti.toFixed(1) + \" / \" + gti.toFixed(1) + \" secs\";\r\n    }\r\n    */\r\n    let ti = this.mEffect.GetTotalCompilationTime();\r\n    this.mEleCompilerTime.textContent = \"Compiled in \" + ti.toFixed(1) + \" secs\";\r\n}\r\n\r\nShaderToy.prototype.setFlags = function()\r\n{\r\n    if( this.mEffect===null ) return;\r\n\r\n    var flags = this.mEffect.calcFlags();\r\n/*\r\n    var eleVR = document.getElementById( \"myVR\" );\r\n    eleVR.style.visibility = ( flags.mFlagVR==true ) ? \"visible\" : \"hidden\";\r\n*/\r\n}\r\n\r\nShaderToy.prototype.showChars = function()\r\n{\r\n    let str = this.mCodeEditor.getValue();\r\n    str = minify( str );\r\n    let ve = document.getElementById(\"centerScreen\" );\r\n    doAlert( piGetCoords(ve), {mX:480,mY:-1}, \"Minimal Shader Code, (\" + str.length + \" chars)\", \"\u003cpre\u003e\"+htmlEntities(str)+\"\u003c/pre\u003e\", false, null );\r\n}\r\n\r\nShaderToy.prototype.ChangeTabLeft = function()\r\n{\r\n    var num = this.mEffect.GetNumPasses();\r\n    // find tab pointing to current pass\r\n    var i; for( i=0; i\u003cnum; i++ ) if( this.mTab2Pass[i] === this.mActiveDoc ) break;\r\n    // move left\r\n    i = (i - 1 + num ) % num;\r\n    // change\r\n    this.ChangePass( this.mTab2Pass[i]);\r\n}\r\n\r\nShaderToy.prototype.ChangeTabRight = function()\r\n{\r\n    var num = this.mEffect.GetNumPasses();\r\n    // find tab pointing to current pass\r\n    var i; for( i=0; i\u003cnum; i++ ) if( this.mTab2Pass[i] === this.mActiveDoc ) break;\r\n    // move right\r\n    i = (i + 1) % num;\r\n    // change\r\n    this.ChangePass( this.mTab2Pass[i]);\r\n}\r\n\r\nShaderToy.prototype.ChangePass = function( id )\r\n{\r\n    this.mActiveDoc = id;\r\n    this.mCodeEditor.swapDoc( this.mPass[id].mDocs );\r\n    this.setChars();\r\n    this.setCompilationTime();\r\n    this.SetErrors( this.mEffect.GetError(id), this.mEffect.GetErrorStr(id), false);\r\n    this.mEffect.UpdateInputs( id, true );\r\n\r\n    let num = this.mEffect.GetNumPasses();\r\n    for( let i=0; i\u003cnum; i++ )\r\n    {\r\n        let eleLab = document.getElementById( \"tab\" + i );\r\n        if( i===id )\r\n            eleLab.classList.add(\"selected\");\r\n        else\r\n            eleLab.classList.remove(\"selected\");\r\n    }\r\n\r\n    {\r\n    let passType = this.mEffect.GetPassType(id);\r\n    let ele = document.getElementById( \"textures\" );\r\n    ele.style.visibility = (passType === \"common\")?\"hidden\":\"visible\";\r\n\r\n    ele = document.getElementById( \"screenshotButton\" );\r\n    ele.style.visibility = (passType === \"sound\" || passType === \"buffer\" || passType === \"cubemap\") ? \"visible\" : \"hidden\";\r\n    }\r\n}\r\n\r\nShaderToy.prototype.KillPass = function( id )\r\n{\r\n    let ret = confirm(gStrWantDeletePass);\r\n    if (ret !== true)\r\n        return;\r\n\r\n    let wasCommon = (this.mEffect.GetPassType(id) === \"common\");\r\n\r\n    this.mNeedsSave = true;\r\n    this.mEffect.DestroyPass( id );\r\n    this.mPass.splice(id, 1);\r\n    this.BuildTabs();\r\n\r\n    let activePass = this.mActiveDoc;\r\n    if( activePass \u003e= id )\r\n    {\r\n        activePass--;\r\n        if( activePass\u003c0 ) activePass=0;\r\n    }\r\n\r\n    this.ChangePass(activePass);\r\n\r\n    this.SetShaderFromEditor(wasCommon, true);\r\n}\r\n\r\nShaderToy.prototype.AddPass = function(passType,passName, outputID)\r\n{\r\n    let iCompiled = function ()\r\n    {\r\n    };\r\n\r\n    let res = this.mEffect.AddPass( passType, passName, iCompiled );\r\n    let id = res.mId;\r\n\r\n    this.mEffect.SetOutputsByBufferID(id, 0, outputID );\r\n\r\n    this.mPass[id] = { mDocs: CodeMirror.Doc( res.mShader, \"text/x-glsl\"),\r\n                       mDirty: false,\r\n                       mCharCount: minify(res.mShader).length,\r\n                       mCharCountDirty: false };\r\n    this.BuildTabs();\r\n\r\n    this.ChangePass( id );\r\n    this.mNeedsSave = true;\r\n}\r\n\r\n//-------------------------\r\nconst kPassTypes = [\"common\", \"buffer\", \"cubemap\", \"image\", \"sound\"];\r\n\r\nShaderToy.prototype.AddPlusTabs = function( passes )\r\n{\r\n    var me = this;\r\n\r\n    var numS = this.mEffect.GetNumOfType( \"sound\" );\r\n    var numB = this.mEffect.GetNumOfType( \"buffer\" );\r\n    var numC = this.mEffect.GetNumOfType( \"common\" );\r\n    var numR = this.mEffect.GetNumOfType( \"cubemap\" );\r\n\r\n    if( numS\u003c1 || numB\u003c4 || numC\u003c1 || numR\u003c1)\r\n    {\r\n        var eleCon = document.createElement( \"div\" );\r\n        eleCon.className = \"tabAddContainer\";\r\n\r\n        var eleSel = document.createElement( \"select\" );\r\n        eleSel.className = \"tabAddSelect\";\r\n\r\n        var eleOpt = document.createElement(\"option\");\r\n        eleOpt.value = \"\";\r\n        eleOpt.text = \"\";\r\n        eleOpt.hidden = true;\r\n        eleSel.appendChild(eleOpt);\r\n\r\n        if( numC\u003c1 )\r\n        {\r\n            let eleOpt = document.createElement(\"option\");\r\n            eleOpt.value = 0;\r\n            eleOpt.text = \"Common\";\r\n            eleSel.appendChild(eleOpt);\r\n        }\r\n\r\n        if( numS\u003c1 )\r\n        {\r\n            let eleOpt = document.createElement(\"option\");\r\n            eleOpt.value = 1;\r\n            eleOpt.text = \"Sound\";\r\n            eleSel.appendChild(eleOpt);\r\n        }\r\n\r\n        if( numB\u003c4 )\r\n        {\r\n            for (let i=0; i\u003c4; i++ )\r\n            {\r\n                let isused = me.mEffect.IsBufferPassUsed( i );\r\n                if( isused ) continue;\r\n                let eleOpt = document.createElement(\"option\");\r\n                eleOpt.value = 2+i;\r\n                eleOpt.text = \"Buffer \" +  String.fromCharCode(65+i);\r\n                eleSel.appendChild(eleOpt);\r\n            }\r\n        }\r\n\r\n        if( numR\u003c1 )\r\n        {\r\n            let eleOpt = document.createElement(\"option\");\r\n            eleOpt.value = 6;\r\n            eleOpt.text = \"Cubemap A\";\r\n            eleSel.appendChild(eleOpt);\r\n        }\r\n\r\n        eleSel.onchange = function( ev ) \r\n                            { \r\n                                let val = parseInt( this.value );\r\n                                var outputID = null;\r\n                                var passType = \"common\";\r\n                                var passName = \"Common\";\r\n                                if( val === 0 )\r\n                                {\r\n                                    outputID = null;\r\n                                    passType = \"common\";\r\n                                    passName = \"Common\";\r\n                                }\r\n                                else if( val === 1)\r\n                                {\r\n                                    outputID = null;\r\n                                    passType = \"sound\";\r\n                                    passName = \"Sound\";\r\n                                }\r\n                                else if( val \u003e= 2 \u0026\u0026 val\u003c=5 )\r\n                                {\r\n                                    outputID = val - 2;\r\n                                    passType = \"buffer\";\r\n                                    passName = \"Buffer \" + String.fromCharCode(65+outputID);\r\n                                }\r\n                                else if( val === 6)\r\n                                {\r\n                                    outputID = 0;\r\n                                    passType = \"cubemap\";\r\n                                    passName = \"Cube \" + \"A\";\r\n                                }\r\n\r\n                                me.AddPass(passType, passName, outputID ); \r\n                                ev.stopPropagation();\r\n                            }\r\n\r\n        eleCon.appendChild( eleSel );\r\n\r\n        this.mPassParent.appendChild( eleCon );\r\n    }\r\n}\r\n\r\nShaderToy.prototype.AddTab = function( passType, passName, id )\r\n{\r\n    var me = this;\r\n\r\n    var eleTab = document.createElement( \"div\" );\r\n    eleTab.mNum = id;\r\n    eleTab.onclick = function( ev ) { me.ChangePass( this.mNum ); }\r\n    eleTab.id = \"tab\"+id;\r\n    eleTab.className = \"tab\";\r\n\r\n    if (this.mEffect.GetError(id) )\r\n    {\r\n        eleTab.classList.add(\"errorYes\");\r\n    }\r\n    else \r\n    {\r\n        eleTab.classList.remove(\"errorYes\");\r\n    }\r\n\r\n    {\r\n    let eleImg = document.createElement( \"img\" );\r\n    eleImg.className = \"tabImage\";\r\n    if( passType === \"sound\" )  eleImg.src = \"/img/music.png\";\r\n    if( passType === \"common\" ) eleImg.src = \"/img/common.png\";\r\n    if( passType === \"image\" )  eleImg.src = \"/img/image.png\";\r\n    if( passType === \"buffer\" ) eleImg.src = \"/img/buffer.png\";\r\n    if( passType === \"cubemap\" ) eleImg.src = \"/img/cubemap.png\";\r\n    eleTab.appendChild( eleImg );\r\n    }\r\n\r\n    {\r\n    var eleLab = document.createElement( \"label\" );\r\n    eleLab.textContent = passName;\r\n    eleTab.appendChild( eleLab );\r\n    }\r\n\r\n    if( passType !== \"image\" )\r\n    {\r\n      let eleImg = document.createElement( \"img\" );\r\n      eleImg.src = \"/img/closeSmall.png\";\r\n      eleImg.className = \"tabClose\";\r\n      eleImg.mNum = id;\r\n      eleImg.onclick = function( ev ) { me.KillPass( this.mNum ); ev.stopPropagation();}\r\n      eleTab.appendChild( eleImg );\r\n    }\r\n\r\n    this.mPassParent.appendChild( eleTab );\r\n}\r\n\r\nShaderToy.prototype.BuildTabs = function()\r\n{\r\n    this.mPassParent.innerHTML = '';\r\n    this.AddPlusTabs();\r\n\r\n    const num = this.mEffect.GetNumPasses();\r\n\r\n    this.mTab2Pass = [];\r\n    let n = 0;\r\n    for (let j = 0; j \u003c 5; j++)\r\n    {\r\n        for (let i = 0; i \u003c num; i++)\r\n        {\r\n            var passType = this.mEffect.GetPassType(i);\r\n            if (passType !== kPassTypes[j] ) continue;\r\n            var passName = this.mEffect.GetPassName(i);\r\n            this.AddTab(passType, passName, i);\r\n            this.mTab2Pass[n++] = i;\r\n        }\r\n    }\r\n}\r\n\r\nShaderToy.prototype.Load = function( jsn, preventCache, doResolve )\r\n{\r\n    try\r\n    {\r\n        this.mEleCompilerTime.textContent = \"Compiling...\";\r\n\r\n        let me = this;\r\n\r\n        if (!this.mEffect.Load(jsn)) return;\r\n\r\n        this.mPass = [];\r\n\r\n        var num = this.mEffect.GetNumPasses();\r\n        for( let i=0; i\u003cnum; i++ )\r\n        {\r\n            let shaderCode = this.mEffect.GetCode(i);\r\n            this.mPass[i] = { mDocs:   CodeMirror.Doc( shaderCode, \"text/x-glsl\"),\r\n                              mDirty:  false,\r\n                              mCharCount: minify(shaderCode).length,\r\n                              mCharCountDirty: false\r\n                             };\r\n        }\r\n        this.mCodeEditor.clearHistory()\r\n        this.BuildTabs();\r\n        this.ChangePass(0);\r\n        this.setSaveOptions(true);\r\n        this.resetTime();\r\n\r\n        this.UIStartCompiling(true);\r\n        this.mEffect.Compile(true /*true due to crash reporting*/, function(worked)\r\n        {\r\n            me.UIEndCompiling(true);\r\n\r\n            let compilationTime = me.mEffect.GetTotalCompilationTime();\r\n            if (!gIsMyShader \u0026\u0026 (compilationTime \u003e kMaxCompileTime)) {\r\n                iReportCrash(gShaderID);\r\n            }\r\n        });\r\n\r\n        this.mInfo = jsn.info;\r\n\r\n        return { mDownloaded  : true,\r\n                 mDate        : jsn.info.date,\r\n                 mViewed      : jsn.info.viewed,\r\n                 mName        : jsn.info.name,\r\n                 mUserName    : jsn.info.username,\r\n                 mDescription : jsn.info.description,\r\n                 mLikes       : jsn.info.likes,\r\n                 mPublished   : jsn.info.published,\r\n                 mHasLiked    : jsn.info.hasliked,\r\n                 mTags        : jsn.info.tags,\r\n                 mParentId    : jsn.info.parentid,\r\n                 mParentName  : jsn.info.parentname };\r\n    }\r\n    catch( e )\r\n    {\r\n        console.log( e );\r\n    }\r\n}\r\n\r\nShaderToy.prototype.Save = function()\r\n{\r\n    var res = this.mEffect.Save();\r\n\r\n    if( this.mNeedsSave )\r\n    {\r\n        for( let i=0; i\u003cres.renderpass.length; i++ )\r\n        {\r\n            res.renderpass[i].code = this.mPass[i].mDocs.getValue();\r\n        }\r\n    }\r\n\r\n    res.info = this.mInfo;\r\n\r\n    return res;\r\n}\r\n\r\n// TODO: move this to Effect\r\nShaderToy.prototype.CheckShaderCorrectness = function ()\r\n{\r\n    let numPasses = this.mEffect.GetNumPasses();\r\n    let countImage = 0;\r\n    let countCommon = 0;\r\n    let countSound = 0;\r\n    let countCubemap = 0;\r\n    let countBuffer = 0;\r\n    for (let j = 0; j \u003c numPasses; j++)\r\n    {\r\n        let passType = this.mEffect.GetPassType(j);\r\n        if (passType === \"image\"  ) countImage++;\r\n        if (passType === \"common\" ) countCommon++;\r\n        if (passType === \"sound\"  ) countSound++;\r\n        if (passType === \"cubemap\") countCubemap++;\r\n        if (passType === \"buffer\" ) countBuffer++;\r\n    }\r\n    if (countImage !== 1) return false;\r\n    if (countCommon  \u003e 1) return false;\r\n    if (countSound   \u003e 1) return false;\r\n    if (countCubemap \u003e 1) return false;\r\n    if (countBuffer  \u003e 4) return false;\r\n    return true;\r\n}\r\n//----------------------------------------------------------------------------\r\n\r\nvar gShaderToy = null;\r\nvar gCode = null;\r\nvar gIsLiked = 0;\r\nvar gRes = null;\r\n\r\nfunction loadNew()\r\n{\r\n    const kk = {\r\n\t\"ver\" : \"0.1\",\r\n\t\"info\" : { \"id\":\"-1\", \"date\":\"1358124981\", \"viewed\":0, \"name\":\"\", \"username\": \"None\", \"description\":\"\", \"likes\":0, \"hasliked\":0, \"tags\":[], \"published\":0 },\r\n    \"flags\" : { \"mFlagVR\" : \"false\", \"mFlagWebcam\" : \"false\", \"mFlagSoundInput\" : \"false\", \"mFlagSoundOutput\" : \"false\", \"mFlagKeyboard\" : \"false\" },\r\n\t\"renderpass\": [ { \"inputs\": [], \"outputs\": [ {\"channel\":0, \"id\":\"4dfGRr\" } ], \"type\":\"image\", \"code\": \"void mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n    // Normalized pixel coordinates (from 0 to 1)\\n    vec2 uv = fragCoord/iResolution.xy;\\n\\n    // Time varying pixel color\\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\\n\\n    // Output to screen\\n    fragColor = vec4(col,1.0);\\n}\", \"name\":\"\", \"description\":\"\" } ]\r\n\t};\r\n    iLoadShader( [kk] );\r\n}\r\n\r\n//======= minify ==========================\r\n\r\nfunction minify( str )\r\n{\r\n    function isSpace( str, i ) { return (str[i]===' ') || (str[i]==='\\t'); }\r\n    function isLine( str, i ) { return (str[i]==='\\n'); }\r\n    function replaceChars(str)\r\n    {\r\n        var dst = \"\";\r\n        var num = str.length;\r\n        var isPreprocessor = false;\r\n        for( let i=0; i\u003cnum; i++ )\r\n        {\r\n                 if( str[i]==='#'  ) { isPreprocessor = true; }\r\n            else if( str[i]==='\\n' ) {  if( isPreprocessor ) { isPreprocessor = false; } else { dst = dst + \" \"; continue; } }\r\n            else if( str[i]==='\\r' ) { dst = dst + \" \"; continue; }\r\n            else if( str[i]==='\\t' ) { dst = dst + \" \"; continue; }\r\n            else if( i\u003c(num-1) \u0026\u0026 str[i]==='\\\\' \u0026\u0026 str[i+1]==='\\n') { i+=1; continue; }\r\n            dst = dst + str[i];\r\n        }\r\n        return dst;\r\n    }\r\n    function removeEmptyLines(str)\r\n    {\r\n        var dst = \"\";\r\n        var num = str.length;\r\n        var isPreprocessor = false;\r\n        for( var i=0; i\u003cnum; i++ )\r\n        {\r\n            if( str[i]==='#' ) isPreprocessor = true;\r\n            var isDestroyableChar = isLine(str,i);\r\n            if( isDestroyableChar \u0026\u0026 !isPreprocessor ) continue;\r\n            if( isDestroyableChar \u0026\u0026  isPreprocessor ) isPreprocessor = false;\r\n            dst = dst + str[i];\r\n        }\r\n        return dst;\r\n    }\r\n    function removeMultiSpaces(str)\r\n    {\r\n        var dst = \"\";\r\n        var num = str.length;\r\n        for( var i=0; i\u003cnum; i++ )\r\n        {\r\n            if( isSpace(str,i) \u0026\u0026 (i===(num-1)) ) continue;\r\n            if( isSpace(str,i) \u0026\u0026 isLine(str,i-1) ) continue;\r\n            if( isSpace(str,i) \u0026\u0026 isLine(str,i+1) ) continue;\r\n            if( isSpace(str,i) \u0026\u0026 isSpace(str,i+1) ) continue;\r\n            dst = dst + str[i];\r\n        }\r\n        return dst;\r\n    }\r\n    function removeSingleSpaces(str)\r\n    {\r\n        var dst = \"\";\r\n        var num = str.length;\r\n        for( var i=0; i\u003cnum; i++ )\r\n        {\r\n            var iss = isSpace(str,i);\r\n            if( i===0 \u0026\u0026 iss ) continue;\r\n\r\n            if( i\u003e0 )\r\n            {\r\n            if( iss \u0026\u0026 ( ( str[i-1]===';' ) || ( str[i-1]===',' ) || ( str[i-1]==='}' ) || ( str[i-1]==='{' ) ||\r\n                         ( str[i-1]==='(' ) || ( str[i-1]===')' ) || ( str[i-1]==='+' ) || ( str[i-1]==='-' ) ||\r\n                         ( str[i-1]==='*' ) || ( str[i-1]==='/' ) || ( str[i-1]==='?' ) || ( str[i-1]==='\u003c' ) ||\r\n                         ( str[i-1]==='\u003e' ) || ( str[i-1]==='[' ) || ( str[i-1]===']' ) || ( str[i-1]===':' ) ||\r\n                         ( str[i-1]==='=' ) || ( str[i-1]==='^' ) || ( str[i-1]==='%' ) || ( str[i-1]==='\\n' ) ||\r\n                         ( str[i-1]==='\\r' ) ) ) continue;\r\n            }\r\n            if( i\u003e1 )\r\n            {\r\n                if( iss \u0026\u0026 ( ( str[i-1]==='\u0026' ) \u0026\u0026 ( str[i-2]==='\u0026' ) ) ) continue;\r\n                if( iss \u0026\u0026 ( ( str[i-1]==='|' ) \u0026\u0026 ( str[i-2]==='|' ) ) ) continue;\r\n                if( iss \u0026\u0026 ( ( str[i-1]==='^' ) \u0026\u0026 ( str[i-2]==='^' ) ) ) continue;\r\n                if( iss \u0026\u0026 ( ( str[i-1]==='!' ) \u0026\u0026 ( str[i-2]==='=' ) ) ) continue;\r\n                if( iss \u0026\u0026 ( ( str[i-1]==='=' ) \u0026\u0026 ( str[i-2]==='=' ) ) ) continue;\r\n            }\r\n\r\n            if( iss \u0026\u0026 ( ( str[i+1]===';' ) || ( str[i+1]===',' ) || ( str[i+1]==='}' ) || ( str[i+1]==='{' ) ||\r\n                         ( str[i+1]==='(' ) || ( str[i+1]===')' ) || ( str[i+1]==='+' ) || ( str[i+1]==='-' ) ||\r\n                         ( str[i+1]==='*' ) || ( str[i+1]==='/' ) || ( str[i+1]==='?' ) || ( str[i+1]==='\u003c' ) ||\r\n                         ( str[i+1]==='\u003e' ) || ( str[i+1]==='[' ) || ( str[i+1]===']' ) || ( str[i+1]===':' ) ||\r\n                         ( str[i+1]==='=' ) || ( str[i+1]==='^' ) || ( str[i+1]==='%' ) || ( str[i+1]==='\\n' ) ||\r\n                         ( str[i+1]==='\\r' ) ) ) continue;\r\n            if( i\u003c(num-2) )\r\n            {\r\n                if( iss \u0026\u0026 ( ( str[i+1]==='\u0026' ) \u0026\u0026 ( str[i+2]==='\u0026' ) ) ) continue;\r\n                if( iss \u0026\u0026 ( ( str[i+1]==='|' ) \u0026\u0026 ( str[i+2]==='|' ) ) ) continue;\r\n                if( iss \u0026\u0026 ( ( str[i+1]==='^' ) \u0026\u0026 ( str[i+2]==='^' ) ) ) continue;\r\n                if( iss \u0026\u0026 ( ( str[i+1]==='!' ) \u0026\u0026 ( str[i+2]==='=' ) ) ) continue;\r\n                if( iss \u0026\u0026 ( ( str[i+1]==='=' ) \u0026\u0026 ( str[i+2]==='=' ) ) ) continue;\r\n            }\r\n            dst = dst + str[i];\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    function removeComments( str )\r\n    {\r\n        var dst = \"\";\r\n        var num = str.length;\r\n        var state = 0;\r\n        for( var i=0; i\u003cnum; i++ )\r\n        {\r\n            if( i\u003c=(num-2) )\r\n            {\r\n                if( state===0 \u0026\u0026 str[i]==='/' \u0026\u0026 str[i+1]==='*' ) { state = 1; i+=1; continue; }\r\n                if( state===0 \u0026\u0026 str[i]==='/' \u0026\u0026 str[i+1]==='/' ) { state = 2; i+=1; continue; }\r\n                if( state===1 \u0026\u0026 str[i]===\"*\" \u0026\u0026 str[i+1]===\"/\" ) { dst += ' '; state = 0; i+=1; continue; }\r\n                if( state===2 \u0026\u0026 (str[i]===\"\\r\" || str[i]===\"\\n\") ) { state = 0; continue; }\r\n            }\r\n            if( state===0 )\r\n                dst = dst + str[i];\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    str = removeComments( str );\r\n    str = replaceChars( str  );\r\n    str = removeMultiSpaces( str );\r\n    str = removeSingleSpaces( str );\r\n    str = removeEmptyLines( str );\r\n    return str;\r\n}\r\n\r\n//======= minify ==========================\r\n\r\nfunction loadComments()\r\n{\r\n    try\r\n    {\r\n        var httpReq = new XMLHttpRequest();\r\n        httpReq.onload = function()\r\n        {\r\n            var jsn = httpReq.response;\r\n            updatepage( jsn );\r\n        };\r\n        httpReq.open( \"POST\", \"/comment\", true );\r\n        httpReq.responseType = \"json\";\r\n        httpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n        httpReq.send( \"s=\" + gShaderID );\r\n    }\r\n    catch(e)\r\n    {\r\n        return;\r\n    }\r\n}\r\n\r\nfunction iLoadShader( jsnShader )\r\n{\r\n    gRes = gShaderToy.Load( jsnShader[0], gIsMyShader );\r\n    if( gRes.mDownloaded === false )\r\n        return;\r\n\r\n    document.title = (gRes.mName===\"\") ? \"New\" : gRes.mName;\r\n\r\n    var st = document.getElementById( \"shaderTitle\" );      if( st ) { if( st.value === undefined ) { st.textContent = gRes.mName; st.title = gRes.mName; } else { st.value = gRes.mName;       } }\r\n    var sd = document.getElementById( \"shaderDescription\"); if( sd ) { if( sd.value === undefined ) { sd.innerHTML = bbc2html(htmlEntities(gRes.mDescription),false); } else { sd.value = gRes.mDescription;} }\r\n    var sp = document.getElementById( \"published\" );\r\n    if( sp \u0026\u0026 sp!== undefined )\r\n    {\r\n        sp.selectedIndex = 2;\r\n        for (let i = 0; i \u003c sp.length; i++)\r\n        {\r\n            let option = sp.options[i];\r\n\r\n            if (option.value == gRes.mPublished)\r\n            {\r\n                sp.selectedIndex = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    updateLikes();\r\n    var timeVar = \"-\";\r\n    if( gRes.mDate !== 0 )\r\n    {\r\n        timeVar = piGetTime(gRes.mDate);\r\n    }\r\n\r\n    var shaderAuthorName = document.getElementById( \"shaderAuthorName\"); \r\n    if( shaderAuthorName) \r\n    {\r\n        if (gRes.mUserName!==\"\") shaderAuthorName.innerHTML = \"\u003ca class='user' href='/user/\" + htmlEntities(gRes.mUserName) +\"'\u003e\" + htmlEntities(gRes.mUserName) + \"\u003c/a\u003e\";\r\n        else shaderAuthorName.innerHTML = \"anonymous user\";\r\n    }\r\n    var shaderAuthorDate = document.getElementById( \"shaderAuthorDate\"); \r\n    if( shaderAuthorDate ) shaderAuthorDate.innerHTML = timeVar;\r\n\r\n    var txtHtml = \"\";\r\n    var txtPlain = \"\";\r\n    var numTags = gRes.mTags.length;\r\n    for( let i=0; i\u003cnumTags; i++ )\r\n    {\r\n        txtHtml += \"\u003ca class='user' href='/results?query=tag%3D\" + htmlEntities(gRes.mTags[i]) + \"'\u003e\" + htmlEntities(gRes.mTags[i]) + \"\u003c/a\u003e\";\r\n        txtPlain += gRes.mTags[i];\r\n        if( i !== (numTags-1) ) { txtHtml += \", \"; txtPlain += \", \"; }\r\n    }\r\n    var sts = document.getElementById( \"shaderTags\"); if( sts ) { if( sts.value === undefined ) sts.innerHTML = txtHtml; else sts.value = txtPlain; }\r\n\r\n    var shareShader = document.getElementById(\"shaderShare\");\r\n\r\n    // like\r\n    var shaderLike = document.getElementById(\"shaderLike\");\r\n    if( shaderLike !== null )\r\n    {\r\n        gIsLiked = gRes.mHasLiked;\r\n        updateLikes();\r\n        shaderLike.onclick = function()\r\n        {\r\n            var url = \"s=\" + gShaderID + \"\u0026l=\" + ((gIsLiked==1)?0:1);\r\n            var mHttpReq = new XMLHttpRequest();\r\n            mHttpReq.open( \"POST\", \"/shadertoy\", true );\r\n            mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n            mHttpReq.onload = function()\r\n            {\r\n                var jsn = mHttpReq.response;\r\n                if( jsn===null ) return;\r\n                if( jsn.result!==0 )\r\n                {\r\n                    if( gIsLiked===1 ) gRes.mLikes--; else gRes.mLikes++;\r\n                    gIsLiked = 1 - gIsLiked;\r\n                    updateLikes();\r\n                }\r\n            }\r\n            mHttpReq.send( url );\r\n        }\r\n    }\r\n\r\n    // Forked\r\n    var shaderForkedFrom = document.getElementById(\"shaderForkedFrom\");\r\n    if (shaderForkedFrom !== null ) {\r\n        if (gRes.mParentId !== \"\" ) {\r\n            if  (gRes.mParentName !== \"\") {\r\n                shaderForkedFrom.innerHTML = gStrFork + \" \u003ca class='user' href='/view/\" + gRes.mParentId + \"'\u003e\" + gRes.mParentName + \"\u003c/a\u003e\";\r\n            } else {\r\n                shaderForkedFrom.innerHTML = gStrForkDeleted;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction loadShader()\r\n{\r\n    gShaderToy.mState = 0;\r\n\r\n    try\r\n    {\r\n        var httpReq = new XMLHttpRequest();\r\n        httpReq.addEventListener( 'load', function ( event ) \r\n        { \r\n            var jsnShader = event.target.response;\r\n            if (jsnShader === null) { alert(\"Error loading shader\"); return; };\r\n            gShaderToy.mState = 1;\r\n            iLoadShader( jsnShader );\r\n        }, false );\r\n        httpReq.addEventListener( 'error', function () { alert( \"Error loading shader\" ); }, false );\r\n\r\n        httpReq.open( \"POST\", \"/shadertoy\", true );\r\n        httpReq.responseType = \"json\";\r\n        httpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n        var str = \"{ \\\"shaders\\\" : [\\\"\" + gShaderID + \"\\\"] }\";\r\n        str = \"s=\" + encodeURIComponent(str) + \"\u0026nt=1\u0026nl=1\u0026np=1\";\r\n        httpReq.send( str  );\r\n    }\r\n    catch(e)\r\n    {\r\n         return;\r\n    }\r\n}\r\n\r\nfunction watchInit()\r\n{\r\n    var editorParent = document.getElementById(\"editor\");\r\n    var viewerParent = document.getElementById(\"player\");\r\n    var passParent   = document.getElementById(\"passManager\")\r\n\r\n    // cancel/intercept browsers special keys\r\n    document.addEventListener(\"keydown\",function(e)\r\n    {\r\n        // intercept BACKSPACE\r\n        if( e.keyCode===8 )\r\n        {\r\n            var ele = piGetSourceElement(e);\r\n\r\n            if( ele.nodeName === \"BODY\")\r\n            {\r\n                e.preventDefault();\r\n                return;\r\n            }\r\n\r\n            if( ele.id === \"demogl\" )\r\n            {\r\n                var me = gShaderToy;\r\n                me.mEffect.SetKeyDown( me.mActiveDoc, e.keyCode );\r\n                if( me.mIsPaused ) me.mForceFrame = true;\r\n            }\r\n        }\r\n        // intercept CTRL+S (save the web page to disk)\r\n        else if( e.keyCode===83 \u0026\u0026 (navigator.platform.match(\"Mac\")?e.metaKey:e.ctrlKey))\r\n        {\r\n            e.preventDefault();\r\n        }/*\r\n        // intercept browsers default behaviour for CTRL+F (search)\r\n        else if(e.keyCode===70 \u0026\u0026 (navigator.platform.match(\"Mac\")?e.metaKey:e.ctrlKey))\r\n        {\r\n            e.preventDefault();\r\n        }*/\r\n    }, false);\r\n\r\n    // cancel/intercept browsers default behaviour for ALT+LEFT (prev URL)\r\n    if( !navigator.platform.match(\"Mac\") )\r\n        document.addEventListener(\"keydown\",function(e){if(e.keyCode==37 \u0026\u0026 e.altKey){e.preventDefault();}}, false);\r\n\r\n    // prevent unloading page without saving changes to shader\r\n    window.onbeforeunload = function(e) { if( gShaderToy!==null \u0026\u0026 gShaderToy.GetNeedSave() ) return \"You are about to lose your changes in the code editor.\"; };\r\n\r\n    gShaderToy = new ShaderToy( viewerParent, editorParent, passParent );\r\n    if( !gShaderToy.mCreated )\r\n        return;\r\n\r\n    gShaderToy.setFontSize(gFontSize, false);\r\n\r\n    //-- get info --------------------------------------------------------\r\n\r\n    if( gShaderID===null )\r\n    {\r\n         loadNew();\r\n    }\r\n    else\r\n    {\r\n         loadComments( gShaderID );\r\n         loadShader( gShaderID );\r\n    }\r\n}\r\n\r\nfunction updateLikes()\r\n{\r\n    var shaderLike = document.getElementById(\"shaderLike\");\r\n    if( shaderLike!==null )\r\n    {\r\n        if( gIsLiked==1 )\r\n        {\r\n            shaderLike.src = \"/img/themes/\" + gThemeName + \"/likeYes.png\";\r\n        }\r\n        else\r\n        {\r\n            shaderLike.src = \"/img/themes/\" + gThemeName + \"/likeNo.png\";\r\n        }\r\n    }\r\n\r\n    var shaderStatsViewed  = document.getElementById( \"shaderStatsViewed\" );   if( shaderStatsViewed  )   shaderStatsViewed.innerHTML = \"\" + gRes.mViewed;\r\n    var shaderStatsLikes   = document.getElementById( \"shaderStatsLikes\" );    if( shaderStatsLikes  )    shaderStatsLikes.innerHTML = \"\" + gRes.mLikes;\r\n    var shaderStatsPrivacy = document.getElementById( \"shaderStatsPrivacy\" );  \r\n    if( shaderStatsPrivacy ) \r\n    {\r\n        if (gRes.mPublished == 2) \r\n        {\r\n            shaderStatsPrivacy.innerHTML = \", Unlisted\";\r\n        }\r\n    }\r\n} \r\n\r\nfunction updatepage( jsn )\r\n{\r\n    var txt = \"\";\r\n    var numComments = jsn.text ? jsn.text.length : 0;\r\n    var shaderStatsComments = document.getElementById( \"shaderStatsComments\" ); if( shaderStatsComments  ) shaderStatsComments.innerHTML = \"\" + numComments;\r\n\r\n    for( var i=0; i\u003cnumComments; i++ )\r\n    {\r\n    \tvar timeVar = \"-\";\r\n        if( jsn.date[i] != 0 )\r\n        {\r\n\t        timeVar = piGetTime(jsn.date[i]);\r\n        }\r\n        \r\n        if( jsn.username[i]===gUserName )\r\n        {\r\n            txt += \"\u003cdiv class=\\\"commentSelf\\\"\u003e\";\r\n        }\r\n        else \r\n        {\r\n            txt += \"\u003cdiv class=\\\"comment\\\"\u003e\";\r\n        }\r\n        txt +=   \"\u003cdiv\u003e\u003cimg class=\\\"userPictureSmall\\\" src=\\\"\" + jsn.userpicture[i] + \"\\\"\u003e\u003c/img\u003e\u003c/div\u003e\";\r\n        txt +=   \"\u003cdiv class=\\\"commentContent\\\"\u003e\u003ca class='user' href='/user/\"+ htmlEntities(jsn.username[i]) +\"'\u003e\" + htmlEntities(jsn.username[i]) + \"\u003c/a\u003e, \" + timeVar + \"\u003cbr\u003e\";\r\n        if( jsn.hidden[i]==1) txt += \"\u003ci\u003e\";\r\n        txt +=  bbc2html(htmlEntities(jsn.text[i]),true);\r\n        if( jsn.hidden[i]==1) txt += \"\u003c/i\u003e\";\r\n        txt +=   \"\u003c/div\u003e\";\r\n        if( gIsMyShader )\r\n        txt +=   \"\u003cdiv class='uiDivBUtton' title='\" + ((jsn.hidden[i]==1)?\"Unhide this comment\":\"Hide this comment from all users. You can always unhide it again at a later time.\") + \"' onclick='hideComment(\\\"\" + jsn.id[i] + \"\\\",\" + ((jsn.hidden[i]==1)?\"0\":\"1\") + \");'\u003e\" + ((jsn.hidden[i]==1)?\"unhide\":\"x\") + \"\u003c/div\u003e\";\r\n\r\n        txt += \"\u003c/div\u003e\";\r\n    }\r\n\r\n    var cc = document.getElementById(\"myComments\");      if( cc ) cc.innerHTML = txt;\r\n    var dd = document.getElementById(\"commentTextArea\"); if( dd ) dd.value = \"\";\r\n}\r\n\r\nfunction hideComment(commentid, hidden)\r\n{\r\n\tvar xmlHttp = new XMLHttpRequest();\r\n    if( xmlHttp===null ) return;\r\n    var url = \"s=\" + gShaderID + \"\u0026c=\" + commentid + \"\u0026hide=\" + hidden;\r\n\r\n    xmlHttp.open('POST', \"/comment\", true);\r\n    xmlHttp.responseType = \"json\";\r\n    xmlHttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n    xmlHttp.timeout = 15000; // 15 seconds\r\n    xmlHttp.ontimeout = function()\r\n    {\r\n        var ve = document.getElementById(\"centerScreen\" );\r\n        doAlert( piGetCoords(ve), {mX:320,mY:-1}, \"Error\", \"We are sorry, we couldn't (un)hide the comment\", false, null );\r\n        // reenable comment input elements\r\n        form.mybutton.disabled = false;\r\n        form.comment.disabled = false;\r\n    }\r\n\r\n    xmlHttp.onload = function()\r\n    {\r\n        var jsn = xmlHttp.response;\r\n        if( jsn.hide \u0026\u0026 jsn.hide!=0 )\r\n        {\r\n            updatepage( jsn );\r\n        }\r\n        else\r\n        {\r\n            var ve = document.getElementById(\"centerScreen\" );\r\n            doAlert( piGetCoords(ve), {mX:320,mY:-1}, \"Error\", \"We are sorry, we couldn't (un)hide the comment\", false, null );\r\n        }\r\n        //form.mybutton.disabled = false;\r\n        //form.comment.disabled = false;\r\n    }\r\n\r\n    xmlHttp.onerror = function()\r\n    {\r\n        var ve = document.getElementById(\"centerScreen\" );\r\n        doAlert( piGetCoords(ve), {mX:320,mY:-1}, \"Error\", \"We are sorry, we couldn't submit your comment\", false, null );\r\n        //form.mybutton.disabled = false;\r\n        //form.comment.disabled = false;\r\n    }\r\n    xmlHttp.send(url);\r\n}\r\n\r\nfunction addComment(usr, form)\r\n{\r\n\tvar xmlHttp = new XMLHttpRequest();\r\n    if( xmlHttp===null ) return;\r\n\r\n    // disable comment input elements while we process the comment submision\r\n    form.mybutton.disabled = true;\r\n    form.comment.disabled = true;\r\n\r\n    // encode comments\r\n    var commentsformated = form.comment.value;\r\n    commentsformated = encodeURIComponent( commentsformated );\r\n\r\n    var url = \"s=\" + usr +\"\u0026comment=\" + commentsformated;\r\n    xmlHttp.open('POST', \"/comment\", true);\r\n    xmlHttp.responseType = \"json\";\r\n    xmlHttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n    xmlHttp.timeout = 60000; // 60 seconds\r\n    xmlHttp.ontimeout = function()\r\n    {\r\n        var ve = document.getElementById(\"centerScreen\" );\r\n        doAlert( piGetCoords(ve), {mX:320,mY:-1}, \"Error\", \"We are sorry, we couldn't submit your comment\", false, null );\r\n        // reenable comment input elements\r\n        form.mybutton.disabled = false;\r\n        form.comment.disabled = false;\r\n    }\r\n\r\n    xmlHttp.onload = function()\r\n    {\r\n        var jsn = xmlHttp.response;\r\n        if( jsn.added \u0026\u0026 jsn.added\u003e0 )\r\n        {\r\n            updatepage( jsn );\r\n        }\r\n        else\r\n        {\r\n            var ve = document.getElementById(\"centerScreen\" );\r\n\r\n            if (jsn.added \u0026\u0026 jsn.added == -1) {\r\n                doAlert( piGetCoords(ve), {mX:320,mY:-1}, \"Account verification required\", \"The comment could not be shared. Your account is not verified, please go to your Shadertoy profile for instructions.\", false, null );\r\n            } else if (jsn.added \u0026\u0026 jsn.added == -3) {\r\n                doAlert( piGetCoords(ve), {mX:400,mY:-1}, \"Reached maximum of daily comments\", \"The comment could not be shared. You have reached the maximum daily comments allowed with your current status. If you want to keep improving your status, participate more actively in the Shadertoy community. Please go to your Shadertoy profile for more details.\", false, null );\r\n            } else {\r\n                doAlert( piGetCoords(ve), {mX:320,mY:-1}, \"Error\", \"We are sorry, we couldn't submit your comment\", false, null );                \r\n            }\r\n        }\r\n        // reenable comment input elements\r\n        form.mybutton.disabled = false;\r\n        form.comment.disabled = false;\r\n    }\r\n\r\n    xmlHttp.onerror = function()\r\n    {\r\n        var ve = document.getElementById(\"centerScreen\" );\r\n        doAlert( piGetCoords(ve), {mX:320,mY:-1}, \"Error\", \"We are sorry, we couldn't submit your comment\", false, null );\r\n        // reenable comment input elements\r\n        form.mybutton.disabled = false;\r\n        form.comment.disabled = false;\r\n    }\r\n    xmlHttp.send(url);\r\n}\r\n\r\nfunction checkFormComment(str)\r\n{\r\n    if( str == \"\" )\r\n    {\r\n        var ve = document.getElementById(\"centerScreen\" );\r\n        doAlert( piGetCoords(ve), {mX:320,mY:-1}, \"Error\", \"You need to write at least 1 character\", false, null );\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction validateComment( form )\r\n{\r\n   if(checkFormComment( form.comment.value ))\r\n   {\r\n        addComment(gShaderID, form);\r\n        return true;\r\n   }\r\n   form.comment.focus();\r\n   return false;\r\n}\r\n\r\nfunction shaderSaved( res, savedID, isUpdate, dataJSON )\r\n{\r\n    const ve = document.getElementById(\"centerScreen\" );\r\n    if( res===0 )\r\n    {\r\n        gShaderToy.SetNeedSave( false );\r\n        if( isUpdate )\r\n        {\r\n            var eleWrapper = document.getElementById('editor');\r\n            eleWrapper.classList.add(\"saved\");\r\n            setTimeout( function () { eleWrapper.classList.remove(\"saved\"); }, 500 );\r\n        }\r\n        else\r\n        {\r\n            window.location=\"/view/\" + savedID;\r\n        }\r\n\t}\r\n    else if( res===-2 ) { doAlert( piGetCoords(ve), {mX:400,mY:-1}, \"Error\", \"Shader name \\\"\" +  dataJSON.info.name + \"\\\" is already used by another shader. Please change the name of your shader.\", false, null ); }\r\n    else if( res===-3 ) { doAlert( piGetCoords(ve), {mX:400,mY:-1}, \"Error\", \"The shader could not be \" + (isUpdate?\"updated\":\"added\") + \", you might not be logged in anymore, please Sign In again.\", false, null); }\r\n    else if( res===-13) { doAlert( piGetCoords(ve), {mX:400,mY:-1}, \"Error\", \"The shader coubld not be saved, it is using private assets.\", false, null); }\r\n    else if( res===-15) { doAlert( piGetCoords(ve), {mX:400,mY:-1}, \"Account verification required\", \"The shader could not be published. Your account is not verified, please go to your Shadertoy profile for instructions.\", false, null ); }\r\n    else if( res===-16) { doAlert( piGetCoords(ve), {mX:400,mY:-1}, \"Reached maximum of daily shaders\", \"The shader could not be published. You have reached the maximum daily shaders allowed with your current status. If you want to keep improving your status, participate more actively in the Shadertoy community. Please go to your Shadertoy profile for more details.\", false, null ); }\r\n    else                { doAlert( piGetCoords(ve), {mX:400,mY:-1}, \"Error\", \"The shader could not be \" + (isUpdate?\"updated\":\"added\") + \", please try again. Error code : \" + res, false, null); }\r\n}\r\n\r\nfunction openSubmitShaderForm( isUpdate )\r\n{\r\n    if (gShaderToy.mState !== 1) return;\r\n\r\n    var ve = document.getElementById(\"centerScreen\" );\r\n    var s1 = document.getElementById('shaderTitle');\r\n    var s2 = document.getElementById('shaderTags');\r\n    var s3 = document.getElementById('shaderDescription');\r\n\r\n    if( !s1.validity.valid ) { doAlert( piGetCoords(ve), {mX:320,mY:-1}, \"Error\", \"You must give a name to your shader\", false, null ); return; }\r\n    if( !s2.validity.valid ) { doAlert( piGetCoords(ve), {mX:320,mY:-1}, \"Error\", \"You must assign at least one tag to your shader\", false, null ); return; }\r\n    if( !s3.validity.valid ) { doAlert( piGetCoords(ve), {mX:320,mY:-1}, \"Error\", \"You must give a description to your shader\", false, null ); return; }\r\n    if( !checkFormComment(s1.value) ) return false;\r\n    if( !checkFormComment(s3.value) ) return false;\r\n    if (!gShaderToy.CheckShaderCorrectness()) { doAlert(piGetCoords(ve), { mX: 400, mY: -1 }, \"Error\", \"The shader can not be saved. Too many Image passes.\", false, null); return; }\r\n\r\n    gShaderToy.setActionsState(false);\r\n\r\n    var sp = document.getElementById('published');\r\n    const publishedStatus = sp.options[ sp.selectedIndex ].value;\r\n    if( publishedStatus===1 || publishedStatus===3 )\r\n    {\r\n        gShaderToy.SetShaderFromEditor(true,false)\r\n        if (!gShaderToy.AllowPublishing() )\r\n        {\r\n            let ve = document.getElementById(\"centerScreen\" );\r\n            doAlert( piGetCoords(ve), {mX:400,mY:-1}, \"Error\", \"The shader can not be published. It does not compile.\", false, null );\r\n            gShaderToy.setActionsState(true);\r\n            gShaderToy.mState = 1;\r\n            return false;\r\n        }\r\n\r\n        let compileTime = gShaderToy.GetTotalCompilationTime();\r\n        if (compileTime \u003e kMaxCompileTime)\r\n        {\r\n            let ve = document.getElementById(\"centerScreen\");\r\n            doAlert(piGetCoords(ve), { mX: 400, mY: -1 }, \"Warning\", \"This shader takes too long to compile. Shadertoy might disable real-time rendering when browsing.\", false, null);\r\n        }\r\n    }\r\n\r\n    var dataJSON = gShaderToy.Save();\r\n\r\n    dataJSON.info.name        = s1.value;\r\n    dataJSON.info.tags        = s2.value.split( \",\" );\r\n    dataJSON.info.description = s3.value;\r\n    dataJSON.info.published   = publishedStatus;\r\n\r\n    // short wait to make sure the rendering is done\r\n    // before reading the buffer from the gpu\r\n    setTimeout(() =\u003e {\r\n        // screenshot\r\n        var canvas = document.getElementById(\"demogl\");\r\n        var dataURL = canvas.toDataURL(\"image/jpeg\");\r\n\r\n        var dataTXT = JSON.stringify( dataJSON, null );\r\n        dataTXT = encodeURIComponent( dataTXT );\r\n\r\n        // send\r\n        var mHttpReq = new XMLHttpRequest();\r\n        mHttpReq.open( \"POST\", \"/shadertoy\", true );\r\n        mHttpReq.responseType = \"json\";\r\n        mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n\r\n        var url = \"a=\"; if( isUpdate ) url = \"u=\";\r\n        url += dataTXT;\r\n        \r\n        if (dataJSON.flags.mFlagWebcam === false) { url += \"\u0026ss=\" + dataURL; }\r\n\r\n        mHttpReq.ontimeout = function (e)\r\n        {\r\n            console.log(\"TIMEOUT\");\r\n        };\r\n\r\n        mHttpReq.onerror = function()\r\n        {\r\n            gShaderToy.setActionsState(true);\r\n            gShaderToy.mState = 1;\r\n            shaderSaved(-3, \"NOID\", isUpdate, dataJSON);\r\n        }\r\n        mHttpReq.onload = function()\r\n        {\r\n            gShaderToy.setActionsState(true);\r\n            gShaderToy.mState = 1;\r\n            try \r\n            {\r\n                let jsn = mHttpReq.response;\r\n                shaderSaved( jsn.result, jsn.id, isUpdate, dataJSON );\r\n            } \r\n            catch(e) \r\n            {\r\n                shaderSaved( -3, \"NOID\", isUpdate, dataJSON );\r\n            }\r\n        }\r\n        mHttpReq.send( url );\r\n    }, 100);\r\n}\r\n\r\nfunction doFork()\r\n{\r\n    var dataJSON = gShaderToy.Save();\r\n\r\n    let eleButton = document.getElementById(\"myForkButton\");\r\n    if (eleButton.disabled) return; // prevent double save\r\n\r\n    eleButton.disabled = true;\r\n\r\n    let ve = document.getElementById(\"centerScreen\");\r\n    doAlert(piGetCoords(ve), { mX: 256, mY: 180 }, \"Please Wait\", \"Forking Shader...\", null);\r\n\r\n    // short wait to make sure the rendering is done\r\n    // before reading the buffer from the gpu\r\n    setTimeout(() =\u003e {\r\n        var dataTXT = JSON.stringify( dataJSON, null );\r\n        dataTXT = encodeURIComponent( dataTXT );\r\n\r\n        // Submit the values to the cloud\r\n        var mHttpReq = new XMLHttpRequest();\r\n        mHttpReq.open( \"POST\", \"/shadertoy\", true );\r\n        mHttpReq.responseType = \"json\";\r\n        mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n\r\n        var url = \"f=\" + dataTXT;\r\n\r\n        mHttpReq.onerror = function()\r\n        {\r\n            shaderSaved(-3, \"NOID\", false, dataJSON);\r\n            eleButton.disabled = false;\r\n        }\r\n        mHttpReq.onload = function()\r\n        {\r\n            eleButton.disabled = false;\r\n            try \r\n            {\r\n                var jsn = mHttpReq.response;\r\n                shaderSaved( jsn.result, jsn.id, false, dataJSON );\r\n            } \r\n            catch(e) \r\n            {\r\n                shaderSaved( -3, \"NOID\", false, dataJSON );\r\n            }\r\n        }\r\n        mHttpReq.send( url );\r\n    }, 200);\r\n}\r\n\r\n//==================================================================\r\n\u003c/script\u003e\r\n    \u003cscript src=\"/js/cmpPageNavigation.js?v=86\"\u003e\u003c/script\u003e\r\n\r\n        \r\n    \u003cscript\u003e\r\n        function saveScreenshot()\r\n        {\r\n            gShaderToy.saveScreenshot();\r\n        }\r\n    \u003c/script\u003e\r\n\r\n\u003c/head\u003e\r\n\r\n\u003cbody onload=\"watchInit();\"\u003e\r\n\r\n\r\n\u003c!-- header =================================================================================== --\u003e\r\n\r\n\r\n\u003cdiv id=\"header\"\u003e\r\n\r\n    \u003cdiv id=\"headerBlock1\"\u003e\r\n        \u003ca href=\"/\" id=\"headerTitle\"\u003eShadertoy\u003c/a\u003e\r\n        \u003cform name=\"formSearch\" action=\"/results\" method=\"get\" style=\"display:inline-block;\"\u003e\r\n        \u003cdiv  id=\"headerSearch\"\u003e\r\n            \u003cinput type=\"search\" id=\"mySearch\" name=\"query\" placeholder=\"Search...\" value=\"\"/\u003e\r\n        \u003c/div\u003e\r\n        \u003c/form\u003e\r\n    \u003c/div\u003e\r\n\r\n    \u003cdiv id=\"headerBlock2\"\u003e\r\n                \u003cspan style=\"padding-top:14px;padding-bottom:14px;\"\u003e\r\n\r\n            Welcome            \u003ca class=\"headerLinks\" style=\"padding-right:3px;\" href=\"/profile/?show=shaders\"\u003eMick\u003c/a\u003e\r\n                        |\r\n            \u003ca class=\"headerLinks\" href=\"/browse\"\u003eBrowse\u003c/a\u003e\r\n            \u003ca class=\"headerLinks\" href=\"/new\"\u003eNew\u003c/a\u003e\r\n            \u003ca class=\"headerLinks\" href=\"/signout\"\u003eLogout\u003c/a\u003e\r\n            \u003c/span\u003e\r\n        \u003c/div\u003e\r\n\u003c/div\u003e\r\n\u003cdiv id=\"content\"\u003e\r\n\r\n    \u003c!-- admin ================================================================================== --\u003e\r\n    \r\n    \u003c!-- ================================================================================== --\u003e\r\n\r\n    \u003cdiv class=\"container\"\u003e\r\n\r\n        \u003c!-- player ---------------------------------------------------------------------------------- --\u003e\r\n\r\n        \u003cdiv class=\"block0\"\u003e\r\n\r\n            \u003cdiv id=\"player\"\u003e\r\n                \u003ccanvas id=\"demogl\" class=\"playerCanvas\"\u003e\u003c/canvas\u003e\r\n                \u003cdiv id=\"noWebGL\"\u003e\u003cimg id=\"noWebGL_ShaderImage\"\u003e\u003c/img\u003e\u003cspan id=\"noWebGL_Text\"\u003eNo WebGL available :(\u003c/span\u003e\u003c/div\u003e\r\n                \u003cdiv id=\"playerBar\" class=\"playerBar\"\u003e\r\n                    \u003cdiv\u003e\r\n                        \u003cdiv id=\"myResetButton\" class=\"uiButton\" title=\"Reset time (\u003cALT\u003e+\u003cDownArrow\u003e)\" style=\"background-image:url('/img/themes/classic/rewind.png')\"\u003e\u003c/div\u003e\r\n                        \u003cdiv id=\"myPauseButton\" class=\"uiButton\" title=\"Pause/Resume (\u003cALT\u003e+\u003cUpArrow\u003e)\" style=\"background-image:url('/img/themes/classic/pause.png')\"\u003e\u003c/div\u003e\r\n                    \u003c/div\u003e\r\n                    \u003cdiv\u003e\r\n                        \u003cdiv id=\"myTime\"\u003e0.00\u003c/div\u003e\r\n                        \u003cdiv id=\"myFramerate\"\u003e00.0 fps\u003c/div\u003e\r\n                        \u003cdiv id=\"myResolution\"\u003e0 x 0\u003c/div\u003e\r\n                    \u003c/div\u003e\r\n                    \u003cdiv\u003e\r\n                        \u003c!--\r\n                        \u003cdiv id=\"myVR\" class=\"uiButton\" title=\"Enable VR\" style=\"background-image:url('/img/themes/classic/vrOff.png');visible:hidden\"\u003e\u003c/div\u003e\r\n                        --\u003e\r\n                        \u003cdiv id=\"myRecord\" class=\"uiButton\" title=\"Record (\u003cALT\u003e+\u003cR\u003e)\" style=\"background-image:url('/img/themes/classic/recordOff.png');visible:hidden\"\u003e\u003c/div\u003e\r\n                        \u003cdiv id=\"myVolume\" class=\"uiButton\" title=\"Volume\" style=\"background-image:url('/img/themes/classic/speakerOn.png')\"\u003e\u003c/div\u003e\r\n                        \u003cdiv id=\"myFullScreen\" class=\"uiButton\" title=\"Go fullscreen\" style=\"background-image:url('/img/themes/classic/fullscreen.png')\"\u003e\u003c/div\u003e\r\n                    \u003c/div\u003e\r\n                \u003c/div\u003e\r\n            \u003c/div\u003e\r\n\r\n            \u003cdiv id=\"shaderInfo\"\u003e\r\n                \r\n                \u003cdiv class=\"shaderInfoA\"\u003e\r\n                    \u003cdiv\u003e\r\n                        \u003cinput type=\"text\" class=\"inputForm\" id=\"shaderTitle\" required name=\"name1\" value=\"\" maxlength=\"32\"  placeholder=\" Name of your shader\" /\u003e\u003cbr/\u003e\r\n                    \u003c/div\u003e\r\n                    \u003cdiv\u003e\r\n                        \u003cimg id=\"myForkButton\" class=\"uiButtonNew\" style=\"margin-right:12px\" src=\"/img/themes/classic/fork.png\" title=\"fork this shader\" onclick=\"doFork()\" /\u003e\r\n                        \u003cimg class=\"uiButtonNew\" style=\"margin-right:12px\" src=\"/img/themes/classic/addToPlaylist.png\" title=\"add this shader to a playlist\" onclick=\"doAddToPlaylist( gShaderID, piGetCoords(this) )\" /\u003e\r\n                        \u003cimg class=\"uiButtonNew\" style=\"margin-right:12px\" src=\"/img/themes/classic/share.png\" title=\"share this shader\" onclick=\"doShareShader( piGetCoords(this) )\" /\u003e\r\n                        \u003cimg src='/img/themes/classic/likeNo.png'\u003e\u003c/img\u003e\r\n                        \u003cspan class='shaderInfoHeaderRightBigText' id=\"shaderStatsLikes\"\u003e\u003c/span\u003e\r\n                    \u003c/div\u003e\r\n                    \u003cdiv\u003e\r\n                        Views: \u003cspan id=\"shaderStatsViewed\"\u003e0\u003c/span\u003e, Tags:\r\n                        \u003cinput type=\"text\" class=\"inputForm\" id=\"shaderTags\"  required name=\"name2\" value=\"\" maxlength=\"128\" placeholder=\"Tags, comma separated. For example: 2D, procedural, fractal\" /\u003e\r\n                    \u003c/div\u003e\r\n                    \u003cdiv\u003e\r\n                        Created by \u003cspan id=\"shaderAuthorName\"\u003e\u003c/span\u003e in \u003cspan id=\"shaderAuthorDate\"\u003e\u003c/span\u003e\r\n                    \u003c/div\u003e\r\n                    \u003cdiv\u003e\r\n                        \u003cspan id=\"shaderForkedFrom\"\u003e\u003c/span\u003e\r\n                    \u003c/div\u003e\r\n                \u003c/div\u003e\r\n\r\n                \u003cbr\u003e\r\n                \u003ctextarea class=\"inputForm\" id=\"shaderDescription\" required name=\"name3\" value=\"\" rows=\"4\" maxlength=\"255\" placeholder=\"Describe your shader\"\u003e\u003c/textarea\u003e\r\n                \u003cdiv id=\"shaderPublished\"\u003e\r\n                    \u003cselect class=\"inputForm\" id=\"published\" title=\"Choose privacy level for your shader:\u0026#13;\u0026#13;* private: only you can see the shader\u0026#13;* anonymous: only people with the URL can view the shaders, the author is hidden\u0026#13;* unlisted: only people with the URL can view the shaders\u0026#13;* public: anybody can see your shader in www.shadertoy.com\u0026#13;* public + api: 3rd party apps can access the shader and use it by complying to the license for your shader\"\u003e\r\n                        \u003coption value=\"3\" selected=\"selected\"\u003epublic + api\u003c/option\u003e\r\n                        \u003coption value=\"1\"\u003epublic\u003c/option\u003e\r\n                        \u003coption value=\"2\"\u003eunlisted\u003c/option\u003e\r\n                                                \u003coption value=\"0\"\u003eprivate\u003c/option\u003e\r\n                    \u003c/select\u003e\r\n                    \u003cinput type=\"submit\" id=\"saveButton\" class=\"formButton\" style=\"margin-left:12px;display:inline-block\" title=\"\u003cCTRL\u003e+\u003cS\u003e : save the current shader\" onclick=\"doSaveShader()\" value=\"Save\"/\u003e\r\n                \u003c/div\u003e\r\n\r\n                            \u003c/div\u003e\r\n        \u003c/div\u003e\r\n\r\n        \u003c!-- editor ---------------------------------------------------------------------------------- --\u003e\r\n\r\n        \u003cdiv class=\"block1\"\u003e\r\n\r\n            \u003cdiv id=\"passManager\"\u003e\u003c/div\u003e\r\n            \u003cdiv id=\"passManagerSeparator\"\u003e\r\n            \u003c/div\u003e\r\n            \u003cdiv id=\"editorHeader\" onclick=\"this.classList.toggle('expanded'); document.getElementById('editorHeaderArrow').classList.toggle('expanded'); document.getElementById('editor').classList.toggle('expanded');\"\u003e\r\n                \u003cdiv id=\"editorHeaderBar\"\u003e\r\n                    \u003cdiv id=\"editorHeaderArrow\"\u003e\u003c/div\u003e\r\n                    \u003cspan style=\"left:24px;top:2px;position:relative\"\u003eShader Inputs\u003c/span\u003e\r\n                \u003c/div\u003e\r\n                \u003cdiv id=\"editorHeaderText\"\u003e\u003cpre\u003e\u003cspan style=\"color:#708\"\u003euniform vec3\u003c/span\u003e      iResolution;           \u003cspan style=\"color:#080\"\u003e// viewport resolution (in pixels)\u003c/span\u003e\u003cbr\u003e\u003cspan style=\"color:#708\"\u003euniform float\u003c/span\u003e     iTime;                 \u003cspan style=\"color:#080\"\u003e// shader playback time (in seconds)\u003c/span\u003e\u003cbr\u003e\u003cspan style=\"color:#708\"\u003euniform float\u003c/span\u003e     iTimeDelta;            \u003cspan style=\"color:#080\"\u003e// render time (in seconds)\u003c/span\u003e\u003cbr\u003e\u003cspan style=\"color:#708\"\u003euniform float\u003c/span\u003e     iFrameRate;            \u003cspan style=\"color:#080\"\u003e// shader frame rate\u003c/span\u003e\u003cbr\u003e\u003cspan style=\"color:#708\"\u003euniform int\u003c/span\u003e       iFrame;                \u003cspan style=\"color:#080\"\u003e// shader playback frame\u003c/span\u003e\u003cbr\u003e\u003cspan style=\"color:#708\"\u003euniform float\u003c/span\u003e     iChannelTime[4];       \u003cspan style=\"color:#080\"\u003e// channel playback time (in seconds)\u003c/span\u003e\u003cbr\u003e\u003cspan style=\"color:#708\"\u003euniform vec3\u003c/span\u003e      iChannelResolution[4]; \u003cspan style=\"color:#080\"\u003e// channel resolution (in pixels)\u003c/span\u003e\u003cbr\u003e\u003cspan style=\"color:#708\"\u003euniform vec4\u003c/span\u003e      iMouse;                \u003cspan style=\"color:#080\"\u003e// mouse pixel coords. xy: current (if MLB down), zw: click\u003c/span\u003e\u003cbr\u003e\u003cspan style=\"color:#708\"\u003euniform samplerXX\u003c/span\u003e iChannel0..3;          \u003cspan style=\"color:#080\"\u003e// input channel. XX = 2D/Cube\u003c/span\u003e\u003cbr\u003e\u003cspan style=\"color:#708\"\u003euniform vec4\u003c/span\u003e      iDate;                 \u003cspan style=\"color:#080\"\u003e// (year, month, day, time in seconds)\u003c/span\u003e\u003cbr\u003e\u003cspan style=\"color:#708\"\u003euniform float\u003c/span\u003e     iSampleRate;           \u003cspan style=\"color:#080\"\u003e// sound sample rate (i.e., 44100)\u003c/span\u003e\r\n                \u003c/pre\u003e\u003c/div\u003e\r\n            \u003c/div\u003e\r\n\r\n            \u003cdiv id=\"editor\" class=\"left\"\u003e\u003c/div\u003e\r\n\r\n            \u003cdiv id=\"toolBar\"\u003e\r\n\r\n                \u003cdiv\u003e\r\n                    \u003cimg class=\"uiButtonNew vcenter\" id=\"compileButton\" src=\"/img/themes/classic/play.png\" title=\"Compile (\u003cALT\u003e+\u003cENTER\u003e)\" onclick=\"gShaderToy.SetShaderFromEditor(false,true)\"/\u003e\r\n                    \u003ca class=\"regular vcenter\" style=\"cursor:pointer;\" title=\"See translated shader code (\u003cALT\u003e+\u003cENTER\u003e)\" href=\"#\" onclick=\"gShaderToy.ShowTranslatedSource()\"\u003e\r\n                        \u003cspan class=\"vcenter\" id=\"compilationTime\"\u003eCompiled in 0.0/0.0 secs\u003c/span\u003e\r\n                    \u003c/a\u003e\r\n                \u003c/div\u003e\r\n\r\n                \u003cdiv\u003e\r\n                    \u003ca class=\"regular\" style=\"cursor:pointer;\" id=\"numCharacters\" title=\"Number of minimum number of characters to describe the same shader.\u0026#13;\u0026#13;Click to view the minimal shader.\" onclick=\"gShaderToy.showChars()\"\u003e0 chars\u003c/a\u003e\r\n                    \u003cspan id=\"numCharactersTotal\"\u003e\u003c/span\u003e\r\n                \u003c/div\u003e\r\n\r\n                \u003cdiv style=\"justify-self:right;\"\u003e\r\n\r\n                    \u003cimg class=\"uiButtonNew vcenter\" id=\"screenshotButton\" src=\"/img/themes/classic/screenshot.png\" title=\"Render Image\" onclick=\"saveScreenshot()\"/\u003e\r\n\r\n                    \u003cselect id=\"uiFontSelector\" class=\"inputForm vcenter\" style=\"display:inline\" title=\"Change font size (\u003cALT\u003e+\u003c+/-\u003e)\"\u003e\r\n                        \u003coption\u003eXS\u003c/option\u003e\r\n                        \u003coption selected='selected'\u003eS\u003c/option\u003e\r\n                        \u003coption\u003eM\u003c/option\u003e\r\n                        \u003coption\u003eL\u003c/option\u003e\r\n                        \u003coption\u003eXL\u003c/option\u003e\r\n                        \u003coption\u003eXXL\u003c/option\u003e\r\n                    \u003c/select\u003e\r\n\r\n                    \u003cimg class=\"uiButtonNew vcenter\" src=\"/img/themes/classic/help.png\" title=\"Show GLSL help\" onclick=\"showHelp()\"/\u003e\r\n                \u003c/div\u003e\r\n            \u003c/div\u003e\r\n\r\n            \u003cdiv id=\"textures\"\u003e\r\n                \u003cdiv id='texture0' class='inputSelector'\u003e\u003cdiv style='width:100%;height:100%;padding:0;margin:0;border:0;position:relative;'\u003e\u003ccanvas id='myUnitCanvas0' class='inputSelectorCanvas'\u003e\u003c/canvas\u003e\u003cimg id='myDeleteInput0' class='deleteInput' src='/img/close2.png' title='remove input'/\u003e\u003cdiv id='mySampler0' class='inputSampler'\u003e\u003cbr/\u003eFilter\u003cselect class='inputForm' id='mySamplerFilter0' style='width:80px;' title='Pixel filtering mode' onchange='gShaderToy.SetSamplerFilter(0, this.value );'\u003e\u003coption value='nearest'\u003enearest\u003c/option\u003e\u003coption value='linear'\u003elinear\u003c/option\u003e\u003coption value='mipmap'\u003emipmap\u003c/option\u003e\u003c/select\u003e\u003cbr/\u003eWrap\u003cselect class='inputForm' id='mySamplerWrap0' style='width:80px;' title='Pixel filtering mode' onchange='gShaderToy.SetSamplerWrap(0, this.value );'\u003e\u003coption value='clamp'\u003eclamp\u003c/option\u003e\u003coption value='repeat'\u003erepeat\u003c/option\u003e\u003c/select\u003e\u003cbr/\u003e\u003cdiv id='mySamplerVFlipLabel0'\u003e\u003clabel\u003eVFlip\u003cinput type='checkbox' id='mySamplerVFlip0' value='No' onchange='gShaderToy.SetSamplerVFlip(0,(this.checked)?\"true\":\"false\");' /\u003e\u003c/label\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv class='inputSelectorBar'\u003e\u003cdiv id='myUnitText0' class='inputSelectorText'\u003eiChannel0\u003c/div\u003e\u003cdiv id='inputSelectorControls0' class='inputSelectorControls'\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv id='texture1' class='inputSelector'\u003e\u003cdiv style='width:100%;height:100%;padding:0;margin:0;border:0;position:relative;'\u003e\u003ccanvas id='myUnitCanvas1' class='inputSelectorCanvas'\u003e\u003c/canvas\u003e\u003cimg id='myDeleteInput1' class='deleteInput' src='/img/close2.png' title='remove input'/\u003e\u003cdiv id='mySampler1' class='inputSampler'\u003e\u003cbr/\u003eFilter\u003cselect class='inputForm' id='mySamplerFilter1' style='width:80px;' title='Pixel filtering mode' onchange='gShaderToy.SetSamplerFilter(1, this.value );'\u003e\u003coption value='nearest'\u003enearest\u003c/option\u003e\u003coption value='linear'\u003elinear\u003c/option\u003e\u003coption value='mipmap'\u003emipmap\u003c/option\u003e\u003c/select\u003e\u003cbr/\u003eWrap\u003cselect class='inputForm' id='mySamplerWrap1' style='width:80px;' title='Pixel filtering mode' onchange='gShaderToy.SetSamplerWrap(1, this.value );'\u003e\u003coption value='clamp'\u003eclamp\u003c/option\u003e\u003coption value='repeat'\u003erepeat\u003c/option\u003e\u003c/select\u003e\u003cbr/\u003e\u003cdiv id='mySamplerVFlipLabel1'\u003e\u003clabel\u003eVFlip\u003cinput type='checkbox' id='mySamplerVFlip1' value='No' onchange='gShaderToy.SetSamplerVFlip(1,(this.checked)?\"true\":\"false\");' /\u003e\u003c/label\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv class='inputSelectorBar'\u003e\u003cdiv id='myUnitText1' class='inputSelectorText'\u003eiChannel1\u003c/div\u003e\u003cdiv id='inputSelectorControls1' class='inputSelectorControls'\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv id='texture2' class='inputSelector'\u003e\u003cdiv style='width:100%;height:100%;padding:0;margin:0;border:0;position:relative;'\u003e\u003ccanvas id='myUnitCanvas2' class='inputSelectorCanvas'\u003e\u003c/canvas\u003e\u003cimg id='myDeleteInput2' class='deleteInput' src='/img/close2.png' title='remove input'/\u003e\u003cdiv id='mySampler2' class='inputSampler'\u003e\u003cbr/\u003eFilter\u003cselect class='inputForm' id='mySamplerFilter2' style='width:80px;' title='Pixel filtering mode' onchange='gShaderToy.SetSamplerFilter(2, this.value );'\u003e\u003coption value='nearest'\u003enearest\u003c/option\u003e\u003coption value='linear'\u003elinear\u003c/option\u003e\u003coption value='mipmap'\u003emipmap\u003c/option\u003e\u003c/select\u003e\u003cbr/\u003eWrap\u003cselect class='inputForm' id='mySamplerWrap2' style='width:80px;' title='Pixel filtering mode' onchange='gShaderToy.SetSamplerWrap(2, this.value );'\u003e\u003coption value='clamp'\u003eclamp\u003c/option\u003e\u003coption value='repeat'\u003erepeat\u003c/option\u003e\u003c/select\u003e\u003cbr/\u003e\u003cdiv id='mySamplerVFlipLabel2'\u003e\u003clabel\u003eVFlip\u003cinput type='checkbox' id='mySamplerVFlip2' value='No' onchange='gShaderToy.SetSamplerVFlip(2,(this.checked)?\"true\":\"false\");' /\u003e\u003c/label\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv class='inputSelectorBar'\u003e\u003cdiv id='myUnitText2' class='inputSelectorText'\u003eiChannel2\u003c/div\u003e\u003cdiv id='inputSelectorControls2' class='inputSelectorControls'\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv id='texture3' class='inputSelector'\u003e\u003cdiv style='width:100%;height:100%;padding:0;margin:0;border:0;position:relative;'\u003e\u003ccanvas id='myUnitCanvas3' class='inputSelectorCanvas'\u003e\u003c/canvas\u003e\u003cimg id='myDeleteInput3' class='deleteInput' src='/img/close2.png' title='remove input'/\u003e\u003cdiv id='mySampler3' class='inputSampler'\u003e\u003cbr/\u003eFilter\u003cselect class='inputForm' id='mySamplerFilter3' style='width:80px;' title='Pixel filtering mode' onchange='gShaderToy.SetSamplerFilter(3, this.value );'\u003e\u003coption value='nearest'\u003enearest\u003c/option\u003e\u003coption value='linear'\u003elinear\u003c/option\u003e\u003coption value='mipmap'\u003emipmap\u003c/option\u003e\u003c/select\u003e\u003cbr/\u003eWrap\u003cselect class='inputForm' id='mySamplerWrap3' style='width:80px;' title='Pixel filtering mode' onchange='gShaderToy.SetSamplerWrap(3, this.value );'\u003e\u003coption value='clamp'\u003eclamp\u003c/option\u003e\u003coption value='repeat'\u003erepeat\u003c/option\u003e\u003c/select\u003e\u003cbr/\u003e\u003cdiv id='mySamplerVFlipLabel3'\u003e\u003clabel\u003eVFlip\u003cinput type='checkbox' id='mySamplerVFlip3' value='No' onchange='gShaderToy.SetSamplerVFlip(3,(this.checked)?\"true\":\"false\");' /\u003e\u003c/label\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv class='inputSelectorBar'\u003e\u003cdiv id='myUnitText3' class='inputSelectorText'\u003eiChannel3\u003c/div\u003e\u003cdiv id='inputSelectorControls3' class='inputSelectorControls'\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\n\n            \u003c/div\u003e\r\n        \u003c/div\u003e\r\n\r\n        \u003c!-- comments ---------------------------------------------------------------------------------- --\u003e\r\n\r\n        \u003cdiv class=\"block2\"\u003e\r\n                        \u003cdiv id=\"comments\"\u003e\r\n                \u003cspan\u003eComments\u003c/span\u003e (\u003cspan id=\"shaderStatsComments\"\u003e0\u003c/span\u003e)\u003cbr\u003e\r\n                \u003cdiv id=\"commentsForm\"\u003e\r\n                                        \u003cdiv class=\"commentNew\"\u003e\r\n                        \u003cdiv\u003e\u003cimg class=\"userPictureSmall\" src=\"/img/profile.jpg\"/\u003e\u003c/div\u003e                        \u003cform name=\"formComment\" method=\"post\"\u003e\r\n                            \u003ctextarea class=\"inputForm\" id=\"commentTextArea\" style=\"margin-top:0px;margin-bottom:4px;width:100%;\" name=\"comment\" placeholder=\" Your comment...\" value=\"\" rows=\"4\" cols=\"70\"\u003e\u003c/textarea\u003e\u003cbr /\u003e\r\n\r\n                            \u003cdiv style=\"width:100%;height:24px;\"\u003e\r\n                                \u003cinput style=\"display:inline-block;right:0px;position:absolute;\" id=\"myCommentButton\" name=\"mybutton\" type=\"submit\" value=\"Post\" class=\"formButton\" onclick=\"validateComment(this.form); return false;\" /\u003e\r\n                                                                \u003cdiv class=\"uiButton\" style=\"display:inline-block;background:url('/img/themes/classic/helpSmall.png') no-repeat center center;\" title=\"BBCode help\" onclick=\"showBBCodeHelp()\"\u003e\u003c/div\u003e\r\n                                                            \u003c/div\u003e\r\n\r\n                        \u003c/form\u003e\r\n                    \u003c/div\u003e\r\n\r\n\r\n\r\n\r\n                                    \u003c/div\u003e\r\n\r\n                \u003cdiv id=\"myComments\" style=\"margin-top:4px\"\u003e\u003c/div\u003e\r\n            \u003c/div\u003e\r\n                    \u003c/div\u003e\r\n\r\n    \u003c/div\u003e\r\n\r\n\u003c/div\u003e\r\n\r\n\u003c!-- footer ================================================================================== --\u003e\r\n\r\n\u003cdiv id=\"footer\"\u003e\r\n    \r\n    \u003cdiv\u003e\u003cspan style=\"color:#ffffff;\"\u003eCommunity Forums\u003c/span\u003e\r\n      \u003cul\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"/events\"\u003eOfficial Events\u003c/a\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"https://www.facebook.com/groups/147749602472741\"\u003eIn Facebook (english)\u003c/a\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"https://www.facebook.com/groups/1339783682699494\"\u003eIn Facebook (korean)\u003c/a\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"https://discord.gg/XtmMN6E\"\u003eIn Discord\u003c/a\u003e (\u003ca class=\"regular\" href=\"https://discordapp.com/channels/578696555612209173/579531723348639754\"\u003edirect link\u003c/a\u003e)\u003c/li\u003e\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n\r\n    \u003cdiv\u003e\u003cspan style=\"color:#ffffff;\"\u003eFeedback and Support\u003c/span\u003e\r\n      \u003cul\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"https://www.facebook.com/Shadertoy\"\u003eFacebook\u003c/a\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"https://twitter.com/shadertoy\"\u003eTwitter\u003c/a\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"https://www.patreon.com/shadertoy\"\u003ePatreon\u003c/a\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"https://trello.com/b/5hM0CjId\"\u003eRoadmap\u003c/a\u003e\u003c/li\u003e\r\n\r\n            \u003cli\u003e\u003ca class=\"regular\" href=\"mailto:info@shadertoy.com?Subject=Hello%20Shadertoy\"\u003eEmail\u003c/a\u003e\u003c/li\u003e\r\n      \r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n\r\n    \u003cdiv\u003e\u003cspan style=\"color:#ffffff;\"\u003eShadertoy\u003c/span\u003e\r\n      \u003cul\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"/store\"\u003eStore\u003c/a\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"/howto\"\u003eDocumentation\u003c/a\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"/terms\"\u003eTerms \u0026 Privacy\u003c/a\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"/about\"\u003eAbout\u003c/a\u003e\u003c/li\u003e\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n\r\n    \u003cdiv\u003e\u003cspan style=\"color:#ffffff;\"\u003eApps and Plugins\u003c/span\u003e\r\n      \u003cul\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"https://itunes.apple.com/us/app/shadertoy/id717961814\"\u003eOfficial iPhone App\u003c/a\u003e by \u003ca class=\"user\" href=\"/user/reinder\"\u003eReinder\u003c/a\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188\"\u003eScreensaver\u003c/a\u003e by \u003ca class=\"user\" href=\"/user/kosro\"\u003eKosro\u003c/a\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl\"\u003eShadertoy plugin\u003c/a\u003e by \u003ca class=\"user\" href=\"/user/patu\"\u003ePatu\u003c/a\u003e\u003c/li\u003e\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n\r\n    \u003cdiv\u003e\u003cspan style=\"color:#ffffff;\"\u003eTutorials\u003c/span\u003e\r\n      \u003cul\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"https://www.youtube.com/watch?v=0ifChJ0nJfM\"\u003eShader coding intro\u003c/a\u003e by \u003ca class=\"user\" href=\"/user/iq\"\u003eiq\u003c/a\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003ca class=\"regular\" href=\"https://shadertoyunofficial.wordpress.com/\"\u003eShadertoy Unofficial\u003c/a\u003e by \u003ca class=\"user\" href=\"/user/FabriceNeyret2\"\u003eFabriceNeyret2\u003c/a\u003e\u003c/li\u003e\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n\r\n\u003c/div\u003e\r\n\r\n\u003cdiv id=\"compliance\" style=\"padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF\"\u003e\r\n    \u003cdiv style=\"text-align: center; margin-top:8px\"\u003e\r\n        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. \r\n        For more information, please review our \u003ca class=\"regular\" href=\"/terms\"\u003eTerms \u0026 Privacy\u003c/a\u003e.\r\n    \u003c/div\u003e \r\n    \u003cdiv style=\"text-align: center;margin-top:6px\"\u003e\r\n        \u003cbutton type=\"button\" style=\"width:100px;font-size:inherit\" onclick=\"acceptCompliance()\"\u003eAccept\u003c/button\u003e\r\n    \u003c/div\u003e\r\n\u003c/div\u003e\r\n\r\n\u003cscript\u003e\r\n(function runCompliance() \r\n{\r\n    let showCompliance = 1;\r\n    let allcookies = document.cookie;\r\n    let cookiearray = allcookies.split(';');\r\n    for (var i=0; i\u003ccookiearray.length; i++)\r\n    {\r\n        let name  = cookiearray[i].split('=')[0];\r\n        let value = cookiearray[i].split('=')[1];\r\n        if (name.trim() == \"scmp\") \r\n        {\r\n            showCompliance = value;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (showCompliance === 1) \r\n    {\r\n        var ve = document.getElementById(\"compliance\");\r\n        ve.style.visibility=\"visible\";\r\n    }\r\n})();\r\n\r\nfunction acceptCompliance()\r\n{\r\n    let now = new Date();\r\n    now.setTime( now.getTime() + (5*365*24*60*60*1000) );\r\n    document.cookie=\"scmp=0;expires=\" + now.toUTCString() + \";\";\r\n\r\n    var ve = document.getElementById(\"compliance\");\r\n    ve.style.visibility=\"hidden\";\r\n}\r\n\u003c/script\u003e\r\n\r\n\r\n\r\n\r\n\u003cdiv id=\"centerScreen\"\u003e\u003c/div\u003e\r\n    \u003c!-- pickInput =============================================================================== --\u003e\r\n    \u003cstyle\u003e\r\n\u003c/style\u003e\r\n\r\n\r\n\u003cscript\u003e\r\nfunction cmpAssetBrowser( assetType, clickedCallback )\r\n{\r\n    // private members\r\n    var mJson = null;\r\n    var mNumAssetsInPage = 0;\r\n    var mMaxAssetsPerPage = 9;\r\n    var mNumAssets = 0;\r\n    var mAssetType = assetType;\r\n    var mNavigator = new cmpPageNavigation( document.getElementById( assetType + \"Nav\" ), mMaxAssetsPerPage );\r\n    var mClickedCallback = clickedCallback;\r\n    var mLoaded = false;\r\n\r\n    // public members\r\n    var me = {};\r\n\r\n    me.Load = function()\r\n    {\r\n        if( mLoaded ) return;\r\n\r\n        var req = new XMLHttpRequest();\r\n        req.onload = function()\r\n        {\r\n            mLoaded = true;\r\n\r\n            mJson = req.response;\r\n\r\n            if( mJson==null ) return;\r\n            mNumAssets = mJson.filepath.length;\r\n            if( mNumAssets==0 ) return;\r\n\r\n            mNavigator.SetNumResults( mNumAssets, mMaxAssetsPerPage );\r\n            mNavigator.RefreshUI();\r\n            mNavigator.SetOnClick( function( pageID )\r\n                            {\r\n                                me.RefreshUI( pageID );\r\n                            } );\r\n            me.RefreshUI( 0 );\r\n        };\r\n        req.open( \"POST\", \"/shadertoy\", true );\r\n        req.responseType = \"json\";\r\n        req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n        //req.send( \"mga=1\u0026from=0\u0026num=9\u0026type=\"+mAssetType );\r\n        req.send( \"mga=1\u0026type=\"+mAssetType );\r\n    };\r\n\r\n    me.RefreshUI = function( pageid )\r\n    {\r\n            let firstAsset = pageid*mMaxAssetsPerPage;\r\n            let numAssets = mMaxAssetsPerPage;\r\n\r\n            if( firstAsset + numAssets \u003e mNumAssets ) numAssets = mNumAssets - firstAsset;\r\n\r\n            for( let i=0; i\u003cmMaxAssetsPerPage; i++ )\r\n            {\r\n                let eleAse = document.getElementById( mAssetType+\"Asset\"+i );\r\n                let eleImg = document.getElementById( mAssetType+\"AssetThumnail\"+i );\r\n                let eleNam = document.getElementById( mAssetType+\"AssetName\"+i );\r\n                let eleUse = document.getElementById( mAssetType+\"UserName\"+i );\r\n                let eleInf = document.getElementById( mAssetType+\"Info\"+i );\r\n\r\n\r\n                if( i\u003cnumAssets )\r\n                {\r\n\r\n                    let id = firstAsset + i;\r\n\r\n                    eleAse.style.display = \"block\";\r\n                    \r\n                    // do not use eleImg.addEventListener(\"click\", function()...\r\n                    eleImg.onclick = function()\r\n                                    {\r\n                                        mClickedCallback( { mType: mAssetType, \r\n                                                            mID: mJson.id[id],\r\n                                                            mSrc: mJson.filepath[id],\r\n                                                            mSampler: mJson.sampler[id],\r\n                                                            mPreviewSrc: mJson.previewFilepath[id]\r\n                                                            } ); \r\n                                    };\r\n                    //eleImg.onerror = function() {}\r\n                    eleImg.src = mJson.previewFilepath[id];\r\n                    eleNam.textContent = mJson.name[id];\r\n                    //eleUse.textContent = mJson.owner[id];\r\n                    eleUse.innerHTML = \"\u003ca class='user' href='/user/\" + htmlEntities(mJson.owner[id]) +\"'\u003e\" + htmlEntities(mJson.owner[id]) + \"\u003c/a\u003e\";\r\n                    if( mAssetType===\"texture\" )\r\n                    {\r\n                        eleInf.textContent = mJson.custom1[id] + \" x \" + mJson.custom2[id] + \"\\r\\n\" + mJson.custom3[id] + \" channels, uint8\";\r\n                    }\r\n                    else if( mAssetType===\"volume\" )\r\n                    {\r\n                        eleInf.textContent = mJson.custom1[id] + \" x \" + mJson.custom2[id] +  \" x \" + mJson.custom3[id] + \"\\r\\n\" + mJson.custom4[id] + \" channels, uint8\";\r\n                    }\r\n                    else if( mAssetType===\"cubemap\" )\r\n                    {\r\n                        eleInf.textContent = mJson.custom1[id] + \" x \" + mJson.custom2[id] + \"\\r\\n\" + mJson.custom3[id] + \" channels, uint8\";\r\n                    }\r\n                    else if( mAssetType===\"video\" )\r\n                    {\r\n                        eleInf.textContent = mJson.custom1[id] + \" x \" + mJson.custom2[id] + \", \" + mJson.custom5[id] + \" fps\\r\\n\" + mJson.custom3[id] + \" channels, uint8\\r\\n\" + mJson.custom6[id] + \" seconds\";\r\n                    }\r\n                    else if( mAssetType===\"music\" )\r\n                    {\r\n                        eleInf.textContent =  mJson.custom3[id] + \" hz\\r\\n\" + mJson.custom1[id] + \" channels, sint16\\r\\n\" + mJson.custom4[id] + \" seconds\";\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    eleAse.style.display = \"none\";\r\n                }\r\n            }\r\n    };\r\n\r\n    return me;\r\n}\r\n\u003c/script\u003e\r\n\r\n\r\n\u003cstyle\u003e\r\n.navigation\r\n{\r\n    text-align: center;\r\n    width: 100%;\r\n}\r\n\r\n.pageButtons\r\n{\r\n    text-align: center;\r\n    vertical-align: middle;\r\n    margin-left: 12px;\r\n    display: inline-block;\r\n    border-radius: 4px;\r\n    cursor: pointer;\r\n    padding-bottom:5px;\r\n    padding-top:4px;\r\n    padding-left: 8px;\r\n    padding-right: 8px;\r\n    margin-left:4px;\r\n    margin-right:4px;\r\n    text-decoration: none;\r\n    -moz-transition:    background-color 0.15s linear, color 0.15s linear;\r\n    -webkit-transition: background-color 0.15s linear, color 0.15s linear;\r\n    transition:         background-color 0.15s linear, color 0.15s linear;\r\n}\r\n\r\n.pageButtons:hover\r\n{\r\n    background-color:#808080;\r\n    color : #ff8020;\r\n}\r\n\r\n.pageButtonsCurrent\r\n{\r\n    text-align: center;\r\n    vertical-align: middle;\r\n    margin-left: 12px;\r\n    display: inline-block;\r\n    border-radius: 4px;\r\n    background-color: #808080;\r\n    padding-bottom:5px;\r\n    padding-top:4px;\r\n    padding-left: 8px;\r\n    padding-right: 8px;\r\n    margin-left:4px;\r\n    margin-right:4px;\r\n    text-decoration: none;\r\n    color:#000000;\r\n}\r\n\r\nul.tab_container\r\n{\r\n    list-style-type: none;\r\n    position:relative;\r\n    margin: 0;\r\n    padding: 0;\r\n    overflow: hidden;\r\n}\r\n\r\nul.tab_container li\r\n{\r\n    margin-right:18px;\r\n    float: left;\r\n    border-radius:8px 8px 0px 0px;\r\n    background-color: none;\r\n}\r\n\r\nul.tab_container li a\r\n{\r\n    display: inline-block;\r\n    text-align: center;\r\n    padding: 4px 16px;\r\n    text-decoration: none;\r\n    transition: 0.3s;\r\n    font-size: 1.5em;\r\n}\r\n\r\nul.tab_container li a:hover, a:focus, .active\r\n{\r\n    background-color: #808080}\r\n\r\n.tabcontent\r\n{\r\n    top:16px;\r\n    position:relative;\r\n    display: none;\r\n    width:100%;\r\n    padding-top:16px;\r\n}\r\n\u003c/style\u003e\r\n\r\n\u003cscript\u003e\r\n\r\n    var gDialog = null;\r\n\r\n    function cmpAssetBrowserMisc()\r\n    {\r\n        var names = [\r\n                //\"No Input\", \r\n                \"Keyboard\", \"Webcam\", \"Microphone\", \"Soundcloud\",\r\n                \"Buffer A\" ,\"Buffer B\", \"Buffer C\", \"Buffer D\", \"Cubemap A\"];\r\n        var infos = [\r\n                //\"\",  \r\n                \"256 x 3\\n1 ch, int8\", \"1280 x 720\\n4 ch, int8, sRGB\", \"512 x 2\\n1 ch, int8\", \"512 x 2\\n1 ch, int8\",\r\n                \"Viewport Resolution\\n4 ch, Float32, linear\",\r\n                \"Viewport Resolution\\n4 ch, Float32, linear\",\r\n                \"Viewport Resolution\\n4 ch, Float32, linear\",\r\n                \"Viewport Resolution\\n4 ch, Float32, linear\",\r\n                \"1024 x 1024\\n4 ch, Float16, linear\" ];\r\n        var filePaths = [\r\n                //\"none.png\", \r\n                \"keyboard.png\", \"webcam.png\", \"mic.png\", \"soundcloud.png\", \r\n                \"buffer00.png\", \"buffer01.png\", \"buffer02.png\", \"buffer03.png\", \"cubemap00.png\" ];\r\n        var opts = [\r\n                //{mType:null,          mID:-1,        mSrc:null,                        mSampler:{} },\r\n                {mType:'keyboard',    mID:'4dXGRr',  mSrc:null,                        mSampler:{ filter: 'linear', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }},\r\n                {mType:'webcam',      mID:'4sf3zn',  mSrc:'/media/a/32405eb234ec607dc883db7f5f354822fd453a79aca95107c01cfb140b4c9a2a.png', mSampler:{ filter: 'linear', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }},\r\n                {mType:'mic',         mID:'XdXGRr',  mSrc:'/media/a/b0654e03c81a0764366c8370c57d2b7ef88f79c8fd7c15c5389bbbba750c94c5.png', mSampler:{ filter: 'linear', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }},\r\n                {mType:'musicstream', mID:'new',     mSrc:null,                         mSampler:{ filter: 'linear', wrap: 'clamp', vflip: 'true', srgb: 'false', internal: 'byte' }},\r\n                {mType:'buffer',      mID:'4dXGR8',  mSrc:'/media/previz/buffer00.png', mSampler:{ filter: 'linear', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }},\r\n                {mType:'buffer',      mID:'XsXGR8',  mSrc:'/media/previz/buffer01.png', mSampler:{ filter: 'linear', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }},\r\n                {mType:'buffer',      mID:'4sXGR8',  mSrc:'/media/previz/buffer02.png', mSampler:{ filter: 'linear', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }},\r\n                {mType:'buffer',      mID:'XdfGR8',  mSrc:'/media/previz/buffer03.png', mSampler:{ filter: 'linear', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }},\r\n                {mType:'cubemap',     mID:'4dX3Rr',  mSrc:'/media/previz/cubemap00.png', mSampler:{ filter: 'linear', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }} ];\r\n\r\n        for( let i=0; i\u003c9; i++ )\r\n        {\r\n            let eleAse = document.getElementById( \"miscAsset\"+i );\r\n            let eleImg = document.getElementById( \"miscAssetThumnail\"+i );\r\n            let eleNam = document.getElementById( \"miscAssetName\"+i );\r\n            let eleUse = document.getElementById( \"miscUserName\"+i );\r\n            let eleInf = document.getElementById( \"miscInfo\"+i );\r\n\r\n            eleImg.src = \"/media/previz/\" + filePaths[i];\r\n            eleNam.textContent = names[i];\r\n            eleUse.innerHTML = \"\u003ca class='user' href='/user/shadertoy'\u003eshadertoy\u003c/a\u003e\";\r\n            eleInf.textContent = infos[i];\r\n\r\n            if( i==3 )\r\n            {\r\n                var eleSouncCloud = document.createElement(\"div\");\r\n                eleSouncCloud.id = \"mySoundCloudURLBox\";\r\n                eleSouncCloud.className = \"mySoundCloudURLBox\";\r\n                eleInf.parentNode.appendChild(eleSouncCloud);\r\n\r\n                var eleText = document.createTextNode(\"Pick Soundcloud track:\\n\\n\"); \r\n                eleSouncCloud.appendChild(eleText);\r\n\r\n                var eleInput = document.createElement(\"input\"); \r\n                eleInput.type = \"text\";\r\n                eleInput.id = \"mySoundCloudURL\";\r\n                eleInput.className = \"mySoundCloudURL\";\r\n                eleInput.placeholder=\"Track URL\";\r\n                eleInput.maxLength = 255;\r\n                eleSouncCloud.appendChild(eleInput);\r\n\r\n                gDialog.mSoundCloudsURL = eleInput;\r\n                gDialog.mSoundCloudsURLBox = eleSouncCloud;\r\n\r\n                eleInput.onkeypress = function (e)\r\n                {\r\n                    if (!e) e = window.event;\r\n                    var keyCode = e.keyCode || e.which;\r\n                    if (keyCode == 13)\r\n                    {\r\n                        var url = this.value.trim();\r\n                        if (SC != null)\r\n                        {\r\n                            SC.resolve(url, \r\n                                function (song)\r\n                                {\r\n                                    if (song.streamable == true)\r\n                                    {\r\n                                        gShaderToy.SetTexture(gDialog.gCurrentEditingSlot, { mType: 'musicstream', mID: \"new\", mSrc: url, mSampler: opts[i].mSampler });\r\n                                    }\r\n                                    else { alert('Shadertoy: Soundcloud 1 - This track cannot be streamed'); }\r\n                                },\r\n                                function (error) { \r\n                                    alert('Shadertoy: Soundcloud 2 - ' + error.message); \r\n                                });\r\n                        }\r\n                    }\r\n                    return;\r\n                };\r\n\r\n                eleInput.onclick = function ()\r\n                {\r\n                    this.select();\r\n                };\r\n\r\n                eleImg.onclick = function ()\r\n                {\r\n                    eleSouncCloud.classList.toggle(\"mySoundCloudURLBoxVisible\");\r\n                    eleInput.focus();\r\n                    eleInput.select();\r\n                };\r\n            }\r\n            else\r\n            {\r\n                eleImg.onclick = function()\r\n                                {\r\n                                    gDialog.CloseSoundCloud();\r\n                                    gShaderToy.SetTexture( gDialog.gCurrentEditingSlot, opts[i] );\r\n                                };\r\n            }\r\n        }\r\n    }\r\n    \r\n    function overlay(slot, passType)\r\n    {\r\n\t\tlet isSoundPassType = (passType===\"sound\");\r\n\t\t\r\n        if (gDialog == null)\r\n        {\r\n\t\t    gDialog = {};\r\n\t\t\tgDialog.mCurrent = \"\";\r\n            gDialog.gCurrentEditingSlot = slot;\r\n\r\n            var clickedCallback = function( opts )\r\n            {\r\n                gDialog.CloseSoundCloud();\r\n                gShaderToy.SetTexture( gDialog.gCurrentEditingSlot, opts );\r\n            };\r\n\r\n                                           cmpAssetBrowserMisc();\r\n            gDialog.gBrowserTextures = new cmpAssetBrowser( \"texture\", clickedCallback );\r\n            gDialog.gBrowserCubemaps = new cmpAssetBrowser( \"cubemap\", clickedCallback );\r\n            gDialog.gBrowserVolumes  = new cmpAssetBrowser( \"volume\",  clickedCallback );\r\n            gDialog.gBrowserVideos   = new cmpAssetBrowser( \"video\",   clickedCallback );\r\n            gDialog.gBrowserMusics   = new cmpAssetBrowser( \"music\",   clickedCallback );\r\n\r\n            gDialog.mEle = document.getElementById(\"pickTexture_image\");\r\n            gDialog.mIsMoving = false;\r\n            gDialog.mStartPosX = 0;\r\n            gDialog.mStartPosY = 0;\r\n\r\n            gDialog.mHeader = document.getElementById(\"pickTextureHeader\" );\r\n\r\n            gDialog.mHeader.onmousedown = function (ev) { gDialog.mIsMoving = true; gDialog.mStartPosX = ev.screenX - gDialog.mEle.offsetLeft;gDialog.mStartPosY = ev.screenY - gDialog.mEle.offsetTop; };\r\n            gDialog.mHeader.onmouseup = function (ev)   { gDialog.mIsMoving = false; };\r\n            gDialog.mVisible = false;\r\n\r\n            document.onmousemove = function (ev)\r\n            {\r\n                if (gDialog != null \u0026\u0026 gDialog.mIsMoving)\r\n                {\r\n                    gDialog.mEle.style.left = (ev.screenX - gDialog.mStartPosX) + \"px\";\r\n                    gDialog.mEle.style.top = (ev.screenY - gDialog.mStartPosY) + \"px\";\r\n                }\r\n            };\r\n        }\r\n\r\n        // visibility\r\n        if (gDialog.mVisible)\r\n        {\r\n            gDialog.mVisible = false;\r\n            gDialog.mEle.style.visibility = \"hidden\";\r\n            gDialog.mEle.style.display = \"none\";\r\n        }\r\n        else\r\n        {\r\n            gDialog.mVisible = true;\r\n            gDialog.mEle.style.visibility = \"visible\";\r\n            gDialog.mEle.style.display = \"block\";\r\n        }\r\n\r\n        gDialog.gCurrentEditingSlot = slot;\r\n\r\n        if( slot!=null )\r\n        {\r\n\r\n            var eleTabMusic = document.getElementById(\"liMusic\");\r\n            var eleTabVideos = document.getElementById(\"liVideos\");\r\n\t\t\tvar eleTabMisc = document.getElementById(\"liMisc\");\r\n            eleTabMusic.style.display = (isSoundPassType)?\"none\":\"inherit\";\r\n            eleTabVideos.style.display = (isSoundPassType)?\"none\":\"inherit\";\r\n\t\t\teleTabMisc.style.display = (isSoundPassType)?\"none\":\"inherit\";\r\n\r\n\t\t\tif( gDialog.mCurrent===\"\" )\r\n\t\t\t{\r\n\t\t\t\tif( isSoundPassType ) openTab( 'Textures' );\r\n                else                  openTab( 'Misc' );\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n            if( !isSoundPassType )\r\n            {\r\n                var texture = gShaderToy.GetTexture(slot);\r\n                if (texture != null \u0026\u0026 texture.mType == \"musicstream\")\r\n                    gDialog.mSoundCloudsURL.value = texture.mSrc;\r\n                else\r\n                    gDialog.mSoundCloudsURL.value = \"\";\r\n                gDialog.CloseSoundCloud = function () { gDialog.mSoundCloudsURLBox.classList.remove(\"mySoundCloudURLBoxVisible\"); };\r\n            }\r\n            else\r\n            {\r\n                gDialog.CloseSoundCloud = function() { }\r\n\t\t\t\tif( gDialog.mCurrent!==\"Textures\" \u0026\u0026\r\n\t\t\t\t    gDialog.mCurrent!==\"Cubemaps\" \u0026\u0026\r\n                    gDialog.mCurrent!==\"Volumes\" ) openTab( 'Textures' );\r\n            }\r\n\r\n\r\n            var eleDialogTitle = document.getElementById(\"pickTextureDialogTitle\");\r\n            eleDialogTitle.textContent = \"Select input for iChannel\" + slot;\r\n        }\r\n    }\r\n\r\n\r\n    function openTab(name)\r\n    {\r\n        let tabcontent = document.getElementsByClassName(\"tabcontent\");\r\n        for (let i = 0; i \u003c tabcontent.length; i++) \r\n        {\r\n            tabcontent[i].style.display = \"none\";\r\n        }\r\n\t\tdocument.getElementById(\"div\" + name).style.display = \"block\";\r\n\r\n        //let tablinks = document.getElementsByClassName(\"tablinks\");\r\n        //for (let i = 0; i \u003c tablinks.length; i++) \r\n        //{\r\n            //tablinks[i].classList.remove(\"active\");\r\n        //}\r\n\t\tdocument.getElementById(\"liMisc\").classList.remove(\"active\");\r\n\t\tdocument.getElementById(\"liTextures\").classList.remove(\"active\");\r\n\t\tdocument.getElementById(\"liCubemaps\").classList.remove(\"active\");\r\n\t\tdocument.getElementById(\"liVolumes\").classList.remove(\"active\");\r\n\t\tdocument.getElementById(\"liVideos\").classList.remove(\"active\");\r\n\t\tdocument.getElementById(\"liMusic\").classList.remove(\"active\");\r\n\t\tdocument.getElementById(\"li\"+name).classList.add(\"active\");\r\n\r\n        if( name === \"Textures\" ) { gDialog.gBrowserTextures.Load(); }\r\n        if( name === \"Cubemaps\" ) { gDialog.gBrowserCubemaps.Load(); }\r\n        if( name === \"Volumes\" )  { gDialog.gBrowserVolumes.Load(); }\r\n        if( name === \"Videos\" )   { gDialog.gBrowserVideos.Load(); }\r\n        if( name === \"Music\" )    { gDialog.gBrowserMusics.Load(); }\r\n\t\t\r\n\t\tgDialog.mCurrent = name;\r\n    }\r\n\u003c/script\u003e\r\n\r\n\u003cdiv id=\"pickTexture_image\" class=\"dialog\"\u003e\r\n\r\n    \u003cdiv id=\"pickTextureHeader\" class=\"dialogHeader\" \u003e\r\n        \u003cdiv class=\"dialogTitle\" id=\"pickTextureDialogTitle\"\u003eSelect input for iChannel\u003c/div\u003e\r\n        \u003cdiv class=\"dialogCloseButton\" onclick='overlay(null,\"image\")'\u003e\u003c/div\u003e\r\n    \u003c/div\u003e\r\n\r\n    \u003cdiv class=\"dialogContent\"\u003e\r\n        \u003cdiv class=\"dialogContentBody\"\u003e\r\n            \u003cdiv style=\"width:90%\"\u003e\r\n                \u003cul class=\"tab_container\"\u003e\r\n                    \u003cli id=\"liMisc\"    \u003e\u003ca href=\"javascript:void(0)\" onclick=\"openTab('Misc')\"\u003eMisc\u003c/a\u003e\u003c/li\u003e\r\n                    \u003cli id=\"liTextures\"\u003e\u003ca href=\"javascript:void(0)\" onclick=\"openTab('Textures')\"\u003eTextures\u003c/a\u003e\u003c/li\u003e\r\n                    \u003cli id=\"liCubemaps\"\u003e\u003ca href=\"javascript:void(0)\" onclick=\"openTab('Cubemaps')\"\u003eCubemaps\u003c/a\u003e\u003c/li\u003e\r\n                    \u003cli id=\"liVolumes\" \u003e\u003ca href=\"javascript:void(0)\" onclick=\"openTab('Volumes')\"\u003eVolumes\u003c/a\u003e\u003c/li\u003e\r\n                    \u003cli id=\"liVideos\"  \u003e\u003ca href=\"javascript:void(0)\" onclick=\"openTab('Videos')\"\u003eVideos\u003c/a\u003e\u003c/li\u003e\r\n                    \u003cli id=\"liMusic\"   \u003e\u003ca href=\"javascript:void(0)\" onclick=\"openTab('Music')\"\u003eMusic\u003c/a\u003e\u003c/li\u003e\r\n                \u003c/ul\u003e\r\n                \u003cdiv style=\"width:100%;height:2px;background-color:#404040;\"\u003e\u003c/div\u003e\r\n            \u003c/div\u003e\r\n            \u003cdiv class=\"tabcontent\" id=\"divMisc\"  style=\"display:block;\"\u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='miscAsset0' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='miscAssetThumnail0'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='miscAssetName0'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='miscUserName0'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='miscInfo0'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='miscAsset1' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='miscAssetThumnail1'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='miscAssetName1'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='miscUserName1'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='miscInfo1'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='miscAsset2' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='miscAssetThumnail2'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='miscAssetName2'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='miscUserName2'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='miscInfo2'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='miscAsset3' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='miscAssetThumnail3'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='miscAssetName3'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='miscUserName3'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='miscInfo3'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='miscAsset4' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='miscAssetThumnail4'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='miscAssetName4'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='miscUserName4'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='miscInfo4'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='miscAsset5' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='miscAssetThumnail5'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='miscAssetName5'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='miscUserName5'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='miscInfo5'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='miscAsset6' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='miscAssetThumnail6'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='miscAssetName6'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='miscUserName6'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='miscInfo6'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='miscAsset7' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='miscAssetThumnail7'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='miscAssetName7'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='miscUserName7'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='miscInfo7'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='miscAsset8' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='miscAssetThumnail8'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='miscAssetName8'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='miscUserName8'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='miscInfo8'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003cbr\u003e\u003c/br\u003e\u003cdiv id='miscNav' class='navigation'\u003e\u003c/div\u003e\u003c/div\u003e\r\n            \u003cdiv class=\"tabcontent\" id=\"divTextures\"\u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='textureAsset0' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='textureAssetThumnail0'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='textureAssetName0'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='textureUserName0'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='textureInfo0'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='textureAsset1' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='textureAssetThumnail1'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='textureAssetName1'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='textureUserName1'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='textureInfo1'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='textureAsset2' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='textureAssetThumnail2'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='textureAssetName2'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='textureUserName2'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='textureInfo2'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='textureAsset3' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='textureAssetThumnail3'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='textureAssetName3'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='textureUserName3'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='textureInfo3'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='textureAsset4' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='textureAssetThumnail4'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='textureAssetName4'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='textureUserName4'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='textureInfo4'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='textureAsset5' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='textureAssetThumnail5'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='textureAssetName5'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='textureUserName5'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='textureInfo5'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='textureAsset6' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='textureAssetThumnail6'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='textureAssetName6'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='textureUserName6'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='textureInfo6'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='textureAsset7' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='textureAssetThumnail7'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='textureAssetName7'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='textureUserName7'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='textureInfo7'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='textureAsset8' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='textureAssetThumnail8'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='textureAssetName8'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='textureUserName8'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='textureInfo8'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003cbr\u003e\u003c/br\u003e\u003cdiv id='textureNav' class='navigation'\u003e\u003c/div\u003e\u003c/div\u003e\r\n            \u003cdiv class=\"tabcontent\" id=\"divVideos\"\u003e  \u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='videoAsset0' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='videoAssetThumnail0'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='videoAssetName0'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='videoUserName0'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='videoInfo0'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='videoAsset1' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='videoAssetThumnail1'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='videoAssetName1'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='videoUserName1'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='videoInfo1'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='videoAsset2' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='videoAssetThumnail2'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='videoAssetName2'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='videoUserName2'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='videoInfo2'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='videoAsset3' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='videoAssetThumnail3'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='videoAssetName3'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='videoUserName3'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='videoInfo3'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='videoAsset4' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='videoAssetThumnail4'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='videoAssetName4'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='videoUserName4'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='videoInfo4'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='videoAsset5' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='videoAssetThumnail5'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='videoAssetName5'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='videoUserName5'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='videoInfo5'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='videoAsset6' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='videoAssetThumnail6'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='videoAssetName6'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='videoUserName6'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='videoInfo6'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='videoAsset7' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='videoAssetThumnail7'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='videoAssetName7'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='videoUserName7'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='videoInfo7'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='videoAsset8' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='videoAssetThumnail8'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='videoAssetName8'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='videoUserName8'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='videoInfo8'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003cbr\u003e\u003c/br\u003e\u003cdiv id='videoNav' class='navigation'\u003e\u003c/div\u003e\u003c/div\u003e\r\n            \u003cdiv class=\"tabcontent\" id=\"divCubemaps\"\u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='cubemapAsset0' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='cubemapAssetThumnail0'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='cubemapAssetName0'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='cubemapUserName0'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='cubemapInfo0'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='cubemapAsset1' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='cubemapAssetThumnail1'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='cubemapAssetName1'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='cubemapUserName1'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='cubemapInfo1'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='cubemapAsset2' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='cubemapAssetThumnail2'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='cubemapAssetName2'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='cubemapUserName2'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='cubemapInfo2'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='cubemapAsset3' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='cubemapAssetThumnail3'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='cubemapAssetName3'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='cubemapUserName3'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='cubemapInfo3'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='cubemapAsset4' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='cubemapAssetThumnail4'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='cubemapAssetName4'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='cubemapUserName4'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='cubemapInfo4'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='cubemapAsset5' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='cubemapAssetThumnail5'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='cubemapAssetName5'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='cubemapUserName5'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='cubemapInfo5'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='cubemapAsset6' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='cubemapAssetThumnail6'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='cubemapAssetName6'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='cubemapUserName6'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='cubemapInfo6'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='cubemapAsset7' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='cubemapAssetThumnail7'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='cubemapAssetName7'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='cubemapUserName7'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='cubemapInfo7'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='cubemapAsset8' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='cubemapAssetThumnail8'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='cubemapAssetName8'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='cubemapUserName8'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='cubemapInfo8'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003cbr\u003e\u003c/br\u003e\u003cdiv id='cubemapNav' class='navigation'\u003e\u003c/div\u003e\u003c/div\u003e\r\n            \u003cdiv class=\"tabcontent\" id=\"divVolumes\"\u003e \u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='volumeAsset0' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='volumeAssetThumnail0'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='volumeAssetName0'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='volumeUserName0'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='volumeInfo0'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='volumeAsset1' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='volumeAssetThumnail1'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='volumeAssetName1'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='volumeUserName1'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='volumeInfo1'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='volumeAsset2' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='volumeAssetThumnail2'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='volumeAssetName2'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='volumeUserName2'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='volumeInfo2'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='volumeAsset3' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='volumeAssetThumnail3'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='volumeAssetName3'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='volumeUserName3'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='volumeInfo3'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='volumeAsset4' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='volumeAssetThumnail4'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='volumeAssetName4'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='volumeUserName4'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='volumeInfo4'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='volumeAsset5' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='volumeAssetThumnail5'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='volumeAssetName5'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='volumeUserName5'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='volumeInfo5'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='volumeAsset6' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='volumeAssetThumnail6'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='volumeAssetName6'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='volumeUserName6'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='volumeInfo6'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='volumeAsset7' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='volumeAssetThumnail7'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='volumeAssetName7'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='volumeUserName7'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='volumeInfo7'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='volumeAsset8' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='volumeAssetThumnail8'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='volumeAssetName8'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='volumeUserName8'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='volumeInfo8'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003cbr\u003e\u003c/br\u003e\u003cdiv id='volumeNav' class='navigation'\u003e\u003c/div\u003e\u003c/div\u003e\r\n            \u003cdiv class=\"tabcontent\" id=\"divMusic\"\u003e   \u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='musicAsset0' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='musicAssetThumnail0'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='musicAssetName0'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='musicUserName0'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='musicInfo0'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='musicAsset1' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='musicAssetThumnail1'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='musicAssetName1'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='musicUserName1'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='musicInfo1'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='musicAsset2' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='musicAssetThumnail2'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='musicAssetName2'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='musicUserName2'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='musicInfo2'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='musicAsset3' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='musicAssetThumnail3'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='musicAssetName3'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='musicUserName3'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='musicInfo3'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='musicAsset4' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='musicAssetThumnail4'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='musicAssetName4'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='musicUserName4'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='musicInfo4'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='musicAsset5' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='musicAssetThumnail5'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='musicAssetName5'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='musicUserName5'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='musicInfo5'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='musicAsset6' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='musicAssetThumnail6'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='musicAssetName6'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='musicUserName6'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='musicInfo6'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='musicAsset7' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='musicAssetThumnail7'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='musicAssetName7'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='musicUserName7'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='musicInfo7'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003ctd\u003e\u003cdiv class='divAsset' id='musicAsset8' \u003e\u003ctable\u003e\u003ctr\u003e\u003ctd\u003e\u003cimg class='inputThumbnail' id='musicAssetThumnail8'/\u003e\u003c/td\u003e\u003ctd class='inputInfoColumn'\u003e\u003cdiv style='position:absolute'\u003e\u003cspan class='spanName' id='musicAssetName8'\u003e\u003c/span\u003e\u003cbr\u003eby \u003cspan class='spanUser' id='musicUserName8'\u003e\u003c/span\u003e\u003cbr\u003e\u003cbr\u003e\u003cspan class='spanDescription' id='musicInfo8'\u003e\u003c/br\u003e\u003c/span\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003c/div\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\u003cbr\u003e\u003c/br\u003e\u003cdiv id='musicNav' class='navigation'\u003e\u003c/div\u003e\u003c/div\u003e\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n    \u003c!-- glslHelp ================================================================================ --\u003e\r\n    \r\n\u003cscript\u003e\r\n\r\nvar gGLSLHelp = null;\r\n\r\nfunction showHelp()\r\n{\r\n    if( gGLSLHelp==null )\r\n    {\r\n        gGLSLHelp = {};\r\n        gGLSLHelp.mEle = document.getElementById(\"dlgHelp\");\r\n        gGLSLHelp.mHeader = document.getElementById(\"dlgHelpHeader\");\r\n        gGLSLHelp.mIsMoving = false;\r\n        gGLSLHelp.mStartPosX = 0;\r\n        gGLSLHelp.mStartPosY = 0;\r\n        gGLSLHelp.mHeader.onmousedown = function(ev) { gGLSLHelp.mIsMoving = true; gGLSLHelp.mStartPosX = ev.screenX - gGLSLHelp.mEle.offsetLeft; gGLSLHelp.mStartPosY = ev.screenY - gGLSLHelp.mEle.offsetTop; };\r\n        gGLSLHelp.mHeader.onmouseup   = function(ev) { gGLSLHelp.mIsMoving = false; };\r\n        gGLSLHelp.mVisible = false;\r\n    }\r\n\r\n    document.onmousemove = function( ev )\r\n    {\r\n        if( gGLSLHelp!=null \u0026\u0026 gGLSLHelp.mIsMoving )\r\n        {\r\n            gGLSLHelp.mEle.style.left = (ev.screenX-gGLSLHelp.mStartPosX) + \"px\";\r\n            gGLSLHelp.mEle.style.top  = (ev.screenY-gGLSLHelp.mStartPosY) + \"px\";\r\n        }\r\n    }\r\n\r\n    if( gGLSLHelp.mVisible )\r\n    {\r\n        gGLSLHelp.mVisible = false;\r\n\t    gGLSLHelp.mEle.style.opacity = \"0.0\";\r\n        gGLSLHelp.mEle.style.visibility = \"hidden\";\r\n    }\r\n    else\r\n    {\r\n        gGLSLHelp.mVisible = true;\r\n\t    gGLSLHelp.mEle.style.opacity = \"1.0\";\r\n        gGLSLHelp.mEle.style.visibility = \"visible\";\r\n    }\r\n}\r\n\u003c/script\u003e\r\n\r\n\r\n\u003cdiv id=\"dlgHelp\" class=\"dialog\"\u003e\r\n    \u003cdiv id=\"dlgHelpHeader\" class=\"dialogHeader\" \u003e\r\n      \u003cdiv class=\"dialogTitle\"\u003eGLSL Help\u003c/div\u003e\r\n      \u003cdiv class=\"dialogCloseButton\" onclick='showHelp()'\u003e\u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class=\"dialogContent\"\u003e\r\n    \u003cdiv class=\"dialogContentBody\"\u003e\r\n\r\n        This help only covers the parts of GLSL ES that are relevant for Shadertoy. For the complete specification please have a look at        \u003ca class=\"user\" href=\"https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf\"\u003eGLSL ES specification\u003c/a\u003e\u003cbr\u003e\r\n                \u003cbr/\u003e\r\n        \u003ch2\u003eLanguage:\u003c/h2\u003e\r\n        \u003chr/\u003e\r\n        \u003cul\u003e\r\n            \u003cli\u003e\u003cb\u003eVersion:\u003c/b\u003e WebGL 2.0\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eArithmetic:\u003c/b\u003e ( ) + - ! * / %\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eLogical/Relatonal:\u003c/b\u003e ~  \u0026lt;  \u0026gt;  \u0026lt;=   \u0026gt;=  ==  !=  \u0026amp;\u0026amp;  ||\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eBit Operators:\u003c/b\u003e \u0026amp; ^ | \u0026lt;\u0026lt; \u0026gt;\u0026gt;\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eComments:\u003c/b\u003e // /* */\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eTypes:\u003c/b\u003e void bool int uint float vec2 vec3 vec4 bvec2 bvec3 bvec4 ivec2 ivec3 ivec4 uvec2 uvec3 uvec4 mat2 mat3 mat4 mat?x? sampler2D, sampler3D, samplerCube\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eFormat:\u003c/b\u003e float a = 1.0; int b = 1; uint i = 1U; int i = 0x1;\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eFunction Parameter Qualifiers:\u003c/b\u003e [none], in, out, inout\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eGlobal Variable Qualifiers:\u003c/b\u003e const\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eVector Components:\u003c/b\u003e .xyzw .rgba .stpq\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eFlow Control:\u003c/b\u003e if else for return break continue switch/case\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eOutput:\u003c/b\u003e vec4 fragColor\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eInput:\u003c/b\u003e vec2 fragCoord\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003ePreprocessor:\u003c/b\u003e #define #undef #if #ifdef #ifndef #else #elif #endif #error #pragma #line\u003c/li\u003e\r\n        \u003c/ul\u003e\r\n\r\n        \u003cbr/\u003e\r\n        \u003ch2\u003eBuilt-in Functions:\u003c/h2\u003e\r\n        \u003chr/\u003e\r\n        \u003ctable\u003e\r\n        \u003ctr\u003e\r\n        \u003ctd valign=\"top\"\u003e\r\n          \u003cul\u003e\r\n              \u003cli\u003eftype radians (ftype degrees)\u003c/li\u003e\r\n              \u003cli\u003eftype degrees (ftype radians)\u003c/li\u003e\r\n              \u003cli\u003eftype sin (ftype angle)\u003c/li\u003e\r\n              \u003cli\u003eftype cos (ftype angle)\u003c/li\u003e\r\n              \u003cli\u003eftype tan (ftype angle)\u003c/li\u003e\r\n              \u003cli\u003eftype asin (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype acos (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype atan (ftype y, ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype atan (ftype y_over_x)\u003c/li\u003e\r\n              \u003cli\u003eftype sinh (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype cosh (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype tanh (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype asinh (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype acosh (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype atanh f(type x)\u003c/li\u003e\r\n          \u003c/ul\u003e\r\n          \u003cul\u003e\r\n              \u003cli\u003eftype pow (ftype x, ftype y)\u003c/li\u003e\r\n              \u003cli\u003eftype exp (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype log (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype exp2 (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype log2 (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype sqrt (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype inversesqrt (ftype x)\u003c/li\u003e\r\n          \u003c/ul\u003e\r\n          \u003cul\u003e\r\n              \u003cli\u003etype abs (type x)\u003c/li\u003e\r\n              \u003cli\u003etype sign (type x)\u003c/li\u003e\r\n              \u003cli\u003eftype floor (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype ceil (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype trunc (type x)\u003c/li\u003e\r\n              \u003cli\u003eftype fract (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype mod (ftype x, ftype y)\u003c/li\u003e\r\n              \u003cli\u003eftype modf (ftype x, out ftype i)\u003c/li\u003e\r\n              \u003cli\u003etype min (type x, type y)\u003c/li\u003e\r\n              \u003cli\u003etype max (type x, type y)\u003c/li\u003e\r\n              \u003cli\u003etype clamp (type x, type minV, type maxV)\u003c/li\u003e\r\n              \u003cli\u003eftype mix (ftype x, ftype y, ftype a)\u003c/li\u003e\r\n              \u003cli\u003etype step (type edge, type x)\u003c/li\u003e\r\n              \u003cli\u003eftype smoothstep (ftype a, ftype b, ftype x)\u003c/li\u003e\r\n          \u003c/ul\u003e\r\n          \u003cul\u003e\r\n              \u003cli\u003efloat length (vec x)\u003c/li\u003e\r\n              \u003cli\u003efloat distance (vec p0, vec p1)\u003c/li\u003e\r\n              \u003cli\u003efloat dot (vec x, vec y)\u003c/li\u003e\r\n              \u003cli\u003evec3 cross (vec3 x, vec3 y)\u003c/li\u003e\r\n              \u003cli\u003evec  normalize (vec x)\u003c/li\u003e\r\n              \u003cli\u003evec  faceforward (vec N, vec I, vec Nref)\u003c/li\u003e\r\n              \u003cli\u003evec  reflect (vec I, vec N)\u003c/li\u003e\r\n              \u003cli\u003evec  refract (vec I, vec N, float eta)\u003c/li\u003e\r\n              \u003cli\u003efloat determinant(mat? m)\u003c/li\u003e\r\n              \u003cli\u003emat?x? outerProduct(vec c, vec r)\u003c/li\u003e\r\n              \u003cli\u003emat?x? matrixCompMult (mat?x? x, mat?x? y)\u003c/li\u003e\r\n              \u003cli\u003emat? inverse (mat? inverse)\u003c/li\u003e\r\n              \u003cli\u003emat?x? transpose (mat?x? inverse)\u003c/li\u003e\r\n          \u003c/ul\u003e\r\n        \u003c/td\u003e\r\n        \u003ctd valign=\"top\"\u003e\r\n          \u003cul\u003e\r\n              \u003cli\u003evec4  texture( sampler , vec coord [, float bias])\u003c/li\u003e\r\n              \u003cli\u003evec4  textureLod(  sampler, vec coord, float lod)\u003c/li\u003e\r\n              \u003cli\u003evec4  textureLodOffset( sampler sampler, vec coord, float lod, ivec offset)\u003c/li\u003e\r\n              \u003cli\u003evec4  textureGrad( sampler , vec coord, vec2 dPdx, vec2 dPdy)\u003c/li\u003e\r\n              \u003cli\u003evec4  textureGradOffset sampler , vec coord, vec dPdx, vec dPdy, vec offset)\u003c/li\u003e\r\n              \u003cli\u003evec4  textureProj( sampler , vec coord [, float bias])\u003c/li\u003e\r\n              \u003cli\u003evec4  textureProjLod( sampler , vec coord, float lod)\u003c/li\u003e\r\n              \u003cli\u003evec4  textureProjLodOffset( sampler , vec coord, float lod, vec? offset)\u003c/li\u003e\r\n              \u003cli\u003evec4  textureProjGrad( sampler , vec coord, vec2 dPdx, vec2 dPdy)\u003c/li\u003e\r\n              \u003cli\u003evec4  texelFetch( sampler , ivec coord, int lod)\u003c/li\u003e\r\n              \u003cli\u003evec4  texelFetchOffset( sampler, ivec coord, int lod, ivec offset )\u003c/li\u003e\r\n              \u003cli\u003eivec  textureSize( sampler , int lod)\u003c/li\u003e\r\n          \u003c/ul\u003e\r\n          \u003cul\u003e\r\n              \u003cli\u003eftype dFdx (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype dFdy (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype fwidth (ftype p)\u003c/li\u003e\r\n          \u003c/ul\u003e\r\n          \u003cul\u003e\r\n              \u003cli\u003ebtype isnan (ftype x)\u003c/li\u003e\r\n              \u003cli\u003ebtype isinf (ftype x)\u003c/li\u003e\r\n              \u003cli\u003eftype intBitsToFloat (itype v)\u003c/li\u003e\r\n              \u003cli\u003eftype uintBitsToFloat (utype v)\u003c/li\u003e\r\n              \u003cli\u003eitype floatBitsToInt (ftype v)\u003c/li\u003e\r\n              \u003cli\u003eutype floatBitsToUint (ftype v)\u003c/li\u003e\r\n              \u003cli\u003euint packSnorm2x16 (vec2 v)\u003c/li\u003e\r\n              \u003cli\u003euint packUnorm2x16 (vec2 v)\u003c/li\u003e\r\n              \u003cli\u003evec2 unpackSnorm2x16 (uint p)\u003c/li\u003e\r\n              \u003cli\u003evec2 unpackUnorm2x16 (uint p)\u003c/li\u003e\r          \u003c/ul\u003e\r\n          \u003cul\u003e\r\n              \u003cli\u003ebvec lessThan (vec x, vec y)\u003c/li\u003e\r\n              \u003cli\u003ebvec lessThanEqual (vec x, vec y)\u003c/li\u003e\r\n              \u003cli\u003ebvec greaterThan (vec x, vec y)\u003c/li\u003e\r\n              \u003cli\u003ebvec greaterThanEqual (vec x, vec y)\u003c/li\u003e\r\n              \u003cli\u003ebvec equal (type x, type y)\u003c/li\u003e\r\n              \u003cli\u003ebvec notEqual (type x, type y)\u003c/li\u003e\r\n              \u003cli\u003ebool any (bvec x)\u003c/li\u003e\r\n              \u003cli\u003ebool all (bvec x)\u003c/li\u003e\r\n              \u003cli\u003ebvec not (bvec x)\u003c/li\u003e\r\n          \u003c/ul\u003e\r\n        \u003c/td\u003e\r\n        \u003c/tr\u003e\r\n        \u003c/table\u003e\r\n        \u003cbr/\u003e\r\n        \u003ch2\u003eHow-to\u003c/h2\u003e\r\n        \u003chr/\u003e\r\n        \u003cul\u003e\r\n            \u003cli\u003e\u003cb\u003eUse structs:\u003c/b\u003e struct myDataType { float occlusion; vec3 color; }; myDataType myData = myDataType(0.7, vec3(1.0, 2.0, 3.0));\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eInitialize arrays:\u003c/b\u003e float[] x = float[] (0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6);\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eDo conversions:\u003c/b\u003e int a = 3; float b = float(a);\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eDo component swizzling:\u003c/b\u003e vec4 a = vec4(1.0,2.0,3.0,4.0); vec4 b = a.zyyw;\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003eAccess matrix components:\u003c/b\u003e mat4 m; m[1] = vec4(2.0); m[0][0] = 1.0; m[2][3] = 2.0;\u003c/li\u003e\r\n        \u003c/ul\u003e\r\n        \u003cbr/\u003e\r\n        \u003ch2\u003eBe careful!\u003c/h2\u003e\r\n        \u003chr/\u003e\r\n        \u003cul\u003e\r\n            \u003cli\u003e\u003cb\u003ethe \u003ci\u003ef\u003c/i\u003e suffix for floating pont numbers:\u003c/b\u003e 1.0f is illegal in GLSL. You must use 1.0\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003esaturate():\u003c/b\u003e saturate(x) doesn't exist in GLSL. Use clamp(x,0.0,1.0) instead\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003epow/sqrt:\u003c/b\u003e please don't feed sqrt() and pow() with negative numbers. Add an abs() or max(0.0,) to the argument\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003emod:\u003c/b\u003e please don't do mod(x,0.0). This is undefined in some platforms\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003evariables:\u003c/b\u003e initialize your variables! Don't assume they'll be set to zero by default\u003c/li\u003e\r\n            \u003cli\u003e\u003cb\u003efunctions:\u003c/b\u003e don't call your functions the same name as any of your variables\u003c/li\u003e\r\n        \u003c/ul\u003e\r\n        \u003cbr/\u003e\r\n        \u003ch2\u003eShadertoy Inputs\u003c/h2\u003e\r\n        \u003chr/\u003e\r\n        \u003ctable\u003e\r\n            \u003ctr\u003e\u003ctd\u003e\u003cb\u003evec3\u003c/b\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003eiResolution\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eimage/buffer\u003c/td\u003e\u003ctd\u003eThe viewport resolution (z is pixel aspect ratio, usually 1.0)\u003c/td\u003e\u003c/tr\u003e\r\n            \u003ctr\u003e\u003ctd\u003e\u003cb\u003efloat\u003c/b\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003eiTime\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eimage/sound/buffer\u003c/td\u003e\u003ctd\u003eCurrent time in seconds\u003c/td\u003e\u003c/tr\u003e\r\n            \u003ctr\u003e\u003ctd\u003e\u003cb\u003efloat\u003c/b\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003eiTimeDelta\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eimage/buffer\u003c/td\u003e\u003ctd\u003eTime it takes to render a frame, in seconds\u003c/td\u003e\u003c/tr\u003e\r\n            \u003ctr\u003e\u003ctd\u003e\u003cb\u003eint\u003c/b\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003eiFrame\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eimage/buffer\u003c/td\u003e\u003ctd\u003eCurrent frame\u003c/td\u003e\u003c/tr\u003e\r\n            \u003ctr\u003e\u003ctd\u003e\u003cb\u003efloat\u003c/b\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003eiFrameRate\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eimage/buffer\u003c/td\u003e\u003ctd\u003eNumber of frames rendered per second\u003c/td\u003e\u003c/tr\u003e\r\n            \u003ctr\u003e\u003ctd\u003e\u003cb\u003efloat\u003c/b\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003eiChannelTime[4]\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eimage/buffer\u003c/td\u003e\u003ctd\u003eTime for channel (if video or sound), in seconds\u003c/td\u003e\u003c/tr\u003e\r\n            \u003ctr\u003e\u003ctd\u003e\u003cb\u003evec3\u003c/b\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003eiChannelResolution[4]\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eimage/buffer/sound\u003c/td\u003e\u003ctd\u003eInput texture resolution for each channel\u003c/td\u003e\u003c/tr\u003e\r\n            \u003ctr\u003e\u003ctd\u003e\u003cb\u003evec4\u003c/b\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003eiMouse\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eimage/buffer\u003c/td\u003e\u003ctd\u003exy = current pixel coords (if LMB is down). zw = click pixel\u003c/td\u003e\u003c/tr\u003e\r\n            \u003ctr\u003e\u003ctd\u003e\u003cb\u003esampler2D\u003c/b\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003eiChannel{i}\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eimage/buffer/sound\u003c/td\u003e\u003ctd\u003eSampler for input textures i\u003c/td\u003e\u003c/tr\u003e\r\n            \u003ctr\u003e\u003ctd\u003e\u003cb\u003evec4\u003c/b\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003eiDate\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eimage/buffer/sound\u003c/td\u003e\u003ctd\u003eYear, month, day, time in seconds in .xyzw\u003c/td\u003e\u003c/tr\u003e\r\n            \u003ctr\u003e\u003ctd\u003e\u003cb\u003efloat\u003c/b\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003eiSampleRate\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eimage/buffer/sound\u003c/td\u003e\u003ctd\u003eThe sound sample rate (typically 44100)\u003c/td\u003e\u003c/tr\u003e\r\n        \u003c/table\u003e\r\n        \u003cbr/\u003e\r\n        \u003ch2\u003eShadertoy Outputs\u003c/h2\u003e\r\n        \u003chr/\u003e\r\n        Image shaders: fragColor is used as output channel. It is not, for now, mandatory but recommended to leave the alpha channel to 1.0.\u003cbr\u003e\r\n        \u003cbr/\u003e\r\n        Sound shaders: the mainSound() function returns a vec2 containing the left and right (stereo) sound channel wave data.\r\n        \u003cbr/\u003e\r\n        \u003cbr/\u003e\r\n        \u003cbr/\u003e\r\n\r\n    \u003c/div\u003e\r\n    \u003c/div\u003e\r\n\u003c/div\u003e    \u003c!-- alert =============================================================================== --\u003e\r\n    \u003cscript\u003e\r\n\r\n    var gDlgAlert = null;\r\n\r\n    function doAlert( coords, size, title, str, hasButtons, doThing )\r\n    {\r\n    if( gDlgAlert==null )\r\n    {\r\n    gDlgAlert = {};\r\n    gDlgAlert.mEle = document.getElementById(\"dlgAlertShader\");\r\n    gDlgAlert.mIsMoving = false;\r\n    gDlgAlert.mStartPosX = 0;\r\n    gDlgAlert.mStartPosY = 0;\r\n    gDlgAlert.mHasButtons = hasButtons;\r\n    gDlgAlert.mDoThing = doThing;\r\n\r\n    if( !hasButtons )\r\n    {\r\n    var ele = document.getElementById(\"dialogContentButtons\");\r\n    ele.style.visibility = \"hidden\";\r\n    }\r\n    else\r\n    {\r\n    var ele = document.getElementById(\"dialogContentButtons\");\r\n    ele.style.visibility = \"visible\";\r\n    }\r\n\r\n\r\n    if( size != null )\r\n    {\r\n    gDlgAlert.mEle.style.width  = size.mX + \"px\";\r\n    if( size.mY\u003e0 ) gDlgAlert.mEle.style.height = size.mY + \"px\";\r\n    }\r\n\r\n    var eleHeader =  document.getElementById( \"dlgAlertShaderHeader\" );\r\n    eleHeader.onmousedown = function(ev) { gDlgAlert.mIsMoving = true; gDlgAlert.mStartPosX = ev.screenX - gDlgAlert.mEle.offsetLeft; gDlgAlert.mStartPosY = ev.screenY - gDlgAlert.mEle.offsetTop; };\r\n    eleHeader.onmouseup   = function(ev) { gDlgAlert.mIsMoving = false; };\r\n\r\n    gDlgAlert.mEle.style.left = coords.mX - gDlgAlert.mEle.offsetWidth/2 + \"px\";\r\n    gDlgAlert.mEle.style.top  = coords.mY - gDlgAlert.mEle.offsetHeight/2 + 32 + \"px\";\r\n    gDlgAlert.mVisible = false;\r\n    }\r\n\r\n    var ele = document.getElementById(\"dlgAlertTXT\");\r\n    ele.innerHTML = str;\r\n\r\n    ele = document.getElementById(\"dlgAlertTitle\" );\r\n    ele.textContent = title;\r\n\r\n    document.onmousemove = function( ev )\r\n    {\r\n\r\n    if( gDlgAlert!=null \u0026\u0026 gDlgAlert.mIsMoving )\r\n        {\r\n            gDlgAlert.mEle.style.left = (ev.screenX-gDlgAlert.mStartPosX) + \"px\";\r\n            gDlgAlert.mEle.style.top  = (ev.screenY-gDlgAlert.mStartPosY) + \"px\";\r\n        }\r\n    }\r\n\r\n    if( gDlgAlert.mVisible )\r\n    {\r\n        gDlgAlert.mVisible = false;\r\n\t    gDlgAlert.mEle.style.opacity = \"0.0\";\r\n        gDlgAlert.mEle.style.visibility = \"hidden\";\r\n    }\r\n    else\r\n    {\r\n        gDlgAlert.mVisible = true;\r\n\t    gDlgAlert.mEle.style.opacity = \"1.0\";\r\n        gDlgAlert.mEle.style.visibility = \"visible\";\r\n    }\r\n}\r\n\r\nfunction doAlertClose()\r\n{\r\n    gDlgAlert.mVisible = false;\r\n    gDlgAlert.mEle.style.opacity = \"0.0\";\r\n    gDlgAlert.mEle.style.visibility = \"hidden\";\r\n}\r\n\r\nfunction doAlertConfirmClose()\r\n{\r\n    gDlgAlert.mVisible = false;\r\n    gDlgAlert.mEle.style.opacity = \"0.0\";\r\n    gDlgAlert.mEle.style.visibility = \"hidden\";\r\n    gDlgAlert.mDoThing();\r\n}\r\n\u003c/script\u003e\r\n\r\n\u003cdiv id=\"dlgAlertShader\" class=\"dialog\"\u003e\r\n  \u003cdiv class=\"dialogHeader\" id=\"dlgAlertShaderHeader\" \u003e\r\n    \u003cdiv id=\"dlgAlertTitle\" class=\"dialogTitle\"\u003eShare your shader\u003c/div\u003e\r\n    \u003cdiv class=\"dialogCloseButton\" onclick='doAlertClose()'\u003e\u003c/div\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"dialogContent\"\u003e\r\n  \u003cdiv class=\"dialogContentBody\"\u003e\r\n    \u003cdiv id=\"dlgAlertTXT\" style=\"width:90%;overflow-wrap:break-word;\"\u003e\u003c/div\u003e\r\n    \u003cdiv class=\"dialogContentButtons\" id=\"dialogContentButtons\"\u003e\r\n     \u003cdiv class=\"dialogButton\" onclick='doAlertConfirmClose()'\u003eYes\u003c/div\u003e\r\n     \u003cdiv class=\"dialogButton\" onclick='doAlertClose()'\u003eNo\u003c/div\u003e\r\n    \u003c/div\u003e\r\n  \u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/div\u003e\r\n    \u003c!-- BBCodeHelp ================================================================================ --\u003e\r\n    \n\u003cscript\u003e\n\nvar gBBCodeHelp = null;\n\nfunction showBBCodeHelp()\n{\n    if( gBBCodeHelp==null )\n    {\n        gBBCodeHelp = {};\n        gBBCodeHelp.mEle = document.getElementById(\"dlgBBCodeHelp\");\n        gBBCodeHelp.mHeader = document.getElementById(\"dlgBBCodeHelpHeader\");\n        gBBCodeHelp.mIsMoving = false;\n        gBBCodeHelp.mStartPosX = 0;\n        gBBCodeHelp.mStartPosY = 0;\n        gBBCodeHelp.mHeader.onmousedown = function(ev) { gBBCodeHelp.mIsMoving = true; gBBCodeHelp.mStartPosX = ev.screenX - gBBCodeHelp.mEle.offsetLeft; gBBCodeHelp.mStartPosY = ev.screenY - gBBCodeHelp.mEle.offsetTop; };\n        gBBCodeHelp.mHeader.onmouseup   = function(ev) { gBBCodeHelp.mIsMoving = false; };\n        gBBCodeHelp.mVisible = false;\n    }\n        document.onmousemove = function( ev )\n        {\n            if( gBBCodeHelp!=null \u0026\u0026 gBBCodeHelp.mIsMoving )\n            {\n                gBBCodeHelp.mEle.style.left = (ev.screenX-gBBCodeHelp.mStartPosX) + \"px\";\n                gBBCodeHelp.mEle.style.top  = (ev.screenY-gBBCodeHelp.mStartPosY) + \"px\";\n            }\n        }\n\n\n    if( gBBCodeHelp.mVisible )\n    {\n        gBBCodeHelp.mVisible = false;\n\t    gBBCodeHelp.mEle.style.opacity = \"0.0\";\n        gBBCodeHelp.mEle.style.visibility = \"hidden\";\n    }\n    else\n    {\n        gBBCodeHelp.mVisible = true;\n\t    gBBCodeHelp.mEle.style.opacity = \"1.0\";\n        gBBCodeHelp.mEle.style.visibility = \"visible\";\n    }\n}\n\n\n\n\u003c/script\u003e\n\n\u003cdiv id=\"dlgBBCodeHelp\" class=\"dialog\"\u003e\n\n\u003cdiv id=\"dlgBBCodeHelpHeader\" class=\"dialogHeader\" \u003e\n  \u003cdiv class=\"dialogTitle\"\u003eBBCode Help\u003c/div\u003e\n  \u003cdiv class=\"dialogCloseButton\" onclick='showBBCodeHelp()'\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv class=\"dialogContent\"\u003e\n\u003cdiv class=\"dialogContentBody\"\u003e\n    \u003ch2\u003eCodes:\u003c/h2\u003e\n    \u003chr\u003e\n    You can format your comments by using standard \u003ca href=\"http://en.wikipedia.org/wiki/BBCode\" class=\"regular\"\u003eBBCode\u003c/a\u003e. The following tags are implemented in Shadertoy:\n    \u003cbr\u003e\n    \u003cbr\u003e\n    \u003ctable\u003e\n    \u003ctr\u003e\u003ctd\u003eBold\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003e[b]\u003c/b\u003ethis text goes in bold\u003cb\u003e[/b]\u003c/b\u003e\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003eItalic\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003e[i]\u003c/b\u003ethis text goes in italic\u003cb\u003e[/i]\u003c/b\u003e\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003eImages\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003e[img]\u003c/b\u003eurl_to_image\u003cb\u003e[/img]\u003c/b\u003e\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003eUrl\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003e[url]\u003c/b\u003ehttp://www.shadertoy.com\u003cb\u003e[/url]\u003c/b\u003e\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003eUrl\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003e[url=\u003c/b\u003ehttp://www.shadertoy.com\u003cb\u003e]\u003c/b\u003eShadertoy\u003cb\u003e[/url]\u003c/b\u003e\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003eCode\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003e[code]\u003c/b\u003efixed-width text\u003cb\u003e[/code]\u003c/b\u003e\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003eVideo\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u003cb\u003e[video]\u003c/b\u003ehttp://www.youtube.com/watch?v=0ifChJ0nJfM\u003cb\u003e[/video]\u003c/b\u003e\u003c/td\u003e\u003c/tr\u003e\n    \u003c/table\u003e\n    \u003cbr\u003e\n    \u003ch2\u003eEmoticons:\u003c/h2\u003e\n    \u003chr\u003e\n    \u003ctable\u003e\n    \u003ctr\u003e\u003ctd\u003e:)\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u003cimg src=\"/img/emoticonHappy.png\"/\u003e\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003e:(\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u003cimg src=\"/img/emoticonSad.png\"/\u003e\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003e:D\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u003cimg src=\"/img/emoticonLaugh.png\"/\u003e\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003e:love:\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u003cimg src=\"/img/emoticonLove.png\"/\u003e\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003e:octopus:\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u003cimg src=\"/img/emoticonOctopus.png\"/\u003e\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003e:octopusballoon:\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u003cimg src=\"/img/emoticonOctopusBalloon.png\"/\u003e\u003c/td\u003e\u003c/tr\u003e\n    \u003c/table\u003e\n    \u003cbr\u003e\n    \u003ch2\u003eSymbols:\u003c/h2\u003e\n    \u003chr\u003e\n    \u003ctable\u003e\n    \u003ctr\u003e\u003ctd\u003e:alpha:\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u0026#945;\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003e:beta:\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u0026#946;\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003e:delta:\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u0026#916;\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003e:epsilon:\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u0026#949;\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003e:nabla:\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u0026#8711;\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003e:square:\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u0026#178;\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003e:cube:\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u0026#179;\u003c/td\u003e\u003c/tr\u003e\n    \u003ctr\u003e\u003ctd\u003e:limit:\u003c/td\u003e\u003ctd width=\"8px\"\u003e\u003c/td\u003e\u003ctd\u003e\u0026#8784;\u003c/td\u003e\u003c/tr\u003e\n\n    \u003c/table\u003e\n    \u003cbr\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n    \u003c!-- shareShader =============================================================================== --\u003e\r\n    \u003cscript\u003e\r\n\r\n    var gDlgShare = null;\r\n\r\n    function doShareShader( coords )\r\n    {\r\n    if( gDlgShare==null )\r\n    {\r\n    gDlgShare = {};\r\n    gDlgShare.mEle = document.getElementById(\"dlgShareShader\");\r\n    gDlgShare.mIsMoving = false;\r\n    gDlgShare.mStartPosX = 0;\r\n    gDlgShare.mStartPosY = 0;\r\n\r\n    var eleHeader =  document.getElementById( \"dlgShareShaderHeader\" );\r\n    eleHeader.onmousedown = function(ev) { gDlgShare.mIsMoving = true; gDlgShare.mStartPosX = ev.screenX - gDlgShare.mEle.offsetLeft; gDlgShare.mStartPosY = ev.screenY - gDlgShare.mEle.offsetTop; };\r\n    eleHeader.onmouseup   = function(ev) { gDlgShare.mIsMoving = false; };\r\n\r\n    gDlgShare.mEle.style.left = coords.mX + 32 + \"px\";\r\n    gDlgShare.mEle.style.top  = coords.mY - 100 + \"px\";\r\n    gDlgShare.mVisible = false;\r\n\r\n    var ele = document.getElementById(\"shaderURL\");\r\n    var str = \"https://www.shadertoy.com/view/\" + gShaderID;\r\n    ele.textContent = str;\r\n    ele.href = str;\r\n    }\r\n\r\n    document.onmousemove = function( ev )\r\n    {\r\n\r\n    if( gDlgShare!=null \u0026\u0026 gDlgShare.mIsMoving )\r\n        {\r\n            gDlgShare.mEle.style.left = (ev.screenX-gDlgShare.mStartPosX) + \"px\";\r\n            gDlgShare.mEle.style.top  = (ev.screenY-gDlgShare.mStartPosY) + \"px\";\r\n        }\r\n    }\r\n\r\n    if( gDlgShare.mVisible )\r\n    {\r\n        gDlgShare.mVisible = false;\r\n\t    gDlgShare.mEle.style.opacity = \"0.0\";\r\n        gDlgShare.mEle.style.visibility = \"hidden\";\r\n    }\r\n    else\r\n    {\r\n        gDlgShare.mVisible = true;\r\n\t    gDlgShare.mEle.style.opacity = \"1.0\";\r\n        gDlgShare.mEle.style.visibility = \"visible\";\r\n    }\r\n}\r\n\u003c/script\u003e\r\n\r\n\u003cdiv id=\"dlgShareShader\" class=\"dialog\"\u003e\r\n    \u003cdiv class=\"dialogHeader\" id=\"dlgShareShaderHeader\"\u003e\r\n      \u003cdiv class=\"dialogTitle\"\u003eShare your shader\u003c/div\u003e\r\n      \u003cdiv class=\"dialogCloseButton\" onclick='doShareShader(null)'\u003e\u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class=\"dialogContent\"\u003e\r\n    \u003cdiv class=\"dialogContentBody\"\u003e\r\n      \u003cb\u003eDirect link:\u003c/b\u003e\u003cbr\u003e\r\n      \u003cbr\u003e\r\n      Just copy and paste this URL below: \u003ca class=\"regular\" id=\"shaderURL\"\u003e\u003c/a\u003e\u003cbr\u003e\r\n      \u003cbr\u003e\r\n      \u003cb\u003eEmbed:\u003c/b\u003e\u003cbr\u003e\r\n      \u003cbr\u003e\r\n      \u003ctextarea readonly rows=\"4\" cols=\"52\"\u003e\u003ciframe width=\"640\" height=\"360\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/4cfcDX?gui=true\u0026t=10\u0026paused=true\u0026muted=false\" allowfullscreen\u003e\u003c/iframe\u003e\u003c/textarea\u003e    \u003c/div\u003e\r\n    \u003c/div\u003e\r\n\u003c/div\u003e\r\n    \u003c!-- addToPlaylist =============================================================================== --\u003e\r\n    \u003cscript\u003e\r\n    var gDlgAddToPlaylists = { mVisible: false };\r\n\r\n    function iAddShaderToPlaylist( playlistID, shaderID, checkbox )\r\n    {\r\n        var req = new XMLHttpRequest();\r\n        req.onload = function()\r\n        {\r\n            var jsn = req.response;\r\n            if( jsn==null ) return;\r\n            if( jsn.result!=0 )\r\n            {\r\n                checkbox.checked = false;\r\n                alert( \"The shader couldn't be added to the playlist. Please try again.\" );\r\n                console.log( \"Error: The shader couldn't be added to the playlist. Please try again.\" );\r\n            }\r\n        }\r\n        req.open( \"POST\", \"/shadertoy\", true );\r\n        req.responseType = \"json\";\r\n        req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n        var str = \"pas=1\u0026pid=\" + playlistID + \"\u0026sid=\" + shaderID;\r\n        req.send( str );\r\n    }\r\n\r\n    function iDelShaderToPlaylist( playlistID, shaderID, checkbox )\r\n    {\r\n        var req = new XMLHttpRequest();\r\n        req.onload = function()\r\n        {\r\n            var jsn = req.response;\r\n            if( jsn==null ) return;\r\n            if( jsn.result!=0 )\r\n            {\r\n                checkbox.checked = true;\r\n                alert( \"The shader couldn't be deleted from the playlist. Please try again.\" );\r\n                console.log( \"Error: The shader couldn't be removed from the playlist. Please try again.\" );\r\n            }\r\n        }\r\n        req.open( \"POST\", \"/shadertoy\", true );\r\n        req.responseType = \"json\";\r\n        req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n        var str = \"prs=1\u0026pid=\" + playlistID + \"\u0026sid=\" + shaderID;\r\n        req.send( str );\r\n    }\r\n\r\n    function doAddToPlaylist( shaderID, coords )\r\n    {\r\n\t\r\n        var ele = document.getElementById(\"dlgAddToPlaylist\");\r\n        if( gDlgAddToPlaylists.mVisible )\r\n        {\r\n            gDlgAddToPlaylists.mVisible = false;\r\n\r\n\t        ele.style.opacity = \"0.0\";\r\n            ele.style.visibility = \"hidden\";\r\n        }\r\n        else\r\n        {\r\n            gDlgAddToPlaylists.mVisible = true;\r\n\r\n            ele.style.left = coords.mX + 32 + \"px\";\r\n            ele.style.top  = coords.mY -  2 + \"px\";\r\n\r\n\t        ele.style.opacity = \"1.0\";\r\n            ele.style.visibility = \"visible\";\r\n\r\n            // get available playlists\r\n            var req = new XMLHttpRequest();\r\n            req.onload = function()\r\n            {\r\n                var jsn = req.response;\r\n                if( jsn==null ) return;\r\n\r\n                var numPlaylists = jsn.playlists.id.length;\r\n\r\n                if( numPlaylists==0 ) return;\r\n\r\n                var eleSelect = document.getElementById( \"dlgAddPlaylistList\" );\r\n\r\n                while(eleSelect.firstChild) { eleSelect.removeChild(eleSelect.firstChild); }\r\n\r\n                for( let i=0; i\u003cnumPlaylists; i++ )\r\n                {\r\n\t\t\t\t\tif( jsn.playlists.system[i]==1 \u0026\u0026 jsn.playlists.name[i]==\"Loved\") continue;\r\n\r\n                    var eleOption = document.createElement(\"input\");\r\n                    eleOption.type = \"checkbox\";   \r\n                    eleOption.checked = (jsn.playlists.exists[i]===1);\r\n                    eleOption.name = \"dlgAddPlaylistListOptions\";\r\n                    eleOption.id = \"dlgAddPlaylistListOption\" + i;\r\n                    eleOption.value = jsn.playlists.name[i];\r\n                    eleOption.onclick = function()\r\n                                        {\r\n                                            if( this.checked )\r\n                                            {\r\n                                                iAddShaderToPlaylist( jsn.playlists.id[i], shaderID, this );\r\n                                            }\r\n                                            else\r\n                                            {\r\n                                                iDelShaderToPlaylist( jsn.playlists.id[i], shaderID, this );\r\n                                            }\r\n                                        };\r\n                    eleSelect.appendChild(eleOption);\r\n\r\n                    var label = document.createElement(\"label\")\r\n                    label.htmlFor = \"dlgAddPlaylistListOption\" + i;\r\n                    var name = jsn.playlists.name[i];\r\n                    name += \" (\" + ((jsn.playlists.published[i]==0)?\"private\":\"public\") + \")\";\r\n                    var eleText = document.createTextNode(name);\r\n                    label.appendChild(eleText);\r\n                    eleSelect.appendChild(label);\r\n\r\n                    eleSelect.appendChild(document.createElement(\"br\"));\r\n                }\r\n\r\n                eleSelect.appendChild(document.createElement(\"br\"));\r\n\r\n                var eleSpan = document.createElement(\"span\");\r\n                    eleSpan.appendChild(document.createTextNode(\"To create new playlists, go to your \"));\r\n                    var eleA = document.createElement(\"a\");\r\n                    eleA.href = \"/profile\";\r\n                        eleA.appendChild(document.createTextNode(\"profile page\"));\r\n                    eleSpan.appendChild(eleA);\r\n                eleSelect.appendChild(eleSpan);\r\n                \r\n                eleSelect.appendChild(document.createElement(\"br\"));\r\n            };\r\n            req.open( \"POST\", \"/shadertoy\", true );\r\n            req.responseType = \"json\";\r\n            req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n            var str = \"psg=1\u0026sid=\" + shaderID;\r\n            req.send( str );\r\n\r\n        }\r\n\r\n    }\r\n\u003c/script\u003e\r\n\r\n\u003cstyle\u003e\r\ndiv#dlgAddToPlaylist\r\n{\r\n     width:320px;\r\n     height:240px;\r\n     position:absolute;\r\n}\r\n\u003c/style\u003e\r\n\r\n\u003cdiv id=\"dlgAddToPlaylist\" class=\"dialog\"\u003e\r\n\r\n    \u003cdiv class=\"dialogHeader\" id=\"dlgAddToPlaylistHeader\" \u003e\r\n      \u003cdiv class=\"dialogTitle\"\u003eAdd to playlist\u003c/div\u003e\r\n      \u003cdiv class=\"dialogCloseButton\" onclick='doAddToPlaylist(null)'\u003e\u003c/div\u003e\r\n    \u003c/div\u003e\r\n\r\n    \u003cdiv class=\"dialogContent\"\u003e\r\n      \u003cdiv class=\"dialogContentBody\" id=\"dlgAddPlaylistList\"\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n\u003c/div\u003e\r\n    \u003c!-- report =============================================================================== --\u003e\r\n    \u003cscript\u003e\n\n    function doReportShader( shaderID, coords )\n    {\n        doAlert( coords, 320, \n                 \"Report Shader\", \n                 \"Are you sure you want to report this shader?\", \n                  true, \n                  function() \n                  { \n                    var req = new XMLHttpRequest();\n                    req.onload = function()\n                    {\n                        var jsn = req.response;\n                        if( jsn==null ) return;\n                        if( jsn.result==0 ) alert( \"Shader has been reported!\" );            \n                    };\n                    req.open( \"POST\", \"/shadertoy\", true );\n                    req.responseType = \"json\";\n                    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n                    var str = \"s=\" + shaderID + \"\u0026r=1\";\n                    req.send( str );\n                  }\n        );\n    }\n\u003c/script\u003e\r\n\u003c/body\u003e\r\n\r\n\u003c/html\u003e","title":""},{"content":"This is a personal note of some useful shader tricks\nNoises Value Noise Gradient Noise Perlin Simplex Noise31 float noise( in vec3 x ) // in [0,1] { vec3 p = floor(x); vec3 f = fract(x); f = f*f*(3.0-2.0*f); float n = p.x + p.y*57.0 + 113.0*p.z; float res = mix(mix(mix( hash(n+ 0.0), hash(n+ 1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y), mix(mix( hash(n+113.0), hash(n+114.0),f.x), mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z); return res; } [!Hash 是不连续的 noise] value noise ?\nNoise21 float hash11( float n ) // in [0,1] { return fract(sin(n)*43758.5453); } vec2 hash22( vec2 p ) { p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3))); return -1.0 + 2.0*fract(sin(p)*43758.5453123); } vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(.1031,.11369,.13787)); p3 += dot(p3, p3.yxz+19.19); return -1.0 + 2.0 * fract(vec3(p3.x+p3.y, p3.x+p3.z, p3.y+p3.z)*p3.zyx); } float noise( in vec2 p ) { const float K1 = 0.366025404; // (sqrt(3)-1)/2; const float K2 = 0.211324865; // (3-sqrt(3))/6; vec2 i = floor(p + (p.x+p.y)*K1);\tvec2 a = p - i + (i.x+i.y)*K2; vec2 o = (a.x\u0026gt;a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x)); vec2 b = a - o + K2; vec2 c = a - 1.0 + 2.0*K2; vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 ); vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0))); return dot(n, vec3(70.0));\t} Voronoise (celular) Great For 爬行动物皮肤纹理或干燥地砖\nComposited Noise FBM float fbm( vec3 p ) // in [0,1] { if (ANIM) p += iTime; float f; f = 0.5000*noise( p ); p = m*p*2.02; f += 0.2500*noise( p ); p = m*p*2.03; f += 0.1250*noise( p ); p = m*p*2.01; f += 0.0625*noise( p ); return f; } float fbm(vec2 uv) { float total = 0.0, amplitude = 0.1; for (int i = 0; i \u0026lt; 7; i++) { // 每一次迭代，增加一层 noise，即添加一层 color // amplitude 控制噪音的 数量 // frequency 控制尺度的降低 total += noise(uv) * amplitude; uv = frequency * uv; amplitude *= 0.; } return total; } 自然界的形状可以理解为 不同数量 * 不同尺度的形状 的叠加\na simple sum of noise waves with increasing frequencies and decreasing amplitudes.\nShapes 圆环 col = 5. / abs( length( uv + center ) - 0.5 ) / 4e2; ","permalink":"https://mickjagger19.github.io/posts/graphics/shaders/","summary":"\u003cp\u003eThis is a personal note of some useful shader tricks\u003c/p\u003e\n\u003ch2 id=\"noises\"\u003eNoises\u003c/h2\u003e\n\u003ch3 id=\"value-noise\"\u003eValue Noise\u003c/h3\u003e\n\u003ch3 id=\"gradient-noise\"\u003eGradient Noise\u003c/h3\u003e\n\u003ch4 id=\"perlin\"\u003ePerlin\u003c/h4\u003e\n\u003ch4 id=\"simplex\"\u003eSimplex\u003c/h4\u003e\n\u003ch4 id=\"noise31\"\u003eNoise31\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"nf\"\u003enoise\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003evec3\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e// in [0,1]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003evec3\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003efloor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003evec3\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003efract\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mf\"\u003e3.0\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mf\"\u003e2.0\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"mf\"\u003e57.0\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mf\"\u003e113.0\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ez\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eres\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emix\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emix\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emix\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003ehash\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e  \u003cspan class=\"mf\"\u003e0.0\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003ehash\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e  \u003cspan class=\"mf\"\u003e1.0\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003emix\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003ehash\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mf\"\u003e57.0\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003ehash\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mf\"\u003e58.0\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"n\"\u003emix\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emix\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003ehash\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mf\"\u003e113.0\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003ehash\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mf\"\u003e114.0\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003emix\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003ehash\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mf\"\u003e170.0\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003ehash\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mf\"\u003e171.0\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ez\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eres\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e[!Hash 是不连续的 noise]\nvalue noise ?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"noise21\"\u003eNoise21\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"nf\"\u003ehash11\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// in [0,1]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003efract\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"mf\"\u003e43758.5453\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003evec2\u003c/span\u003e \u003cspan class=\"nf\"\u003ehash22\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003evec2\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003evec2\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edot\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003evec2\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mf\"\u003e127.1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mf\"\u003e311.7\u003c/span\u003e\u003cspan class=\"p\"\u003e)),\u003c/span\u003e \u003cspan class=\"n\"\u003edot\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003evec2\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mf\"\u003e269.5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mf\"\u003e183.3\u003c/span\u003e\u003cspan class=\"p\"\u003e)));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mf\"\u003e1.0\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mf\"\u003e2.0\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003efract\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"mf\"\u003e43758.5453123\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003evec3\u003c/span\u003e \u003cspan class=\"nf\"\u003ehash33\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evec3\u003c/span\u003e \u003cspan class=\"n\"\u003ep3\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003ep3\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003efract\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep3\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003evec3\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mf\"\u003e.1031\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mf\"\u003e.11369\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mf\"\u003e.13787\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ep3\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003edot\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ep3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eyxz\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mf\"\u003e19.19\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mf\"\u003e1.0\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mf\"\u003e2.0\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003efract\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evec3\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003ep3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ep3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003ep3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ez\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ep3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003ep3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ez\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ep3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ezyx\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"nf\"\u003enoise\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003evec2\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eK1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.366025404\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// (sqrt(3)-1)/2;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eK2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.211324865\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// (3-sqrt(3))/6;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"n\"\u003evec2\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003efloor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eK1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\t\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003evec2\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eK2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003evec2\u003c/span\u003e \u003cspan class=\"n\"\u003eo\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e?\u003c/span\u003e \u003cspan class=\"n\"\u003evec2\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mf\"\u003e1.0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003evec2\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mf\"\u003e1.0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e//vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003evec2\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eo\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eK2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003evec2\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mf\"\u003e1.0\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mf\"\u003e2.0\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eK2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003evec3\u003c/span\u003e \u003cspan class=\"n\"\u003eh\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.5\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003evec3\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edot\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003edot\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003edot\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.0\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003evec3\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003evec3\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003edot\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ehash\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.0\u003c/span\u003e\u003cspan class=\"p\"\u003e)),\u003c/span\u003e \u003cspan class=\"n\"\u003edot\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ehash\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003eo\u003c/span\u003e\u003cspan class=\"p\"\u003e)),\u003c/span\u003e \u003cspan class=\"n\"\u003edot\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ehash\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mf\"\u003e1.0\u003c/span\u003e\u003cspan class=\"p\"\u003e)));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003edot\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evec3\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mf\"\u003e70.0\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\t\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"voronoise-celular\"\u003eVoronoise (celular)\u003c/h4\u003e\n\u003cp\u003eGreat For \u003cstrong\u003e爬行动物皮肤纹理\u003c/strong\u003e或\u003cstrong\u003e干燥地砖\u003c/strong\u003e\u003c/p\u003e","title":""},{"content":"Immusia\n光照增强\n镜面反射\n相机高度\nEndless\nSpatial size: 决定一小块的面积，其中一小块中的波浪细节固定\nThe width of the ocean surface area being simulated, in meters. This also determines the size of the generated mesh, or the displaced area. Of course, you can scale the object with the Ocean modifier in Object Mode to tweak the apparent size in your scene.\nsize: scale，(displace 下)扩大原有object,可能导致mesh细节丢失\nEnvironments:\nWest lake Outside earth, rotating Plastic Beach Rooftop The Wall 其中真实场景考虑使用 photogremetry\n水面场景：待定\n虚拟场景：待定\nGesture:\n使用 Gesture 引导视频，考虑在模拟器中通过手势捕捉来录制\n使用特定 gesture 完成 immersive space 的进入\nSound Effects:\nArtwork moves Artwork fades Environment choosing Stereo videos Strawberry fields Imagine Eric Clapton Dirty Harry Something Song 2 宣传视频 订阅管理 ","permalink":"https://mickjagger19.github.io/posts/misc/immusia-todolist/","summary":"\u003cp\u003e\u003cstrong\u003eImmusia\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e光照增强\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e镜面反射\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e相机高度\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eEndless\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSpatial size: 决定一小块的面积，其中一小块中的波浪细节固定\u003c/p\u003e\n\u003cp\u003eThe width of the ocean surface area being simulated, in meters. This also determines the size of the generated mesh, or the displaced area. Of course, you can scale the object with the Ocean modifier in Object Mode to tweak the apparent size in your scene.\u003c/p\u003e\n\u003cp\u003esize: scale，(displace 下)扩大原有object,可能导致mesh细节丢失\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eEnvironments:\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWest lake\u003c/li\u003e\n\u003cli\u003eOutside earth, rotating\u003c/li\u003e\n\u003cli\u003ePlastic Beach\u003c/li\u003e\n\u003cli\u003eRooftop\u003c/li\u003e\n\u003cli\u003eThe Wall\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e其中真实场景考虑使用 photogremetry\u003c/p\u003e","title":""}]